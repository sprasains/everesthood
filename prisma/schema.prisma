// This is your new, comprehensive schema for a large-scale social app.
// Replace the existing content of prisma/schema.prisma with this.

datasource db {
  provider     = "postgresql"
  url          = env("DATABASE_URL")
  relationMode = "prisma"
}

generator client {
  provider = "prisma-client-js"
}

// Core User and Auth Models
model User {
  id                     String            @id @default(cuid())
  name                   String?
  email                  String?           @unique
  emailVerified          DateTime?
  password               String?
  image                  String?           // Default avatar from OAuth
  profilePicture         String?           // User-uploaded profile picture
  coverPicture           String?           // User-uploaded cover photo
  bio                    String?           @db.Text
  createdAt              DateTime          @default(now())
  updatedAt              DateTime          @updatedAt
  accounts               Account[]
  sessions               Session[]
  posts                  Post[]
  comments               Comment[]
  commentLikes           CommentLike[]
  postLikes              PostLike[]
  sentFriendships        Friendship[]      @relation("sentFriendships")
  receivedFriendships    Friendship[]      @relation("receivedFriendships")
  ownedCircles           Circle[]
  circleMemberships      CircleMembership[]
  jobApplications        JobApplication[]
  ownedCompany           Company?
  apiKey                 ApiKey[]
  customPersonas         CustomPersona[]
  userAchievements       UserAchievement[]
  votes                  Vote[]
  notifications          Notification[]     @relation("notifications")
  triggeredNotifications Notification[]     @relation("triggeredNotifications")

  // Monetization Fields
  stripeCustomerId       String?           @unique
  stripeSubscriptionId   String?           @unique
  stripePriceId          String?
  stripeCurrentPeriodEnd DateTime?
  subscriptionTier       SubscriptionTier  @default(FREE)
}

model Account {
  id                String  @id @default(cuid())
  userId            String
  type              String
  provider          String
  providerAccountId String
  refresh_token     String? @db.Text
  access_token      String? @db.Text
  expires_at        Int?
  token_type        String?
  scope             String?
  id_token          String? @db.Text
  session_state     String?
  user              User    @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([provider, providerAccountId])
  @@index([userId])
}

model Session {
  id           String   @id @default(cuid())
  sessionToken String   @unique
  userId       String
  expires      DateTime
  user         User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
}

model VerificationToken {
  identifier String
  token      String   @unique
  expires    DateTime

  @@unique([identifier, token])
}

// Content and Engagement Models
model Post {
  id             String     @id @default(cuid())
  title          String?
  content        Json? // Temporarily make content optional for migration
  authorId       String
  createdAt      DateTime   @default(now())
  updatedAt      DateTime   @updatedAt
  type           PostType   @default(TEXT)
  mediaUrls      String[]
  metadata       Json?
  author         User       @relation(fields: [authorId], references: [id], onDelete: Cascade)
  comments       Comment[]
  likes          PostLike[]
  poll           Poll?
  resharedFromId String?
  resharedFrom   Post?      @relation("Reshares", fields: [resharedFromId], references: [id], onDelete: Restrict, onUpdate: Restrict)
  reshares       Post[]     @relation("Reshares")

  @@index([authorId])
  @@index([createdAt])
}

model PostLike {
  userId    String
  postId    String
  createdAt DateTime @default(now())
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  post      Post     @relation(fields: [postId], references: [id], onDelete: Cascade)

  @@id([userId, postId])
  @@index([postId])
}

model Comment {
  id        String        @id @default(cuid())
  content   String
  createdAt DateTime      @default(now())
  authorId  String
  postId    String
  parentId  String?
  author    User          @relation(fields: [authorId], references: [id], onDelete: Cascade)
  post      Post          @relation(fields: [postId], references: [id], onDelete: Cascade)
  parent    Comment?      @relation("Replies", fields: [parentId], references: [id], onDelete: Restrict, onUpdate: Restrict)
  replies   Comment[]     @relation("Replies")
  likes     CommentLike[]
}

model CommentLike {
  userId    String
  commentId String
  user      User    @relation(fields: [userId], references: [id], onDelete: Cascade)
  comment   Comment @relation(fields: [commentId], references: [id], onDelete: Cascade)

  @@id([userId, commentId])
}

// Social Graph Models
model Friendship {
  requesterId String
  receiverId  String
  status      FriendshipStatus @default(PENDING) // PENDING, ACCEPTED, DECLINED, BLOCKED
  createdAt   DateTime         @default(now())
  updatedAt   DateTime         @updatedAt
  requester   User             @relation("sentFriendships", fields: [requesterId], references: [id], onDelete: Cascade)
  receiver    User             @relation("receivedFriendships", fields: [receiverId], references: [id], onDelete: Cascade)

  @@id([requesterId, receiverId])
  @@index([receiverId])
}

// Gamification Models
model Achievement {
  id               String            @id @default(cuid())
  name             String            @unique
  description      String
  icon             String
  xpReward         Int
  userAchievements UserAchievement[]
}

model UserAchievement {
  id            String      @id @default(cuid())
  userId        String
  achievementId String
  earnedAt      DateTime    @default(now())
  user          User        @relation(fields: [userId], references: [id], onDelete: Cascade)
  achievement   Achievement @relation(fields: [achievementId], references: [id], onDelete: Cascade)

  @@unique([userId, achievementId])
}

// Auxiliary and Feature Models
model Poll {
  id       String       @id @default(cuid())
  question String
  postId   String       @unique
  post     Post         @relation(fields: [postId], references: [id], onDelete: Cascade)
  options  PollOption[]
}

model PollOption {
  id     String @id @default(cuid())
  text   String
  pollId String
  poll   Poll   @relation(fields: [pollId], references: [id], onDelete: Cascade)
  votes  Vote[]
}

model Vote {
  userId       String
  pollOptionId String
  createdAt    DateTime   @default(now())
  user         User       @relation(fields: [userId], references: [id], onDelete: Cascade)
  pollOption   PollOption @relation(fields: [pollOptionId], references: [id], onDelete: Cascade)

  @@id([userId, pollOptionId])
}

model Circle {
  id          String             @id @default(cuid())
  name        String
  ownerId     String
  owner       User               @relation(fields: [ownerId], references: [id])
  memberships CircleMembership[]
}

model CircleMembership {
  circleId String
  userId   String
  circle   Circle @relation(fields: [circleId], references: [id], onDelete: Cascade)
  user     User   @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@id([circleId, userId])
}

model Company {
  id          String @id @default(cuid())
  name        String
  description String
  websiteUrl  String?
  logoUrl     String?
  ownerId     String @unique
  owner       User   @relation(fields: [ownerId], references: [id])
  jobs        Job[]
}

model Job {
  id           String         @id @default(cuid())
  title        String
  description  String         @db.Text // Ensure description is Text for long postings
  location     String
  type         String
  salaryRange  String?
  isActive     Boolean        @default(true)
  isFeatured   Boolean        @default(false)
  createdAt    DateTime       @default(now())
  
  // --- MODIFICATIONS & ADDITIONS ---
  companyId    String?        // Make this optional
  companyName  String         // Add a field to store the company name directly
  externalUrl  String?        @unique // The direct link to the job post, must be unique
  source       String?        // e.g., "Stack Overflow Jobs"
  publishedAt  DateTime?
  // Keep the relation, but it's now optional
  company      Company?       @relation(fields: [companyId], references: [id])
  applications JobApplication[]

  @@index([companyId])
}

model JobApplication {
  id          String   @id @default(cuid())
  status      String   @default("SUBMITTED")
  appliedAt   DateTime @default(now())
  applicantId String
  jobId       String
  applicant   User     @relation(fields: [applicantId], references: [id])
  job         Job      @relation(fields: [jobId], references: [id])

  @@unique([applicantId, jobId])
}

model ApiKey {
  id        String   @id @default(cuid())
  key       String   @unique
  createdAt DateTime @default(now())
  userId    String
  user      User     @relation(fields: [userId], references: [id])
}

model CustomPersona {
  id        String   @id @default(cuid())
  name      String
  prompt    String
  icon      String?
  createdAt DateTime @default(now())
  ownerId   String
  owner     User     @relation(fields: [ownerId], references: [id], onDelete: Cascade)

  @@index([ownerId])
}

model Notification {
  id           String           @id @default(cuid())
  recipientId  String
  actorId      String
  type         NotificationType
  entityId     String?
  isRead       Boolean          @default(false)
  createdAt    DateTime         @default(now())

  recipient    User             @relation("notifications", fields: [recipientId], references: [id], onDelete: Cascade)
  actor        User             @relation("triggeredNotifications", fields: [actorId], references: [id], onDelete: Cascade)

  @@index([recipientId])
}

model NewsArticle {
  id           String    @id @default(cuid())
  title        String
  link         String    @unique
  description  String?   @db.Text
  imageUrl     String?
  publishedAt  DateTime?
  sourceName   String
  createdAt    DateTime  @default(now())
  // Added for GenZ content and categorization
  category     String?   // e.g. 'ai', 'startup', 'culture', etc.
  tags         String[]  // Array of tags/keywords
  content      String?   @db.Text // Full article content if available

  @@index([publishedAt])
}

// Enums
enum PostType {
  TEXT
  POLL
  LINK
  PREDICTION
  IMAGE
  VIDEO
}

enum SubscriptionTier {
  FREE
  PREMIUM
  CREATOR
}

enum FriendshipStatus {
  PENDING
  ACCEPTED
  DECLINED
  BLOCKED
}

enum NotificationType {
  FRIEND_REQUEST
  FRIEND_ACCEPT
  POST_LIKE
  NEW_COMMENT
}
