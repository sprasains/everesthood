/*! For license information please see worker-1VsTvM69je7rIagmlxVoo.js.LICENSE.txt */
(()=>{var e=[,(e,t,n)=>{"use strict";n.r(t),n.d(t,{AsyncFifoQueue:()=>r.AsyncFifoQueue,Backoffs:()=>r.Backoffs,Child:()=>r.Child,ChildCommand:()=>i.ChildCommand,ChildPool:()=>r.ChildPool,ChildProcessor:()=>r.ChildProcessor,ClientType:()=>a.ClientType,DELAYED_ERROR:()=>r.DELAYED_ERROR,DELAY_TIME_1:()=>s.DELAY_TIME_1,DELAY_TIME_5:()=>s.DELAY_TIME_5,DelayedError:()=>r.DelayedError,ErrorCode:()=>i.ErrorCode,FlowProducer:()=>r.FlowProducer,Job:()=>r.Job,JobScheduler:()=>r.JobScheduler,MetricsTime:()=>i.MetricsTime,PRIORITY_LIMIT:()=>r.PRIORITY_LIMIT,ParentCommand:()=>i.ParentCommand,QUEUE_EVENT_SUFFIX:()=>s.QUEUE_EVENT_SUFFIX,Queue:()=>r.Queue,QueueBase:()=>r.QueueBase,QueueEvents:()=>r.QueueEvents,QueueEventsProducer:()=>r.QueueEventsProducer,QueueGetters:()=>r.QueueGetters,QueueKeys:()=>r.QueueKeys,RATE_LIMIT_ERROR:()=>r.RATE_LIMIT_ERROR,RateLimitError:()=>r.RateLimitError,RedisConnection:()=>r.RedisConnection,Repeat:()=>r.Repeat,Scripts:()=>r.Scripts,SpanKind:()=>i.SpanKind,TelemetryAttributes:()=>i.TelemetryAttributes,UNRECOVERABLE_ERROR:()=>r.UNRECOVERABLE_ERROR,UnrecoverableError:()=>r.UnrecoverableError,WAITING_CHILDREN_ERROR:()=>r.WAITING_CHILDREN_ERROR,WAITING_ERROR:()=>r.WAITING_ERROR,WaitingChildrenError:()=>r.WaitingChildrenError,WaitingError:()=>r.WaitingError,Worker:()=>r.Worker,array2obj:()=>s.array2obj,asyncSend:()=>s.asyncSend,childSend:()=>s.childSend,clientCommandMessageReg:()=>s.clientCommandMessageReg,createScripts:()=>s.createScripts,decreaseMaxListeners:()=>s.decreaseMaxListeners,defaultRepeatStrategy:()=>r.defaultRepeatStrategy,delay:()=>s.delay,errorObject:()=>s.errorObject,errorToJSON:()=>s.errorToJSON,getNextMillis:()=>r.getNextMillis,getParentKey:()=>s.getParentKey,increaseMaxListeners:()=>s.increaseMaxListeners,invertObject:()=>s.invertObject,isEmpty:()=>s.isEmpty,isNotConnectionError:()=>s.isNotConnectionError,isRedisCluster:()=>s.isRedisCluster,isRedisInstance:()=>s.isRedisInstance,isRedisVersionLowerThan:()=>s.isRedisVersionLowerThan,lengthInUtf8Bytes:()=>s.lengthInUtf8Bytes,objectToFlatArray:()=>s.objectToFlatArray,optsDecodeMap:()=>s.optsDecodeMap,optsEncodeMap:()=>s.optsEncodeMap,parseObjectValues:()=>s.parseObjectValues,raw2NextJobData:()=>r.raw2NextJobData,removeAllQueueData:()=>s.removeAllQueueData,removeUndefinedFields:()=>s.removeUndefinedFields,toString:()=>s.toString,trace:()=>s.trace,tryCatch:()=>s.tryCatch});var r=n(2),i=n(8),a=n(227),s=(n(257),n(18))},(e,t,n)=>{"use strict";n.r(t),n.d(t,{AsyncFifoQueue:()=>r.AsyncFifoQueue,Backoffs:()=>i.Backoffs,Child:()=>a.Child,ChildPool:()=>s.ChildPool,ChildProcessor:()=>o.ChildProcessor,DELAYED_ERROR:()=>l.DELAYED_ERROR,DelayedError:()=>l.DelayedError,FlowProducer:()=>d.FlowProducer,Job:()=>c.Job,JobScheduler:()=>u.JobScheduler,PRIORITY_LIMIT:()=>c.PRIORITY_LIMIT,Queue:()=>b.Queue,QueueBase:()=>p.QueueBase,QueueEvents:()=>h.QueueEvents,QueueEventsProducer:()=>y.QueueEventsProducer,QueueGetters:()=>m.QueueGetters,QueueKeys:()=>f.QueueKeys,RATE_LIMIT_ERROR:()=>l.RATE_LIMIT_ERROR,RateLimitError:()=>l.RateLimitError,RedisConnection:()=>g.RedisConnection,Repeat:()=>v.Repeat,Scripts:()=>K.Scripts,UNRECOVERABLE_ERROR:()=>l.UNRECOVERABLE_ERROR,UnrecoverableError:()=>l.UnrecoverableError,WAITING_CHILDREN_ERROR:()=>l.WAITING_CHILDREN_ERROR,WAITING_ERROR:()=>l.WAITING_ERROR,WaitingChildrenError:()=>l.WaitingChildrenError,WaitingError:()=>l.WaitingError,Worker:()=>E.Worker,defaultRepeatStrategy:()=>u.defaultRepeatStrategy,getNextMillis:()=>v.getNextMillis,raw2NextJobData:()=>K.raw2NextJobData});var r=n(3),i=n(4),a=n(5),s=n(15),o=n(17),l=n(140),d=n(146),c=n(147),u=n(206),p=n(216),h=n(217),y=n(218),m=n(219),f=n(149),b=n(220),g=n(150),v=n(221),K=(n(223),n(83)),E=n(224)},(e,t,n)=>{"use strict";n.r(t),n.d(t,{AsyncFifoQueue:()=>a});class r{constructor(e){this.value=void 0,this.next=null,this.value=e}}class i{constructor(){this.length=0,this.head=null,this.tail=null}push(e){const t=new r(e);return this.length?this.tail.next=t:this.head=t,this.tail=t,this.length+=1,t}shift(){if(this.length){const e=this.head;return this.head=this.head.next,this.length-=1,e}return null}}class a{constructor(e=!1){this.ignoreErrors=e,this.queue=new i,this.pending=new Set,this.newPromise()}add(e){this.pending.add(e),e.then(t=>{this.pending.delete(e),0===this.queue.length&&this.resolvePromise(t),this.queue.push(t)}).catch(t=>{this.ignoreErrors&&this.queue.push(void 0),this.pending.delete(e),this.rejectPromise(t)})}async waitAll(){await Promise.all(this.pending)}numTotal(){return this.pending.size+this.queue.length}numPending(){return this.pending.size}numQueued(){return this.queue.length}resolvePromise(e){this.resolve(e),this.newPromise()}rejectPromise(e){this.reject(e),this.newPromise()}newPromise(){this.nextPromise=new Promise((e,t)=>{this.resolve=e,this.reject=t})}async wait(){return this.nextPromise}async fetch(){var e;if(0!==this.pending.size||0!==this.queue.length){for(;0===this.queue.length;)try{await this.wait()}catch(e){this.ignoreErrors||console.error("Unexpected Error in AsyncFifoQueue",e)}return null===(e=this.queue.shift())||void 0===e?void 0:e.value}}}},(e,t,n)=>{"use strict";n.r(t),n.d(t,{Backoffs:()=>r});class r{static normalize(e){return Number.isFinite(e)?{type:"fixed",delay:e}:e||void 0}static calculate(e,t,n,i,a){if(e){const s=function(e,t){if(e.type in r.builtinStrategies)return r.builtinStrategies[e.type](e.delay,e.jitter);if(t)return t;throw new Error(`Unknown backoff strategy ${e.type}.\n      If a custom backoff strategy is used, specify it when the queue is created.`)}(e,a);return s(t,e.type,n,i)}}}r.builtinStrategies={fixed:function(e,t=0){return function(){if(t>0){const n=e*(1-t);return Math.floor(Math.random()*e*t+n)}return e}},exponential:function(e,t=0){return function(n){if(t>0){const r=Math.round(Math.pow(2,n-1)*e),i=r*(1-t);return Math.floor(Math.random()*r*t+i)}return Math.round(Math.pow(2,n-1)*e)}}}},(e,t,n)=>{"use strict";n.r(t),n.d(t,{Child:()=>l});var r=n(6),i=n(7);Object(function(){var e=new Error("Cannot find module 'worker_threads'");throw e.code="MODULE_NOT_FOUND",e}());var a=n(8),s=n(14);const o={1:"Uncaught Fatal Exception",2:"Unused",3:"Internal JavaScript Parse Error",4:"Internal JavaScript Evaluation Failure",5:"Fatal Error",6:"Non-function Internal Exception Handler",7:"Internal Exception Handler Run-Time Failure",8:"Unused",9:"Invalid Argument",10:"Internal JavaScript Run-Time Failure",12:"Invalid Debug Argument",13:"Unfinished Top-Level Await"};class l extends s.EventEmitter{constructor(e,t,n={useWorkerThreads:!1}){super(),this.mainFile=e,this.processFile=t,this.opts=n,this._exitCode=null,this._signalCode=null,this._killed=!1}get pid(){if(this.childProcess)return this.childProcess.pid;if(this.worker)return Math.abs(this.worker.threadId);throw new Error("No child process or worker thread")}get exitCode(){return this._exitCode}get signalCode(){return this._signalCode}get killed(){return this.childProcess?this.childProcess.killed:this._killed}async init(){const e=await c(process.execArgv);let t;this.opts.useWorkerThreads?this.worker=t=new Object(function(){var e=new Error("Cannot find module 'worker_threads'");throw e.code="MODULE_NOT_FOUND",e}())(this.mainFile,Object.assign({execArgv:e,stdin:!0,stdout:!0,stderr:!0},this.opts.workerThreadsOptions?this.opts.workerThreadsOptions:{})):this.childProcess=t=(0,r.fork)(this.mainFile,[],Object.assign({execArgv:e,stdio:"pipe"},this.opts.workerForkOptions?this.opts.workerForkOptions:{})),t.on("exit",(e,n)=>{this._exitCode=e,n=void 0===n?null:n,this._signalCode=n,this._killed=!0,this.emit("exit",e,n),t.removeAllListeners(),this.removeAllListeners()}),t.on("error",(...e)=>this.emit("error",...e)),t.on("message",(...e)=>this.emit("message",...e)),t.on("close",(...e)=>this.emit("close",...e)),t.stdout.pipe(process.stdout),t.stderr.pipe(process.stderr),await this.initChild()}async send(e){return new Promise((t,n)=>{this.childProcess?this.childProcess.send(e,e=>{e?n(e):t()}):this.worker?t(this.worker.postMessage(e)):t()})}killProcess(e="SIGKILL"){this.childProcess?this.childProcess.kill(e):this.worker&&this.worker.terminate()}async kill(e="SIGKILL",t){if(this.hasProcessExited())return;const n=(r=this.childProcess||this.worker,new Promise(e=>{r.once("exit",()=>e())}));var r;if(this.killProcess(e),void 0!==t&&(0===t||isFinite(t))){const e=setTimeout(()=>{this.hasProcessExited()||this.killProcess("SIGKILL")},t);await n,clearTimeout(e)}await n}async initChild(){const e=new Promise((e,t)=>{const n=i=>{if(i.cmd===a.ParentCommand.InitCompleted)e();else if(i.cmd===a.ParentCommand.InitFailed){const e=new Error;e.stack=i.err.stack,e.message=i.err.message,t(e)}this.off("message",n),this.off("close",r)},r=(e,i)=>{e>128&&(e-=128);t(new Error(`Error initializing child: ${o[e]||`Unknown exit code ${e}`} and signal ${i}`)),this.off("message",n),this.off("close",r)};this.on("message",n),this.on("close",r)});await this.send({cmd:a.ChildCommand.Init,value:this.processFile}),await e}hasProcessExited(){return!(null===this.exitCode&&!this.signalCode)}}const d=async()=>new Promise(e=>{const t=(0,i.createServer)();t.listen(0,()=>{const{port:n}=t.address();t.close(()=>e(n))})}),c=async e=>{const t=[],n=[];for(let r=0;r<e.length;r++){const i=e[r];if(-1===i.indexOf("--inspect"))t.push(i);else{const e=i.split("=")[0],t=await d();n.push(`${e}=${t}`)}}return t.concat(n)}},()=>{},()=>{},(e,t,n)=>{"use strict";n.r(t),n.d(t,{ChildCommand:()=>r.ChildCommand,ErrorCode:()=>i.ErrorCode,MetricsTime:()=>s.MetricsTime,ParentCommand:()=>a.ParentCommand,SpanKind:()=>o.SpanKind,TelemetryAttributes:()=>o.TelemetryAttributes});var r=n(9),i=n(10),a=n(11),s=n(12),o=n(13)},(e,t,n)=>{"use strict";var r;n.r(t),n.d(t,{ChildCommand:()=>r}),function(e){e[e.Init=0]="Init",e[e.Start=1]="Start",e[e.Stop=2]="Stop",e[e.GetChildrenValuesResponse=3]="GetChildrenValuesResponse",e[e.GetIgnoredChildrenFailuresResponse=4]="GetIgnoredChildrenFailuresResponse"}(r||(r={}))},(e,t,n)=>{"use strict";var r;n.r(t),n.d(t,{ErrorCode:()=>r}),function(e){e[e.JobNotExist=-1]="JobNotExist",e[e.JobLockNotExist=-2]="JobLockNotExist",e[e.JobNotInState=-3]="JobNotInState",e[e.JobPendingChildren=-4]="JobPendingChildren",e[e.ParentJobNotExist=-5]="ParentJobNotExist",e[e.JobLockMismatch=-6]="JobLockMismatch",e[e.ParentJobCannotBeReplaced=-7]="ParentJobCannotBeReplaced",e[e.JobBelongsToJobScheduler=-8]="JobBelongsToJobScheduler",e[e.JobFailedChildren=-9]="JobFailedChildren"}(r||(r={}))},(e,t,n)=>{"use strict";var r;n.r(t),n.d(t,{ParentCommand:()=>r}),function(e){e[e.Completed=0]="Completed",e[e.Error=1]="Error",e[e.Failed=2]="Failed",e[e.InitFailed=3]="InitFailed",e[e.InitCompleted=4]="InitCompleted",e[e.Log=5]="Log",e[e.MoveToDelayed=6]="MoveToDelayed",e[e.MoveToWait=7]="MoveToWait",e[e.Progress=8]="Progress",e[e.Update=9]="Update",e[e.GetChildrenValues=10]="GetChildrenValues",e[e.GetIgnoredChildrenFailures=11]="GetIgnoredChildrenFailures"}(r||(r={}))},(e,t,n)=>{"use strict";var r;n.r(t),n.d(t,{MetricsTime:()=>r}),function(e){e[e.ONE_MINUTE=1]="ONE_MINUTE",e[e.FIVE_MINUTES=5]="FIVE_MINUTES",e[e.FIFTEEN_MINUTES=15]="FIFTEEN_MINUTES",e[e.THIRTY_MINUTES=30]="THIRTY_MINUTES",e[e.ONE_HOUR=60]="ONE_HOUR",e[e.ONE_WEEK=10080]="ONE_WEEK",e[e.TWO_WEEKS=20160]="TWO_WEEKS",e[e.ONE_MONTH=80640]="ONE_MONTH"}(r||(r={}))},(e,t,n)=>{"use strict";var r,i;n.r(t),n.d(t,{SpanKind:()=>i,TelemetryAttributes:()=>r}),function(e){e.QueueName="bullmq.queue.name",e.QueueOperation="bullmq.queue.operation",e.BulkCount="bullmq.job.bulk.count",e.BulkNames="bullmq.job.bulk.names",e.JobName="bullmq.job.name",e.JobId="bullmq.job.id",e.JobKey="bullmq.job.key",e.JobIds="bullmq.job.ids",e.DeduplicationKey="bullmq.job.deduplication.key",e.JobOptions="bullmq.job.options",e.JobProgress="bullmq.job.progress",e.QueueDrainDelay="bullmq.queue.drain.delay",e.QueueGrace="bullmq.queue.grace",e.QueueCleanLimit="bullmq.queue.clean.limit",e.QueueRateLimit="bullmq.queue.rate.limit",e.JobType="bullmq.job.type",e.QueueOptions="bullmq.queue.options",e.QueueEventMaxLength="bullmq.queue.event.max.length",e.WorkerOptions="bullmq.worker.options",e.WorkerName="bullmq.worker.name",e.WorkerId="bullmq.worker.id",e.WorkerRateLimit="bullmq.worker.rate.limit",e.WorkerDoNotWaitActive="bullmq.worker.do.not.wait.active",e.WorkerForceClose="bullmq.worker.force.close",e.WorkerStalledJobs="bullmq.worker.stalled.jobs",e.WorkerFailedJobs="bullmq.worker.failed.jobs",e.WorkerJobsToExtendLocks="bullmq.worker.jobs.to.extend.locks",e.JobFinishedTimestamp="bullmq.job.finished.timestamp",e.JobProcessedTimestamp="bullmq.job.processed.timestamp",e.JobResult="bullmq.job.result",e.JobFailedReason="bullmq.job.failed.reason",e.FlowName="bullmq.flow.name",e.JobSchedulerId="bullmq.job.scheduler.id"}(r||(r={})),function(e){e[e.INTERNAL=0]="INTERNAL",e[e.SERVER=1]="SERVER",e[e.CLIENT=2]="CLIENT",e[e.PRODUCER=3]="PRODUCER",e[e.CONSUMER=4]="CONSUMER"}(i||(i={}))},e=>{"use strict";var t,n="object"==typeof Reflect?Reflect:null,r=n&&"function"==typeof n.apply?n.apply:function(e,t,n){return Function.prototype.apply.call(e,t,n)};t=n&&"function"==typeof n.ownKeys?n.ownKeys:Object.getOwnPropertySymbols?function(e){return Object.getOwnPropertyNames(e).concat(Object.getOwnPropertySymbols(e))}:function(e){return Object.getOwnPropertyNames(e)};var i=Number.isNaN||function(e){return e!=e};function a(){a.init.call(this)}e.exports=a,e.exports.once=function(e,t){return new Promise(function(n,r){function i(n){e.removeListener(t,a),r(n)}function a(){"function"==typeof e.removeListener&&e.removeListener("error",i),n([].slice.call(arguments))}m(e,t,a,{once:!0}),"error"!==t&&function(e,t,n){"function"==typeof e.on&&m(e,"error",t,n)}(e,i,{once:!0})})},a.EventEmitter=a,a.prototype._events=void 0,a.prototype._eventsCount=0,a.prototype._maxListeners=void 0;var s=10;function o(e){if("function"!=typeof e)throw new TypeError('The "listener" argument must be of type Function. Received type '+typeof e)}function l(e){return void 0===e._maxListeners?a.defaultMaxListeners:e._maxListeners}function d(e,t,n,r){var i,a,s,d;if(o(n),void 0===(a=e._events)?(a=e._events=Object.create(null),e._eventsCount=0):(void 0!==a.newListener&&(e.emit("newListener",t,n.listener?n.listener:n),a=e._events),s=a[t]),void 0===s)s=a[t]=n,++e._eventsCount;else if("function"==typeof s?s=a[t]=r?[n,s]:[s,n]:r?s.unshift(n):s.push(n),(i=l(e))>0&&s.length>i&&!s.warned){s.warned=!0;var c=new Error("Possible EventEmitter memory leak detected. "+s.length+" "+String(t)+" listeners added. Use emitter.setMaxListeners() to increase limit");c.name="MaxListenersExceededWarning",c.emitter=e,c.type=t,c.count=s.length,d=c,console&&console.warn&&console.warn(d)}return e}function c(){if(!this.fired)return this.target.removeListener(this.type,this.wrapFn),this.fired=!0,0===arguments.length?this.listener.call(this.target):this.listener.apply(this.target,arguments)}function u(e,t,n){var r={fired:!1,wrapFn:void 0,target:e,type:t,listener:n},i=c.bind(r);return i.listener=n,r.wrapFn=i,i}function p(e,t,n){var r=e._events;if(void 0===r)return[];var i=r[t];return void 0===i?[]:"function"==typeof i?n?[i.listener||i]:[i]:n?function(e){for(var t=new Array(e.length),n=0;n<t.length;++n)t[n]=e[n].listener||e[n];return t}(i):y(i,i.length)}function h(e){var t=this._events;if(void 0!==t){var n=t[e];if("function"==typeof n)return 1;if(void 0!==n)return n.length}return 0}function y(e,t){for(var n=new Array(t),r=0;r<t;++r)n[r]=e[r];return n}function m(e,t,n,r){if("function"==typeof e.on)r.once?e.once(t,n):e.on(t,n);else{if("function"!=typeof e.addEventListener)throw new TypeError('The "emitter" argument must be of type EventEmitter. Received type '+typeof e);e.addEventListener(t,function i(a){r.once&&e.removeEventListener(t,i),n(a)})}}Object.defineProperty(a,"defaultMaxListeners",{enumerable:!0,get:function(){return s},set:function(e){if("number"!=typeof e||e<0||i(e))throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received '+e+".");s=e}}),a.init=function(){void 0!==this._events&&this._events!==Object.getPrototypeOf(this)._events||(this._events=Object.create(null),this._eventsCount=0),this._maxListeners=this._maxListeners||void 0},a.prototype.setMaxListeners=function(e){if("number"!=typeof e||e<0||i(e))throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received '+e+".");return this._maxListeners=e,this},a.prototype.getMaxListeners=function(){return l(this)},a.prototype.emit=function(e){for(var t=[],n=1;n<arguments.length;n++)t.push(arguments[n]);var i="error"===e,a=this._events;if(void 0!==a)i=i&&void 0===a.error;else if(!i)return!1;if(i){var s;if(t.length>0&&(s=t[0]),s instanceof Error)throw s;var o=new Error("Unhandled error."+(s?" ("+s.message+")":""));throw o.context=s,o}var l=a[e];if(void 0===l)return!1;if("function"==typeof l)r(l,this,t);else{var d=l.length,c=y(l,d);for(n=0;n<d;++n)r(c[n],this,t)}return!0},a.prototype.addListener=function(e,t){return d(this,e,t,!1)},a.prototype.on=a.prototype.addListener,a.prototype.prependListener=function(e,t){return d(this,e,t,!0)},a.prototype.once=function(e,t){return o(t),this.on(e,u(this,e,t)),this},a.prototype.prependOnceListener=function(e,t){return o(t),this.prependListener(e,u(this,e,t)),this},a.prototype.removeListener=function(e,t){var n,r,i,a,s;if(o(t),void 0===(r=this._events))return this;if(void 0===(n=r[e]))return this;if(n===t||n.listener===t)0===--this._eventsCount?this._events=Object.create(null):(delete r[e],r.removeListener&&this.emit("removeListener",e,n.listener||t));else if("function"!=typeof n){for(i=-1,a=n.length-1;a>=0;a--)if(n[a]===t||n[a].listener===t){s=n[a].listener,i=a;break}if(i<0)return this;0===i?n.shift():function(e,t){for(;t+1<e.length;t++)e[t]=e[t+1];e.pop()}(n,i),1===n.length&&(r[e]=n[0]),void 0!==r.removeListener&&this.emit("removeListener",e,s||t)}return this},a.prototype.off=a.prototype.removeListener,a.prototype.removeAllListeners=function(e){var t,n,r;if(void 0===(n=this._events))return this;if(void 0===n.removeListener)return 0===arguments.length?(this._events=Object.create(null),this._eventsCount=0):void 0!==n[e]&&(0===--this._eventsCount?this._events=Object.create(null):delete n[e]),this;if(0===arguments.length){var i,a=Object.keys(n);for(r=0;r<a.length;++r)"removeListener"!==(i=a[r])&&this.removeAllListeners(i);return this.removeAllListeners("removeListener"),this._events=Object.create(null),this._eventsCount=0,this}if("function"==typeof(t=n[e]))this.removeListener(e,t);else if(void 0!==t)for(r=t.length-1;r>=0;r--)this.removeListener(e,t[r]);return this},a.prototype.listeners=function(e){return p(this,e,!0)},a.prototype.rawListeners=function(e){return p(this,e,!1)},a.listenerCount=function(e,t){return"function"==typeof e.listenerCount?e.listenerCount(t):h.call(e,t)},a.prototype.listenerCount=h,a.prototype.eventNames=function(){return this._eventsCount>0?t(this._events):[]}},(e,t,n)=>{"use strict";n.r(t),n.d(t,{ChildPool:()=>a});var r=n(16),i=n(5);class a{constructor({mainFile:e=r.join(process.cwd(),"dist/cjs/classes/main.js"),useWorkerThreads:t,workerForkOptions:n,workerThreadsOptions:i}){this.retained={},this.free={},this.opts={mainFile:e,useWorkerThreads:t,workerForkOptions:n,workerThreadsOptions:i}}async retain(e){let t=this.getFree(e).pop();if(t)return this.retained[t.pid]=t,t;t=new i.Child(this.opts.mainFile,e,{useWorkerThreads:this.opts.useWorkerThreads,workerForkOptions:this.opts.workerForkOptions,workerThreadsOptions:this.opts.workerThreadsOptions}),t.on("exit",this.remove.bind(this,t));try{if(await t.init(),null!==t.exitCode||null!==t.signalCode)throw new Error("Child exited before it could be retained");return this.retained[t.pid]=t,t}catch(e){throw console.error(e),this.release(t),e}}release(e){delete this.retained[e.pid],this.getFree(e.processFile).push(e)}remove(e){delete this.retained[e.pid];const t=this.getFree(e.processFile),n=t.indexOf(e);n>-1&&t.splice(n,1)}async kill(e,t="SIGKILL"){return this.remove(e),e.kill(t,3e4)}async clean(){const e=Object.values(this.retained).concat(this.getAllFree());this.retained={},this.free={},await Promise.all(e.map(e=>this.kill(e,"SIGTERM")))}getFree(e){return this.free[e]=this.free[e]||[]}getAllFree(){return Object.values(this.free).reduce((e,t)=>e.concat(t),[])}}},()=>{},(e,t,n)=>{"use strict";n.r(t),n.d(t,{ChildProcessor:()=>s});var r,i=n(8),a=n(18);!function(e){e[e.Idle=0]="Idle",e[e.Started=1]="Started",e[e.Terminating=2]="Terminating",e[e.Errored=3]="Errored"}(r||(r={}));class s{constructor(e,t){this.send=e,this.receiver=t}async init(e){let t;try{const{default:r}=await n(139)(e);if(t=r,t.default&&(t=t.default),"function"!=typeof t)throw new Error("No function is exported in processor file")}catch(e){return this.status=r.Errored,this.send({cmd:i.ParentCommand.InitFailed,err:(0,a.errorToJSON)(e)})}const s=t;t=function(e,t){try{return Promise.resolve(s(e,t))}catch(e){return Promise.reject(e)}},this.processor=t,this.status=r.Idle,await this.send({cmd:i.ParentCommand.InitCompleted})}async start(e,t){if(this.status!==r.Idle)return this.send({cmd:i.ParentCommand.Error,err:(0,a.errorToJSON)(new Error("cannot start a not idling child process"))});this.status=r.Started,this.currentJobPromise=(async()=>{try{const n=this.wrapJob(e,this.send),r=await this.processor(n,t);await this.send({cmd:i.ParentCommand.Completed,value:void 0===r?null:r})}catch(e){await this.send({cmd:i.ParentCommand.Failed,value:(0,a.errorToJSON)(e.message?e:new Error(e))})}finally{this.status=r.Idle,this.currentJobPromise=void 0}})()}async stop(){}async waitForCurrentJobAndExit(){this.status=r.Terminating;try{await this.currentJobPromise}finally{process.exit(process.exitCode||0)}}wrapJob(e,t){const n=Object.assign(Object.assign({},e),{data:JSON.parse(e.data||"{}"),opts:e.opts,returnValue:JSON.parse(e.returnvalue||"{}"),async updateProgress(e){this.progress=e,await t({cmd:i.ParentCommand.Progress,value:e})},log:async e=>{await t({cmd:i.ParentCommand.Log,value:e})},moveToDelayed:async(e,n)=>{await t({cmd:i.ParentCommand.MoveToDelayed,value:{timestamp:e,token:n}})},moveToWait:async e=>{await t({cmd:i.ParentCommand.MoveToWait,value:{token:e}})},updateData:async e=>{await t({cmd:i.ParentCommand.Update,value:e}),n.data=e},getChildrenValues:async()=>{const e=Math.random().toString(36).substring(2,15);return await t({requestId:e,cmd:i.ParentCommand.GetChildrenValues}),o(e,this.receiver,5e3,"getChildrenValues")},getIgnoredChildrenFailures:async()=>{const e=Math.random().toString(36).substring(2,15);return await t({requestId:e,cmd:i.ParentCommand.GetIgnoredChildrenFailures}),o(e,this.receiver,5e3,"getIgnoredChildrenFailures")}});return n}}const o=async(e,t,n,r)=>new Promise((i,a)=>{const s=n=>{n.requestId===e&&(i(n.value),t.off("message",s))};t.on("message",s),setTimeout(()=>{t.off("message",s),a(new Error(`TimeoutError: ${r} timed out in (${n}ms)`))},n)})},(e,t,n)=>{"use strict";n.r(t),n.d(t,{DELAY_TIME_1:()=>j,DELAY_TIME_5:()=>k,QUEUE_EVENT_SUFFIX:()=>M,array2obj:()=>p,asyncSend:()=>T,childSend:()=>A,clientCommandMessageReg:()=>w,createScripts:()=>O,decreaseMaxListeners:()=>E,delay:()=>y,errorObject:()=>l,errorToJSON:()=>R,getParentKey:()=>I,increaseMaxListeners:()=>m,invertObject:()=>f,isEmpty:()=>u,isNotConnectionError:()=>x,isRedisCluster:()=>K,isRedisInstance:()=>v,isRedisVersionLowerThan:()=>D,lengthInUtf8Bytes:()=>c,objectToFlatArray:()=>h,optsDecodeMap:()=>b,optsEncodeMap:()=>g,parseObjectValues:()=>C,removeAllQueueData:()=>S,removeUndefinedFields:()=>N,toString:()=>P,trace:()=>L,tryCatch:()=>d});var r=n(19),i=n(35),a=n(83),s=n(94),o=n(8);const l={value:null};function d(e,t,n){try{return e.apply(t,n)}catch(e){return l.value=e,l}}function c(e){return Buffer.byteLength(e,"utf8")}function u(e){for(const t in e)if(Object.prototype.hasOwnProperty.call(e,t))return!1;return!0}function p(e){const t={};for(let n=0;n<e.length;n+=2)t[e[n]]=e[n+1];return t}function h(e){const t=[];for(const n in e)Object.prototype.hasOwnProperty.call(e,n)&&void 0!==e[n]&&(t[t.length]=n,t[t.length]=e[n]);return t}function y(e,t){return new Promise(n=>{let r;const i=()=>{null==t||t.signal.removeEventListener("abort",i),clearTimeout(r),n()};r=setTimeout(i,e),null==t||t.signal.addEventListener("abort",i)})}function m(e,t){const n=e.getMaxListeners();e.setMaxListeners(n+t)}function f(e){return Object.entries(e).reduce((e,[t,n])=>(e[n]=t,e),{})}const b={de:"deduplication",fpof:"failParentOnFailure",cpof:"continueParentOnFailure",idof:"ignoreDependencyOnFailure",kl:"keepLogs",rdof:"removeDependencyOnFailure"},g=Object.assign(Object.assign({},f(b)),{debounce:"de"});function v(e){if(!e)return!1;return["connect","disconnect","duplicate"].every(t=>"function"==typeof e[t])}function K(e){return v(e)&&e.isCluster}function E(e,t){m(e,-t)}async function S(e,t,n=process.env.BULLMQ_TEST_PREFIX||"bull"){if(e instanceof r.Cluster)return Promise.resolve(!1);const i=`${n}:${t}:*`,a=await new Promise((t,n)=>{const r=e.scanStream({match:i});r.on("data",t=>{if(t.length){const r=e.pipeline();t.forEach(e=>{r.del(e)}),r.exec().catch(e=>{n(e)})}}),r.on("end",()=>t()),r.on("error",e=>n(e))});await a,await e.quit()}function I(e){if(e)return`${e.queue}:${e.id}`}const w=/ERR unknown command ['`]\s*client\s*['`]/,k=5e3,j=100;function x(e){const t=`${e.message}`;return t!==i.CONNECTION_CLOSED_ERROR_MSG&&!t.includes("ECONNREFUSED")}const T=(e,t)=>new Promise((n,r)=>{"function"==typeof e.send?e.send(t,e=>{e?r(e):n()}):"function"==typeof e.postMessage?n(e.postMessage(t)):n()}),A=(e,t)=>T(e,t),O=e=>new a.Scripts({keys:e.keys,client:e.client,get redisVersion(){return e.redisVersion},toKey:e.toKey,opts:e.opts,closing:e.closing}),D=(e,t)=>{const n=s.valid(s.coerce(e));return s.lt(n,t)},C=e=>{const t={};for(const n of Object.entries(e))t[n[0]]=JSON.parse(n[1]);return t},R=e=>{const t={};return Object.getOwnPropertyNames(e).forEach(function(n){t[n]=e[n]}),JSON.parse(JSON.stringify(t,(e=>{const t=new WeakSet;return t.add(e),(e,n)=>{if("object"==typeof n&&null!==n){if(t.has(n))return"[Circular]";t.add(n)}return n}})(e)))},P=e=>{if(null==e)return"";if("string"==typeof e)return e;if(Array.isArray(e))return`${e.map(e=>null==e?e:P(e))}`;if("symbol"==typeof e||"[object Symbol]"==Object.prototype.toString.call(e))return e.toString();const t=`${e}`;return"0"===t&&1/e==-1/0?"-0":t},M=":qe";function N(e){const t={};for(const n in e)void 0!==e[n]&&(t[n]=e[n]);return t}async function L(e,t,n,r,i,a,s){if(!e)return a();{const{tracer:l,contextManager:d}=e,c=d.active();let u;s&&(u=d.fromMetadata(c,s));const p=i?`${r} ${i}`:r,h=l.startSpan(p,{kind:t},u);try{let e,i;return h.setAttributes({[o.TelemetryAttributes.QueueName]:n,[o.TelemetryAttributes.QueueOperation]:r}),e=t===o.SpanKind.CONSUMER&&u?h.setSpanOnContext(u):h.setSpanOnContext(c),2==a.length&&(i=d.getMetadata(e)),await d.with(e,()=>a(h,i))}catch(e){throw h.recordException(e),e}finally{h.end()}}}},(e,t,n)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.print=t.ReplyError=t.SentinelIterator=t.SentinelConnector=t.AbstractConnector=t.Pipeline=t.ScanStream=t.Command=t.Cluster=t.Redis=t.default=void 0,t=e.exports=n(20).default;var r=n(20);Object.defineProperty(t,"default",{enumerable:!0,get:function(){return r.default}});var i=n(20);Object.defineProperty(t,"Redis",{enumerable:!0,get:function(){return i.default}});var a=n(29);Object.defineProperty(t,"Cluster",{enumerable:!0,get:function(){return a.default}});var s=n(33);Object.defineProperty(t,"Command",{enumerable:!0,get:function(){return s.default}});var o=n(45);Object.defineProperty(t,"ScanStream",{enumerable:!0,get:function(){return o.default}});var l=n(48);Object.defineProperty(t,"Pipeline",{enumerable:!0,get:function(){return l.default}});var d=n(67);Object.defineProperty(t,"AbstractConnector",{enumerable:!0,get:function(){return d.default}});var c=n(68);Object.defineProperty(t,"SentinelConnector",{enumerable:!0,get:function(){return c.default}}),Object.defineProperty(t,"SentinelIterator",{enumerable:!0,get:function(){return c.SentinelIterator}}),t.ReplyError=n(30).ReplyError,Object.defineProperty(t,"Promise",{get:()=>(console.warn("ioredis v5 does not support plugging third-party Promise library anymore. Native Promise will be used."),Promise),set(e){console.warn("ioredis v5 does not support plugging third-party Promise library anymore. Native Promise will be used.")}}),t.print=function(e,t){e?console.log("Error: "+e):console.log("Reply: "+t)}},(e,t,n)=>{"use strict";var r=n(21);function i(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter(function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable})),n.push.apply(n,r)}return n}function a(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?i(Object(n),!0).forEach(function(t){r(e,t,n[t])}):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach(function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))})}return e}Object.defineProperty(t,"__esModule",{value:!0});const s=n(25),o=n(14),l=n(27),d=n(29),c=n(33),u=n(63),p=n(68),h=n(73),y=n(82),m=n(45),f=n(47),b=n(35),g=n(53),v=n(49),K=n(36),E=n(61),S=(0,b.Debug)("redis");class I extends v.default{constructor(e,t,n){if(super(),this.status="wait",this.isCluster=!1,this.reconnectTimeout=null,this.connectionEpoch=0,this.retryAttempts=0,this.manuallyClosing=!1,this._autoPipelines=new Map,this._runningAutoPipelines=new Set,this.parseOptions(e,t,n),o.EventEmitter.call(this),this.resetCommandQueue(),this.resetOfflineQueue(),this.options.Connector)this.connector=new this.options.Connector(this.options);else if(this.options.sentinels){const e=new p.default(this.options);e.emitter=this,this.connector=e}else this.connector=new u.StandaloneConnector(this.options);this.options.scripts&&Object.entries(this.options.scripts).forEach(([e,t])=>{this.defineCommand(e,t)}),this.options.lazyConnect?this.setStatus("wait"):this.connect().catch(K.noop)}static createClient(...e){return new I(...e)}get autoPipelineQueueSize(){let e=0;for(const t of this._autoPipelines.values())e+=t.length;return e}connect(e){const t=new Promise((e,t)=>{if("connecting"===this.status||"connect"===this.status||"ready"===this.status)return void t(new Error("Redis is already connecting/connected"));this.connectionEpoch+=1,this.setStatus("connecting");const{options:n}=this;this.condition={select:n.db,auth:n.username?[n.username,n.password]:n.password,subscriber:!1};const r=this;(0,l.default)(this.connector.connect(function(e,t){r.silentEmit(e,t)}),function(i,a){if(i)return r.flushQueue(i),r.silentEmit("error",i),t(i),void r.setStatus("end");let s=n.tls?"secureConnect":"connect";if("sentinels"in n&&n.sentinels&&!n.enableTLSForSentinelMode&&(s="connect"),r.stream=a,n.noDelay&&a.setNoDelay(!0),"number"==typeof n.keepAlive&&(a.connecting?a.once(s,()=>{a.setKeepAlive(!0,n.keepAlive)}):a.setKeepAlive(!0,n.keepAlive)),a.connecting){if(a.once(s,h.connectHandler(r)),n.connectTimeout){let e=!1;a.setTimeout(n.connectTimeout,function(){if(e)return;a.setTimeout(0),a.destroy();const t=new Error("connect ETIMEDOUT");t.errorno="ETIMEDOUT",t.code="ETIMEDOUT",t.syscall="connect",h.errorHandler(r)(t)}),a.once(s,function(){e=!0,a.setTimeout(0)})}}else if(a.destroyed){const e=r.connector.firstError;e&&process.nextTick(()=>{h.errorHandler(r)(e)}),process.nextTick(h.closeHandler(r))}else process.nextTick(h.connectHandler(r));a.destroyed||(a.once("error",h.errorHandler(r)),a.once("close",h.closeHandler(r)));const o=function(){r.removeListener("close",l),e()};var l=function(){r.removeListener("ready",o),t(new Error(b.CONNECTION_CLOSED_ERROR_MSG))};r.once("ready",o),r.once("close",l)})});return(0,l.default)(t,e)}disconnect(e=!1){e||(this.manuallyClosing=!0),this.reconnectTimeout&&!e&&(clearTimeout(this.reconnectTimeout),this.reconnectTimeout=null),"wait"===this.status?h.closeHandler(this)():this.connector.disconnect()}end(){this.disconnect()}duplicate(e){return new I(a(a({},this.options),e))}get mode(){var e;return this.options.monitor?"monitor":(null===(e=this.condition)||void 0===e?void 0:e.subscriber)?"subscriber":"normal"}monitor(e){const t=this.duplicate({monitor:!0,lazyConnect:!1});return(0,l.default)(new Promise(function(e,n){t.once("error",n),t.once("monitoring",function(){e(t)})}),e)}sendCommand(e,t){var n,r;if("wait"===this.status&&this.connect().catch(K.noop),"end"===this.status)return e.reject(new Error(b.CONNECTION_CLOSED_ERROR_MSG)),e.promise;if((null===(n=this.condition)||void 0===n?void 0:n.subscriber)&&!c.default.checkFlag("VALID_IN_SUBSCRIBER_MODE",e.name))return e.reject(new Error("Connection in subscriber mode, only subscriber commands may be used")),e.promise;"number"==typeof this.options.commandTimeout&&e.setTimeout(this.options.commandTimeout);let i="ready"===this.status||!t&&"connect"===this.status&&(0,s.exists)(e.name)&&(0,s.hasFlag)(e.name,"loading");if(this.stream&&this.stream.writable?this.stream._writableState&&this.stream._writableState.ended&&(i=!1):i=!1,i)S.enabled&&S("write command[%s]: %d -> %s(%o)",this._getDescription(),null===(r=this.condition)||void 0===r?void 0:r.select,e.name,e.args),t?"isPipeline"in t&&t.isPipeline?t.write(e.toWritable(t.destination.redis.stream)):t.write(e.toWritable(t)):this.stream.write(e.toWritable(this.stream)),this.commandQueue.push({command:e,stream:t,select:this.condition.select}),c.default.checkFlag("WILL_DISCONNECT",e.name)&&(this.manuallyClosing=!0),void 0!==this.options.socketTimeout&&void 0===this.socketTimeoutTimer&&this.setSocketTimeout();else{if(!this.options.enableOfflineQueue)return e.reject(new Error("Stream isn't writeable and enableOfflineQueue options is false")),e.promise;if("quit"===e.name&&0===this.offlineQueue.length)return this.disconnect(),e.resolve(Buffer.from("OK")),e.promise;S.enabled&&S("queue command[%s]: %d -> %s(%o)",this._getDescription(),this.condition.select,e.name,e.args),this.offlineQueue.push({command:e,stream:t,select:this.condition.select})}if("select"===e.name&&(0,b.isInt)(e.args[0])){const t=parseInt(e.args[0],10);this.condition.select!==t&&(this.condition.select=t,this.emit("select",t),S("switch to db [%d]",this.condition.select))}return e.promise}setSocketTimeout(){this.socketTimeoutTimer=setTimeout(()=>{this.stream.destroy(new Error(`Socket timeout. Expecting data, but didn't receive any in ${this.options.socketTimeout}ms.`)),this.socketTimeoutTimer=void 0},this.options.socketTimeout),this.stream.once("data",()=>{clearTimeout(this.socketTimeoutTimer),this.socketTimeoutTimer=void 0,0!==this.commandQueue.length&&this.setSocketTimeout()})}scanStream(e){return this.createScanStream("scan",{options:e})}scanBufferStream(e){return this.createScanStream("scanBuffer",{options:e})}sscanStream(e,t){return this.createScanStream("sscan",{key:e,options:t})}sscanBufferStream(e,t){return this.createScanStream("sscanBuffer",{key:e,options:t})}hscanStream(e,t){return this.createScanStream("hscan",{key:e,options:t})}hscanBufferStream(e,t){return this.createScanStream("hscanBuffer",{key:e,options:t})}zscanStream(e,t){return this.createScanStream("zscan",{key:e,options:t})}zscanBufferStream(e,t){return this.createScanStream("zscanBuffer",{key:e,options:t})}silentEmit(e,t){let n;if("error"===e){if(n=t,"end"===this.status)return;if(this.manuallyClosing&&n instanceof Error&&(n.message===b.CONNECTION_CLOSED_ERROR_MSG||"connect"===n.syscall||"read"===n.syscall))return}return this.listeners(e).length>0?this.emit.apply(this,arguments):(n&&n instanceof Error&&console.error("[ioredis] Unhandled error event:",n.stack),!1)}recoverFromFatalError(e,t,n){this.flushQueue(t,n),this.silentEmit("error",t),this.disconnect(!0)}handleReconnection(e,t){var n;let r=!1;switch(this.options.reconnectOnError&&(r=this.options.reconnectOnError(e)),r){case 1:case!0:"reconnecting"!==this.status&&this.disconnect(!0),t.command.reject(e);break;case 2:"reconnecting"!==this.status&&this.disconnect(!0),(null===(n=this.condition)||void 0===n?void 0:n.select)!==t.select&&"select"!==t.command.name&&this.select(t.select),this.sendCommand(t.command);break;default:t.command.reject(e)}}_getDescription(){let e;return e="path"in this.options&&this.options.path?this.options.path:this.stream&&this.stream.remoteAddress&&this.stream.remotePort?this.stream.remoteAddress+":"+this.stream.remotePort:"host"in this.options&&this.options.host?this.options.host+":"+this.options.port:"",this.options.connectionName&&(e+=` (${this.options.connectionName})`),e}resetCommandQueue(){this.commandQueue=new E}resetOfflineQueue(){this.offlineQueue=new E}parseOptions(...e){const t={};let n=!1;for(let r=0;r<e.length;++r){const i=e[r];if(null!=i)if("object"==typeof i)(0,K.defaults)(t,i);else if("string"==typeof i)(0,K.defaults)(t,(0,b.parseURL)(i)),i.startsWith("rediss://")&&(n=!0);else{if("number"!=typeof i)throw new Error("Invalid argument "+i);t.port=i}}n&&(0,K.defaults)(t,{tls:!0}),(0,K.defaults)(t,I.defaultOptions),"string"==typeof t.port&&(t.port=parseInt(t.port,10)),"string"==typeof t.db&&(t.db=parseInt(t.db,10)),this.options=(0,b.resolveTLSProfile)(t)}setStatus(e,t){S.enabled&&S("status[%s]: %s -> %s",this._getDescription(),this.status||"[empty]",e),this.status=e,process.nextTick(this.emit.bind(this,e,t))}createScanStream(e,{key:t,options:n={}}){return new m.default(a({objectMode:!0,key:t,redis:this,command:e},n))}flushQueue(e,t){let n;if((t=(0,K.defaults)({},t,{offlineQueue:!0,commandQueue:!0})).offlineQueue)for(;n=this.offlineQueue.shift();)n.command.reject(e);if(t.commandQueue&&this.commandQueue.length>0)for(this.stream&&this.stream.removeAllListeners("data");n=this.commandQueue.shift();)n.command.reject(e)}_readyCheck(e){const t=this;this.info(function(n,r){if(n)return n.message&&n.message.includes("NOPERM")?(console.warn(`Skipping the ready check because INFO command fails: "${n.message}". You can disable ready check with "enableReadyCheck". More: https://github.com/luin/ioredis/wiki/Disable-ready-check.`),e(null,{})):e(n);if("string"!=typeof r)return e(null,r);const i={},a=r.split("\r\n");for(let e=0;e<a.length;++e){const[t,...n]=a[e].split(":"),r=n.join(":");r&&(i[t]=r)}if(i.loading&&"0"!==i.loading){const n=1e3*(i.loading_eta_seconds||1),r=t.options.maxLoadingRetryTime&&t.options.maxLoadingRetryTime<n?t.options.maxLoadingRetryTime:n;S("Redis server still loading, trying again in "+r+"ms"),setTimeout(function(){t._readyCheck(e)},r)}else e(null,i)}).catch(K.noop)}}I.Cluster=d.default,I.Command=c.default,I.defaultOptions=y.DEFAULT_REDIS_OPTIONS,(0,g.default)(I,o.EventEmitter),(0,f.addTransactionSupport)(I.prototype),t.default=I},(e,t,n)=>{var r=n(22);e.exports=function(e,t,n){return(t=r(t))in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e},e.exports.__esModule=!0,e.exports.default=e.exports},(e,t,n)=>{var r=n(23).default,i=n(24);e.exports=function(e){var t=i(e,"string");return"symbol"===r(t)?t:String(t)},e.exports.__esModule=!0,e.exports.default=e.exports},e=>{function t(n){return e.exports=t="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(e){return typeof e}:function(e){return e&&"function"==typeof Symbol&&e.constructor===Symbol&&e!==Symbol.prototype?"symbol":typeof e},e.exports.__esModule=!0,e.exports.default=e.exports,t(n)}e.exports=t,e.exports.__esModule=!0,e.exports.default=e.exports},(e,t,n)=>{var r=n(23).default;e.exports=function(e,t){if("object"!==r(e)||null===e)return e;var n=e[Symbol.toPrimitive];if(void 0!==n){var i=n.call(e,t||"default");if("object"!==r(i))return i;throw new TypeError("@@toPrimitive must return a primitive value.")}return("string"===t?String:Number)(e)},e.exports.__esModule=!0,e.exports.default=e.exports},function(e,t,n){"use strict";var r=this&&this.__importDefault||function(e){return e&&e.__esModule?e:{default:e}};Object.defineProperty(t,"__esModule",{value:!0}),t.getKeyIndexes=t.hasFlag=t.exists=t.list=void 0;const i=r(n(26));t.list=Object.keys(i.default);const a={};function s(e){"string"!=typeof e&&(e=String(e));const t=e.indexOf("->");return-1===t?e.length:t}t.list.forEach(e=>{a[e]=i.default[e].flags.reduce(function(e,t){return e[t]=!0,e},{})}),t.exists=function(e){return Boolean(i.default[e])},t.hasFlag=function(e,t){if(!a[e])throw new Error("Unknown command "+e);return Boolean(a[e][t])},t.getKeyIndexes=function(e,t,n){const r=i.default[e];if(!r)throw new Error("Unknown command "+e);if(!Array.isArray(t))throw new Error("Expect args to be an array");const a=[],o=Boolean(n&&n.parseExternalKey),l=(e,t)=>{const n=[],r=Number(e[t]);for(let e=0;e<r;e++)n.push(e+t+1);return n},d=(e,t,n)=>{for(let r=t;r<e.length-1;r+=1)if(String(e[r]).toLowerCase()===n.toLowerCase())return r+1;return null};switch(e){case"zunionstore":case"zinterstore":case"zdiffstore":a.push(0,...l(t,1));break;case"eval":case"evalsha":case"eval_ro":case"evalsha_ro":case"fcall":case"fcall_ro":case"blmpop":case"bzmpop":a.push(...l(t,1));break;case"sintercard":case"lmpop":case"zunion":case"zinter":case"zmpop":case"zintercard":case"zdiff":a.push(...l(t,0));break;case"georadius":{a.push(0);const e=d(t,5,"STORE");e&&a.push(e);const n=d(t,5,"STOREDIST");n&&a.push(n);break}case"georadiusbymember":{a.push(0);const e=d(t,4,"STORE");e&&a.push(e);const n=d(t,4,"STOREDIST");n&&a.push(n);break}case"sort":case"sort_ro":a.push(0);for(let e=1;e<t.length-1;e++){let n=t[e];if("string"!=typeof n)continue;const r=n.toUpperCase();"GET"===r?(e+=1,n=t[e],"#"!==n&&(o?a.push([e,s(n)]):a.push(e))):"BY"===r?(e+=1,o?a.push([e,s(t[e])]):a.push(e)):"STORE"===r&&(e+=1,a.push(e))}break;case"migrate":if(""===t[2])for(let e=5;e<t.length-1;e++){const n=t[e];if("string"==typeof n&&"KEYS"===n.toUpperCase()){for(let n=e+1;n<t.length;n++)a.push(n);break}}else a.push(2);break;case"xreadgroup":case"xread":for(let n="xread"===e?0:3;n<t.length-1;n++)if("STREAMS"===String(t[n]).toUpperCase()){for(let e=n+1;e<=n+(t.length-1-n)/2;e++)a.push(e);break}break;default:if(r.step>0){const e=r.keyStart-1,n=r.keyStop>0?r.keyStop:t.length+r.keyStop+1;for(let t=e;t<n;t+=r.step)a.push(t)}}return a}},e=>{"use strict";e.exports=JSON.parse('{"acl":{"arity":-2,"flags":[],"keyStart":0,"keyStop":0,"step":0},"append":{"arity":3,"flags":["write","denyoom","fast"],"keyStart":1,"keyStop":1,"step":1},"asking":{"arity":1,"flags":["fast"],"keyStart":0,"keyStop":0,"step":0},"auth":{"arity":-2,"flags":["noscript","loading","stale","fast","no_auth","allow_busy"],"keyStart":0,"keyStop":0,"step":0},"bgrewriteaof":{"arity":1,"flags":["admin","noscript","no_async_loading"],"keyStart":0,"keyStop":0,"step":0},"bgsave":{"arity":-1,"flags":["admin","noscript","no_async_loading"],"keyStart":0,"keyStop":0,"step":0},"bitcount":{"arity":-2,"flags":["readonly"],"keyStart":1,"keyStop":1,"step":1},"bitfield":{"arity":-2,"flags":["write","denyoom"],"keyStart":1,"keyStop":1,"step":1},"bitfield_ro":{"arity":-2,"flags":["readonly","fast"],"keyStart":1,"keyStop":1,"step":1},"bitop":{"arity":-4,"flags":["write","denyoom"],"keyStart":2,"keyStop":-1,"step":1},"bitpos":{"arity":-3,"flags":["readonly"],"keyStart":1,"keyStop":1,"step":1},"blmove":{"arity":6,"flags":["write","denyoom","noscript","blocking"],"keyStart":1,"keyStop":2,"step":1},"blmpop":{"arity":-5,"flags":["write","blocking","movablekeys"],"keyStart":0,"keyStop":0,"step":0},"blpop":{"arity":-3,"flags":["write","noscript","blocking"],"keyStart":1,"keyStop":-2,"step":1},"brpop":{"arity":-3,"flags":["write","noscript","blocking"],"keyStart":1,"keyStop":-2,"step":1},"brpoplpush":{"arity":4,"flags":["write","denyoom","noscript","blocking"],"keyStart":1,"keyStop":2,"step":1},"bzmpop":{"arity":-5,"flags":["write","blocking","movablekeys"],"keyStart":0,"keyStop":0,"step":0},"bzpopmax":{"arity":-3,"flags":["write","noscript","blocking","fast"],"keyStart":1,"keyStop":-2,"step":1},"bzpopmin":{"arity":-3,"flags":["write","noscript","blocking","fast"],"keyStart":1,"keyStop":-2,"step":1},"client":{"arity":-2,"flags":[],"keyStart":0,"keyStop":0,"step":0},"cluster":{"arity":-2,"flags":[],"keyStart":0,"keyStop":0,"step":0},"command":{"arity":-1,"flags":["loading","stale"],"keyStart":0,"keyStop":0,"step":0},"config":{"arity":-2,"flags":[],"keyStart":0,"keyStop":0,"step":0},"copy":{"arity":-3,"flags":["write","denyoom"],"keyStart":1,"keyStop":2,"step":1},"dbsize":{"arity":1,"flags":["readonly","fast"],"keyStart":0,"keyStop":0,"step":0},"debug":{"arity":-2,"flags":["admin","noscript","loading","stale"],"keyStart":0,"keyStop":0,"step":0},"decr":{"arity":2,"flags":["write","denyoom","fast"],"keyStart":1,"keyStop":1,"step":1},"decrby":{"arity":3,"flags":["write","denyoom","fast"],"keyStart":1,"keyStop":1,"step":1},"del":{"arity":-2,"flags":["write"],"keyStart":1,"keyStop":-1,"step":1},"discard":{"arity":1,"flags":["noscript","loading","stale","fast","allow_busy"],"keyStart":0,"keyStop":0,"step":0},"dump":{"arity":2,"flags":["readonly"],"keyStart":1,"keyStop":1,"step":1},"echo":{"arity":2,"flags":["fast"],"keyStart":0,"keyStop":0,"step":0},"eval":{"arity":-3,"flags":["noscript","stale","skip_monitor","no_mandatory_keys","movablekeys"],"keyStart":0,"keyStop":0,"step":0},"eval_ro":{"arity":-3,"flags":["readonly","noscript","stale","skip_monitor","no_mandatory_keys","movablekeys"],"keyStart":0,"keyStop":0,"step":0},"evalsha":{"arity":-3,"flags":["noscript","stale","skip_monitor","no_mandatory_keys","movablekeys"],"keyStart":0,"keyStop":0,"step":0},"evalsha_ro":{"arity":-3,"flags":["readonly","noscript","stale","skip_monitor","no_mandatory_keys","movablekeys"],"keyStart":0,"keyStop":0,"step":0},"exec":{"arity":1,"flags":["noscript","loading","stale","skip_slowlog"],"keyStart":0,"keyStop":0,"step":0},"exists":{"arity":-2,"flags":["readonly","fast"],"keyStart":1,"keyStop":-1,"step":1},"expire":{"arity":-3,"flags":["write","fast"],"keyStart":1,"keyStop":1,"step":1},"expireat":{"arity":-3,"flags":["write","fast"],"keyStart":1,"keyStop":1,"step":1},"expiretime":{"arity":2,"flags":["readonly","fast"],"keyStart":1,"keyStop":1,"step":1},"failover":{"arity":-1,"flags":["admin","noscript","stale"],"keyStart":0,"keyStop":0,"step":0},"fcall":{"arity":-3,"flags":["noscript","stale","skip_monitor","no_mandatory_keys","movablekeys"],"keyStart":0,"keyStop":0,"step":0},"fcall_ro":{"arity":-3,"flags":["readonly","noscript","stale","skip_monitor","no_mandatory_keys","movablekeys"],"keyStart":0,"keyStop":0,"step":0},"flushall":{"arity":-1,"flags":["write"],"keyStart":0,"keyStop":0,"step":0},"flushdb":{"arity":-1,"flags":["write"],"keyStart":0,"keyStop":0,"step":0},"function":{"arity":-2,"flags":[],"keyStart":0,"keyStop":0,"step":0},"geoadd":{"arity":-5,"flags":["write","denyoom"],"keyStart":1,"keyStop":1,"step":1},"geodist":{"arity":-4,"flags":["readonly"],"keyStart":1,"keyStop":1,"step":1},"geohash":{"arity":-2,"flags":["readonly"],"keyStart":1,"keyStop":1,"step":1},"geopos":{"arity":-2,"flags":["readonly"],"keyStart":1,"keyStop":1,"step":1},"georadius":{"arity":-6,"flags":["write","denyoom","movablekeys"],"keyStart":1,"keyStop":1,"step":1},"georadius_ro":{"arity":-6,"flags":["readonly"],"keyStart":1,"keyStop":1,"step":1},"georadiusbymember":{"arity":-5,"flags":["write","denyoom","movablekeys"],"keyStart":1,"keyStop":1,"step":1},"georadiusbymember_ro":{"arity":-5,"flags":["readonly"],"keyStart":1,"keyStop":1,"step":1},"geosearch":{"arity":-7,"flags":["readonly"],"keyStart":1,"keyStop":1,"step":1},"geosearchstore":{"arity":-8,"flags":["write","denyoom"],"keyStart":1,"keyStop":2,"step":1},"get":{"arity":2,"flags":["readonly","fast"],"keyStart":1,"keyStop":1,"step":1},"getbit":{"arity":3,"flags":["readonly","fast"],"keyStart":1,"keyStop":1,"step":1},"getdel":{"arity":2,"flags":["write","fast"],"keyStart":1,"keyStop":1,"step":1},"getex":{"arity":-2,"flags":["write","fast"],"keyStart":1,"keyStop":1,"step":1},"getrange":{"arity":4,"flags":["readonly"],"keyStart":1,"keyStop":1,"step":1},"getset":{"arity":3,"flags":["write","denyoom","fast"],"keyStart":1,"keyStop":1,"step":1},"hdel":{"arity":-3,"flags":["write","fast"],"keyStart":1,"keyStop":1,"step":1},"hello":{"arity":-1,"flags":["noscript","loading","stale","fast","no_auth","allow_busy"],"keyStart":0,"keyStop":0,"step":0},"hexists":{"arity":3,"flags":["readonly","fast"],"keyStart":1,"keyStop":1,"step":1},"hget":{"arity":3,"flags":["readonly","fast"],"keyStart":1,"keyStop":1,"step":1},"hgetall":{"arity":2,"flags":["readonly"],"keyStart":1,"keyStop":1,"step":1},"hincrby":{"arity":4,"flags":["write","denyoom","fast"],"keyStart":1,"keyStop":1,"step":1},"hincrbyfloat":{"arity":4,"flags":["write","denyoom","fast"],"keyStart":1,"keyStop":1,"step":1},"hkeys":{"arity":2,"flags":["readonly"],"keyStart":1,"keyStop":1,"step":1},"hlen":{"arity":2,"flags":["readonly","fast"],"keyStart":1,"keyStop":1,"step":1},"hmget":{"arity":-3,"flags":["readonly","fast"],"keyStart":1,"keyStop":1,"step":1},"hmset":{"arity":-4,"flags":["write","denyoom","fast"],"keyStart":1,"keyStop":1,"step":1},"hrandfield":{"arity":-2,"flags":["readonly"],"keyStart":1,"keyStop":1,"step":1},"hscan":{"arity":-3,"flags":["readonly"],"keyStart":1,"keyStop":1,"step":1},"hset":{"arity":-4,"flags":["write","denyoom","fast"],"keyStart":1,"keyStop":1,"step":1},"hsetnx":{"arity":4,"flags":["write","denyoom","fast"],"keyStart":1,"keyStop":1,"step":1},"hstrlen":{"arity":3,"flags":["readonly","fast"],"keyStart":1,"keyStop":1,"step":1},"hvals":{"arity":2,"flags":["readonly"],"keyStart":1,"keyStop":1,"step":1},"incr":{"arity":2,"flags":["write","denyoom","fast"],"keyStart":1,"keyStop":1,"step":1},"incrby":{"arity":3,"flags":["write","denyoom","fast"],"keyStart":1,"keyStop":1,"step":1},"incrbyfloat":{"arity":3,"flags":["write","denyoom","fast"],"keyStart":1,"keyStop":1,"step":1},"info":{"arity":-1,"flags":["loading","stale"],"keyStart":0,"keyStop":0,"step":0},"keys":{"arity":2,"flags":["readonly"],"keyStart":0,"keyStop":0,"step":0},"lastsave":{"arity":1,"flags":["loading","stale","fast"],"keyStart":0,"keyStop":0,"step":0},"latency":{"arity":-2,"flags":[],"keyStart":0,"keyStop":0,"step":0},"lcs":{"arity":-3,"flags":["readonly"],"keyStart":1,"keyStop":2,"step":1},"lindex":{"arity":3,"flags":["readonly"],"keyStart":1,"keyStop":1,"step":1},"linsert":{"arity":5,"flags":["write","denyoom"],"keyStart":1,"keyStop":1,"step":1},"llen":{"arity":2,"flags":["readonly","fast"],"keyStart":1,"keyStop":1,"step":1},"lmove":{"arity":5,"flags":["write","denyoom"],"keyStart":1,"keyStop":2,"step":1},"lmpop":{"arity":-4,"flags":["write","movablekeys"],"keyStart":0,"keyStop":0,"step":0},"lolwut":{"arity":-1,"flags":["readonly","fast"],"keyStart":0,"keyStop":0,"step":0},"lpop":{"arity":-2,"flags":["write","fast"],"keyStart":1,"keyStop":1,"step":1},"lpos":{"arity":-3,"flags":["readonly"],"keyStart":1,"keyStop":1,"step":1},"lpush":{"arity":-3,"flags":["write","denyoom","fast"],"keyStart":1,"keyStop":1,"step":1},"lpushx":{"arity":-3,"flags":["write","denyoom","fast"],"keyStart":1,"keyStop":1,"step":1},"lrange":{"arity":4,"flags":["readonly"],"keyStart":1,"keyStop":1,"step":1},"lrem":{"arity":4,"flags":["write"],"keyStart":1,"keyStop":1,"step":1},"lset":{"arity":4,"flags":["write","denyoom"],"keyStart":1,"keyStop":1,"step":1},"ltrim":{"arity":4,"flags":["write"],"keyStart":1,"keyStop":1,"step":1},"memory":{"arity":-2,"flags":[],"keyStart":0,"keyStop":0,"step":0},"mget":{"arity":-2,"flags":["readonly","fast"],"keyStart":1,"keyStop":-1,"step":1},"migrate":{"arity":-6,"flags":["write","movablekeys"],"keyStart":3,"keyStop":3,"step":1},"module":{"arity":-2,"flags":[],"keyStart":0,"keyStop":0,"step":0},"monitor":{"arity":1,"flags":["admin","noscript","loading","stale"],"keyStart":0,"keyStop":0,"step":0},"move":{"arity":3,"flags":["write","fast"],"keyStart":1,"keyStop":1,"step":1},"mset":{"arity":-3,"flags":["write","denyoom"],"keyStart":1,"keyStop":-1,"step":2},"msetnx":{"arity":-3,"flags":["write","denyoom"],"keyStart":1,"keyStop":-1,"step":2},"multi":{"arity":1,"flags":["noscript","loading","stale","fast","allow_busy"],"keyStart":0,"keyStop":0,"step":0},"object":{"arity":-2,"flags":[],"keyStart":0,"keyStop":0,"step":0},"persist":{"arity":2,"flags":["write","fast"],"keyStart":1,"keyStop":1,"step":1},"pexpire":{"arity":-3,"flags":["write","fast"],"keyStart":1,"keyStop":1,"step":1},"pexpireat":{"arity":-3,"flags":["write","fast"],"keyStart":1,"keyStop":1,"step":1},"pexpiretime":{"arity":2,"flags":["readonly","fast"],"keyStart":1,"keyStop":1,"step":1},"pfadd":{"arity":-2,"flags":["write","denyoom","fast"],"keyStart":1,"keyStop":1,"step":1},"pfcount":{"arity":-2,"flags":["readonly"],"keyStart":1,"keyStop":-1,"step":1},"pfdebug":{"arity":3,"flags":["write","denyoom","admin"],"keyStart":2,"keyStop":2,"step":1},"pfmerge":{"arity":-2,"flags":["write","denyoom"],"keyStart":1,"keyStop":-1,"step":1},"pfselftest":{"arity":1,"flags":["admin"],"keyStart":0,"keyStop":0,"step":0},"ping":{"arity":-1,"flags":["fast"],"keyStart":0,"keyStop":0,"step":0},"psetex":{"arity":4,"flags":["write","denyoom"],"keyStart":1,"keyStop":1,"step":1},"psubscribe":{"arity":-2,"flags":["pubsub","noscript","loading","stale"],"keyStart":0,"keyStop":0,"step":0},"psync":{"arity":-3,"flags":["admin","noscript","no_async_loading","no_multi"],"keyStart":0,"keyStop":0,"step":0},"pttl":{"arity":2,"flags":["readonly","fast"],"keyStart":1,"keyStop":1,"step":1},"publish":{"arity":3,"flags":["pubsub","loading","stale","fast"],"keyStart":0,"keyStop":0,"step":0},"pubsub":{"arity":-2,"flags":[],"keyStart":0,"keyStop":0,"step":0},"punsubscribe":{"arity":-1,"flags":["pubsub","noscript","loading","stale"],"keyStart":0,"keyStop":0,"step":0},"quit":{"arity":-1,"flags":["noscript","loading","stale","fast","no_auth","allow_busy"],"keyStart":0,"keyStop":0,"step":0},"randomkey":{"arity":1,"flags":["readonly"],"keyStart":0,"keyStop":0,"step":0},"readonly":{"arity":1,"flags":["loading","stale","fast"],"keyStart":0,"keyStop":0,"step":0},"readwrite":{"arity":1,"flags":["loading","stale","fast"],"keyStart":0,"keyStop":0,"step":0},"rename":{"arity":3,"flags":["write"],"keyStart":1,"keyStop":2,"step":1},"renamenx":{"arity":3,"flags":["write","fast"],"keyStart":1,"keyStop":2,"step":1},"replconf":{"arity":-1,"flags":["admin","noscript","loading","stale","allow_busy"],"keyStart":0,"keyStop":0,"step":0},"replicaof":{"arity":3,"flags":["admin","noscript","stale","no_async_loading"],"keyStart":0,"keyStop":0,"step":0},"reset":{"arity":1,"flags":["noscript","loading","stale","fast","no_auth","allow_busy"],"keyStart":0,"keyStop":0,"step":0},"restore":{"arity":-4,"flags":["write","denyoom"],"keyStart":1,"keyStop":1,"step":1},"restore-asking":{"arity":-4,"flags":["write","denyoom","asking"],"keyStart":1,"keyStop":1,"step":1},"role":{"arity":1,"flags":["noscript","loading","stale","fast"],"keyStart":0,"keyStop":0,"step":0},"rpop":{"arity":-2,"flags":["write","fast"],"keyStart":1,"keyStop":1,"step":1},"rpoplpush":{"arity":3,"flags":["write","denyoom"],"keyStart":1,"keyStop":2,"step":1},"rpush":{"arity":-3,"flags":["write","denyoom","fast"],"keyStart":1,"keyStop":1,"step":1},"rpushx":{"arity":-3,"flags":["write","denyoom","fast"],"keyStart":1,"keyStop":1,"step":1},"sadd":{"arity":-3,"flags":["write","denyoom","fast"],"keyStart":1,"keyStop":1,"step":1},"save":{"arity":1,"flags":["admin","noscript","no_async_loading","no_multi"],"keyStart":0,"keyStop":0,"step":0},"scan":{"arity":-2,"flags":["readonly"],"keyStart":0,"keyStop":0,"step":0},"scard":{"arity":2,"flags":["readonly","fast"],"keyStart":1,"keyStop":1,"step":1},"script":{"arity":-2,"flags":[],"keyStart":0,"keyStop":0,"step":0},"sdiff":{"arity":-2,"flags":["readonly"],"keyStart":1,"keyStop":-1,"step":1},"sdiffstore":{"arity":-3,"flags":["write","denyoom"],"keyStart":1,"keyStop":-1,"step":1},"select":{"arity":2,"flags":["loading","stale","fast"],"keyStart":0,"keyStop":0,"step":0},"set":{"arity":-3,"flags":["write","denyoom"],"keyStart":1,"keyStop":1,"step":1},"setbit":{"arity":4,"flags":["write","denyoom"],"keyStart":1,"keyStop":1,"step":1},"setex":{"arity":4,"flags":["write","denyoom"],"keyStart":1,"keyStop":1,"step":1},"setnx":{"arity":3,"flags":["write","denyoom","fast"],"keyStart":1,"keyStop":1,"step":1},"setrange":{"arity":4,"flags":["write","denyoom"],"keyStart":1,"keyStop":1,"step":1},"shutdown":{"arity":-1,"flags":["admin","noscript","loading","stale","no_multi","allow_busy"],"keyStart":0,"keyStop":0,"step":0},"sinter":{"arity":-2,"flags":["readonly"],"keyStart":1,"keyStop":-1,"step":1},"sintercard":{"arity":-3,"flags":["readonly","movablekeys"],"keyStart":0,"keyStop":0,"step":0},"sinterstore":{"arity":-3,"flags":["write","denyoom"],"keyStart":1,"keyStop":-1,"step":1},"sismember":{"arity":3,"flags":["readonly","fast"],"keyStart":1,"keyStop":1,"step":1},"slaveof":{"arity":3,"flags":["admin","noscript","stale","no_async_loading"],"keyStart":0,"keyStop":0,"step":0},"slowlog":{"arity":-2,"flags":[],"keyStart":0,"keyStop":0,"step":0},"smembers":{"arity":2,"flags":["readonly"],"keyStart":1,"keyStop":1,"step":1},"smismember":{"arity":-3,"flags":["readonly","fast"],"keyStart":1,"keyStop":1,"step":1},"smove":{"arity":4,"flags":["write","fast"],"keyStart":1,"keyStop":2,"step":1},"sort":{"arity":-2,"flags":["write","denyoom","movablekeys"],"keyStart":1,"keyStop":1,"step":1},"sort_ro":{"arity":-2,"flags":["readonly","movablekeys"],"keyStart":1,"keyStop":1,"step":1},"spop":{"arity":-2,"flags":["write","fast"],"keyStart":1,"keyStop":1,"step":1},"spublish":{"arity":3,"flags":["pubsub","loading","stale","fast"],"keyStart":1,"keyStop":1,"step":1},"srandmember":{"arity":-2,"flags":["readonly"],"keyStart":1,"keyStop":1,"step":1},"srem":{"arity":-3,"flags":["write","fast"],"keyStart":1,"keyStop":1,"step":1},"sscan":{"arity":-3,"flags":["readonly"],"keyStart":1,"keyStop":1,"step":1},"ssubscribe":{"arity":-2,"flags":["pubsub","noscript","loading","stale"],"keyStart":1,"keyStop":-1,"step":1},"strlen":{"arity":2,"flags":["readonly","fast"],"keyStart":1,"keyStop":1,"step":1},"subscribe":{"arity":-2,"flags":["pubsub","noscript","loading","stale"],"keyStart":0,"keyStop":0,"step":0},"substr":{"arity":4,"flags":["readonly"],"keyStart":1,"keyStop":1,"step":1},"sunion":{"arity":-2,"flags":["readonly"],"keyStart":1,"keyStop":-1,"step":1},"sunionstore":{"arity":-3,"flags":["write","denyoom"],"keyStart":1,"keyStop":-1,"step":1},"sunsubscribe":{"arity":-1,"flags":["pubsub","noscript","loading","stale"],"keyStart":1,"keyStop":-1,"step":1},"swapdb":{"arity":3,"flags":["write","fast"],"keyStart":0,"keyStop":0,"step":0},"sync":{"arity":1,"flags":["admin","noscript","no_async_loading","no_multi"],"keyStart":0,"keyStop":0,"step":0},"time":{"arity":1,"flags":["loading","stale","fast"],"keyStart":0,"keyStop":0,"step":0},"touch":{"arity":-2,"flags":["readonly","fast"],"keyStart":1,"keyStop":-1,"step":1},"ttl":{"arity":2,"flags":["readonly","fast"],"keyStart":1,"keyStop":1,"step":1},"type":{"arity":2,"flags":["readonly","fast"],"keyStart":1,"keyStop":1,"step":1},"unlink":{"arity":-2,"flags":["write","fast"],"keyStart":1,"keyStop":-1,"step":1},"unsubscribe":{"arity":-1,"flags":["pubsub","noscript","loading","stale"],"keyStart":0,"keyStop":0,"step":0},"unwatch":{"arity":1,"flags":["noscript","loading","stale","fast","allow_busy"],"keyStart":0,"keyStop":0,"step":0},"wait":{"arity":3,"flags":["noscript"],"keyStart":0,"keyStop":0,"step":0},"watch":{"arity":-2,"flags":["noscript","loading","stale","fast","allow_busy"],"keyStart":1,"keyStop":-1,"step":1},"xack":{"arity":-4,"flags":["write","fast"],"keyStart":1,"keyStop":1,"step":1},"xadd":{"arity":-5,"flags":["write","denyoom","fast"],"keyStart":1,"keyStop":1,"step":1},"xautoclaim":{"arity":-6,"flags":["write","fast"],"keyStart":1,"keyStop":1,"step":1},"xclaim":{"arity":-6,"flags":["write","fast"],"keyStart":1,"keyStop":1,"step":1},"xdel":{"arity":-3,"flags":["write","fast"],"keyStart":1,"keyStop":1,"step":1},"xgroup":{"arity":-2,"flags":[],"keyStart":0,"keyStop":0,"step":0},"xinfo":{"arity":-2,"flags":[],"keyStart":0,"keyStop":0,"step":0},"xlen":{"arity":2,"flags":["readonly","fast"],"keyStart":1,"keyStop":1,"step":1},"xpending":{"arity":-3,"flags":["readonly"],"keyStart":1,"keyStop":1,"step":1},"xrange":{"arity":-4,"flags":["readonly"],"keyStart":1,"keyStop":1,"step":1},"xread":{"arity":-4,"flags":["readonly","blocking","movablekeys"],"keyStart":0,"keyStop":0,"step":0},"xreadgroup":{"arity":-7,"flags":["write","blocking","movablekeys"],"keyStart":0,"keyStop":0,"step":0},"xrevrange":{"arity":-4,"flags":["readonly"],"keyStart":1,"keyStop":1,"step":1},"xsetid":{"arity":-3,"flags":["write","denyoom","fast"],"keyStart":1,"keyStop":1,"step":1},"xtrim":{"arity":-4,"flags":["write"],"keyStart":1,"keyStop":1,"step":1},"zadd":{"arity":-4,"flags":["write","denyoom","fast"],"keyStart":1,"keyStop":1,"step":1},"zcard":{"arity":2,"flags":["readonly","fast"],"keyStart":1,"keyStop":1,"step":1},"zcount":{"arity":4,"flags":["readonly","fast"],"keyStart":1,"keyStop":1,"step":1},"zdiff":{"arity":-3,"flags":["readonly","movablekeys"],"keyStart":0,"keyStop":0,"step":0},"zdiffstore":{"arity":-4,"flags":["write","denyoom","movablekeys"],"keyStart":1,"keyStop":1,"step":1},"zincrby":{"arity":4,"flags":["write","denyoom","fast"],"keyStart":1,"keyStop":1,"step":1},"zinter":{"arity":-3,"flags":["readonly","movablekeys"],"keyStart":0,"keyStop":0,"step":0},"zintercard":{"arity":-3,"flags":["readonly","movablekeys"],"keyStart":0,"keyStop":0,"step":0},"zinterstore":{"arity":-4,"flags":["write","denyoom","movablekeys"],"keyStart":1,"keyStop":1,"step":1},"zlexcount":{"arity":4,"flags":["readonly","fast"],"keyStart":1,"keyStop":1,"step":1},"zmpop":{"arity":-4,"flags":["write","movablekeys"],"keyStart":0,"keyStop":0,"step":0},"zmscore":{"arity":-3,"flags":["readonly","fast"],"keyStart":1,"keyStop":1,"step":1},"zpopmax":{"arity":-2,"flags":["write","fast"],"keyStart":1,"keyStop":1,"step":1},"zpopmin":{"arity":-2,"flags":["write","fast"],"keyStart":1,"keyStop":1,"step":1},"zrandmember":{"arity":-2,"flags":["readonly"],"keyStart":1,"keyStop":1,"step":1},"zrange":{"arity":-4,"flags":["readonly"],"keyStart":1,"keyStop":1,"step":1},"zrangebylex":{"arity":-4,"flags":["readonly"],"keyStart":1,"keyStop":1,"step":1},"zrangebyscore":{"arity":-4,"flags":["readonly"],"keyStart":1,"keyStop":1,"step":1},"zrangestore":{"arity":-5,"flags":["write","denyoom"],"keyStart":1,"keyStop":2,"step":1},"zrank":{"arity":3,"flags":["readonly","fast"],"keyStart":1,"keyStop":1,"step":1},"zrem":{"arity":-3,"flags":["write","fast"],"keyStart":1,"keyStop":1,"step":1},"zremrangebylex":{"arity":4,"flags":["write"],"keyStart":1,"keyStop":1,"step":1},"zremrangebyrank":{"arity":4,"flags":["write"],"keyStart":1,"keyStop":1,"step":1},"zremrangebyscore":{"arity":4,"flags":["write"],"keyStart":1,"keyStop":1,"step":1},"zrevrange":{"arity":-4,"flags":["readonly"],"keyStart":1,"keyStop":1,"step":1},"zrevrangebylex":{"arity":-4,"flags":["readonly"],"keyStart":1,"keyStop":1,"step":1},"zrevrangebyscore":{"arity":-4,"flags":["readonly"],"keyStart":1,"keyStop":1,"step":1},"zrevrank":{"arity":3,"flags":["readonly","fast"],"keyStart":1,"keyStop":1,"step":1},"zscan":{"arity":-3,"flags":["readonly"],"keyStart":1,"keyStop":1,"step":1},"zscore":{"arity":3,"flags":["readonly","fast"],"keyStart":1,"keyStop":1,"step":1},"zunion":{"arity":-3,"flags":["readonly","movablekeys"],"keyStart":0,"keyStop":0,"step":0},"zunionstore":{"arity":-4,"flags":["write","denyoom","movablekeys"],"keyStart":1,"keyStop":1,"step":1}}')},(e,t,n)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0});const r=n(28);function i(e){setTimeout(function(){throw e},0)}t.default=function(e,t,n){return"function"==typeof t&&e.then(e=>{let a;a=void 0!==n&&Object(n).spread&&Array.isArray(e)?r.tryCatch(t).apply(void 0,[null].concat(e)):void 0===e?r.tryCatch(t)(null):r.tryCatch(t)(null,e),a===r.errorObj&&i(a.e)},e=>{if(!e){const t=new Error(e+"");Object.assign(t,{cause:e}),e=t}const n=r.tryCatch(t)(e);n===r.errorObj&&i(n.e)}),e}},(e,t)=>{"use strict";let n;function r(e,r){try{const e=n;return n=null,e.apply(this,arguments)}catch(e){return t.errorObj.e=e,t.errorObj}}Object.defineProperty(t,"__esModule",{value:!0}),t.tryCatch=t.errorObj=void 0,t.errorObj={e:{}},t.tryCatch=function(e){return n=e,r}},(e,t,n)=>{"use strict";var r=n(21);function i(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter(function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable})),n.push.apply(n,r)}return n}Object.defineProperty(t,"__esModule",{value:!0});const a=n(25),s=n(14),o=n(30),l=n(27),d=n(33),c=n(44),u=n(20),p=n(45),h=n(47),y=n(35),m=n(53),f=n(49),b=n(54),g=n(56),v=n(59),K=n(60),E=n(57),S=n(61),I=n(62),w=(0,y.Debug)("cluster"),k=new WeakSet;class j extends f.default{constructor(e,t={}){if(super(),this.slots=[],this._groupsIds={},this._groupsBySlot=Array(16384),this.isCluster=!0,this.retryAttempts=0,this.delayQueue=new K.default,this.offlineQueue=new S,this.isRefreshing=!1,this._refreshSlotsCacheCallbacks=[],this._autoPipelines=new Map,this._runningAutoPipelines=new Set,this._readyDelayedCallbacks=[],this.connectionEpoch=0,s.EventEmitter.call(this),this.startupNodes=e,this.options=(0,y.defaults)({},t,b.DEFAULT_CLUSTER_OPTIONS,this.options),1==this.options.shardedSubscribers&&(this.shardedSubscribers=new I.default(this)),this.options.redisOptions&&this.options.redisOptions.keyPrefix&&!this.options.keyPrefix&&(this.options.keyPrefix=this.options.redisOptions.keyPrefix),"function"!=typeof this.options.scaleReads&&-1===["all","master","slave"].indexOf(this.options.scaleReads))throw new Error('Invalid option scaleReads "'+this.options.scaleReads+'". Expected "all", "master", "slave" or a custom function');this.connectionPool=new v.default(this.options.redisOptions),this.connectionPool.on("-node",(e,t)=>{this.emit("-node",e)}),this.connectionPool.on("+node",e=>{this.emit("+node",e)}),this.connectionPool.on("drain",()=>{this.setStatus("close")}),this.connectionPool.on("nodeError",(e,t)=>{this.emit("node error",e,t)}),this.subscriber=new g.default(this.connectionPool,this),this.options.scripts&&Object.entries(this.options.scripts).forEach(([e,t])=>{this.defineCommand(e,t)}),this.options.lazyConnect?this.setStatus("wait"):this.connect().catch(e=>{w("connecting failed: %s",e)})}connect(){return new Promise((e,t)=>{if("connecting"===this.status||"connect"===this.status||"ready"===this.status)return void t(new Error("Redis is already connecting/connected"));const n=++this.connectionEpoch;this.setStatus("connecting"),this.resolveStartupNodeHostnames().then(r=>{if(this.connectionEpoch!==n)return w("discard connecting after resolving startup nodes because epoch not match: %d != %d",n,this.connectionEpoch),void t(new o.RedisError("Connection is discarded because a new connection is made"));if("connecting"!==this.status)return w("discard connecting after resolving startup nodes because the status changed to %s",this.status),void t(new o.RedisError("Connection is aborted"));this.connectionPool.reset(r);const i=()=>{this.setStatus("ready"),this.retryAttempts=0,this.executeOfflineCommands(),this.resetNodesRefreshInterval(),e()};let a;const s=()=>{this.invokeReadyDelayedCallbacks(void 0),this.removeListener("close",a),this.manuallyClosing=!1,this.setStatus("connect"),this.options.enableReadyCheck?this.readyCheck((e,t)=>{e||t?(w("Ready check failed (%s). Reconnecting...",e||t),"connect"===this.status&&this.disconnect(!0)):i()}):i()};a=()=>{const e=new Error("None of startup nodes is available");this.removeListener("refresh",s),this.invokeReadyDelayedCallbacks(e),t(e)},this.once("refresh",s),this.once("close",a),this.once("close",this.handleCloseEvent.bind(this)),this.refreshSlotsCache(e=>{e&&e.message===c.default.defaultMessage&&(u.default.prototype.silentEmit.call(this,"error",e),this.connectionPool.reset([]))}),this.subscriber.start(),this.options.shardedSubscribers&&this.shardedSubscribers.start()}).catch(e=>{this.setStatus("close"),this.handleCloseEvent(e),this.invokeReadyDelayedCallbacks(e),t(e)})})}disconnect(e=!1){const t=this.status;this.setStatus("disconnecting"),e||(this.manuallyClosing=!0),this.reconnectTimeout&&!e&&(clearTimeout(this.reconnectTimeout),this.reconnectTimeout=null,w("Canceled reconnecting attempts")),this.clearNodesRefreshInterval(),this.subscriber.stop(),this.options.shardedSubscribers&&this.shardedSubscribers.stop(),"wait"===t?(this.setStatus("close"),this.handleCloseEvent()):this.connectionPool.reset([])}quit(e){const t=this.status;if(this.setStatus("disconnecting"),this.manuallyClosing=!0,this.reconnectTimeout&&(clearTimeout(this.reconnectTimeout),this.reconnectTimeout=null),this.clearNodesRefreshInterval(),this.subscriber.stop(),this.options.shardedSubscribers&&this.shardedSubscribers.stop(),"wait"===t){const t=(0,l.default)(Promise.resolve("OK"),e);return setImmediate(function(){this.setStatus("close"),this.handleCloseEvent()}.bind(this)),t}return(0,l.default)(Promise.all(this.nodes().map(e=>e.quit().catch(e=>{if(e.message===y.CONNECTION_CLOSED_ERROR_MSG)return"OK";throw e}))).then(()=>"OK"),e)}duplicate(e=[],t={}){const n=e.length>0?e:this.startupNodes.slice(0),r=Object.assign({},this.options,t);return new j(n,r)}nodes(e="all"){if("all"!==e&&"master"!==e&&"slave"!==e)throw new Error('Invalid role "'+e+'". Expected "all", "master" or "slave"');return this.connectionPool.getNodes(e)}delayUntilReady(e){this._readyDelayedCallbacks.push(e)}get autoPipelineQueueSize(){let e=0;for(const t of this._autoPipelines.values())e+=t.length;return e}refreshSlotsCache(e){if(e&&this._refreshSlotsCacheCallbacks.push(e),this.isRefreshing)return;this.isRefreshing=!0;const t=this,n=e=>{this.isRefreshing=!1;for(const t of this._refreshSlotsCacheCallbacks)t(e);this._refreshSlotsCacheCallbacks=[]},r=(0,y.shuffle)(this.connectionPool.getNodes());let i=null;!function e(a){if(a===r.length){const e=new c.default(c.default.defaultMessage,i);return n(e)}const s=r[a],o=`${s.options.host}:${s.options.port}`;w("getting slot cache from %s",o),t.getInfoFromNode(s,function(r){switch(t.status){case"close":case"end":return n(new Error("Cluster is disconnected."));case"disconnecting":return n(new Error("Cluster is disconnecting."))}r?(t.emit("node error",r,o),i=r,e(a+1)):(t.emit("refresh"),n())})}(0)}sendCommand(e,t,n){if("wait"===this.status&&this.connect().catch(y.noop),"end"===this.status)return e.reject(new Error(y.CONNECTION_CLOSED_ERROR_MSG)),e.promise;let r=this.options.scaleReads;if("master"!==r){e.isReadOnly||(0,a.exists)(e.name)&&(0,a.hasFlag)(e.name,"readonly")||(r="master")}let i=n?n.slot:e.getSlot();const s={},l=this;if(!n&&!k.has(e)){k.add(e);const t=e.reject;e.reject=function(n){const r=c.bind(null,!0);l.handleError(n,s,{moved:function(t,n){w("command %s is moved to %s",e.name,n),i=Number(t),l.slots[t]?l.slots[t][0]=n:l.slots[t]=[n],l._groupsBySlot[t]=l._groupsIds[l.slots[t].join(";")],l.connectionPool.findOrCreate(l.natMapper(n)),c(),w("refreshing slot caches... (triggered by MOVED error)"),l.refreshSlotsCache()},ask:function(t,n){w("command %s is required to ask %s:%s",e.name,n);const r=l.natMapper(n);l.connectionPool.findOrCreate(r),c(!1,`${r.host}:${r.port}`)},tryagain:r,clusterDown:r,connectionClosed:r,maxRedirections:function(n){t.call(e,n)},defaults:function(){t.call(e,n)}})}}function c(a,s){if("end"===l.status)return void e.reject(new o.AbortError("Cluster is ended."));let c;if("ready"===l.status||"cluster"===e.name){if(n&&n.redis)c=n.redis;else if(d.default.checkFlag("ENTER_SUBSCRIBER_MODE",e.name)||d.default.checkFlag("EXIT_SUBSCRIBER_MODE",e.name)){if(1!=l.options.shardedSubscribers||"ssubscribe"!=e.name&&"sunsubscribe"!=e.name)c=l.subscriber.getInstance();else{const t=l.shardedSubscribers.getResponsibleSubscriber(i);let n=-1;"ssubscribe"==e.name&&(n=l.shardedSubscribers.addChannels(e.getKeys())),"sunsubscribe"==e.name&&(n=l.shardedSubscribers.removeChannels(e.getKeys())),-1!==n?c=t.getInstance():e.reject(new o.AbortError("Can't add or remove the given channels. Are they in the same slot?"))}if(!c)return void e.reject(new o.AbortError("No subscriber for the cluster"))}else{if(!a){if("number"==typeof i&&l.slots[i]){const t=l.slots[i];if("function"==typeof r){const n=t.map(function(e){return l.connectionPool.getInstanceByKey(e)});c=r(n,e),Array.isArray(c)&&(c=(0,y.sample)(c)),c||(c=n[0])}else{let e;e="all"===r?(0,y.sample)(t):"slave"===r&&t.length>1?(0,y.sample)(t,1):t[0],c=l.connectionPool.getInstanceByKey(e)}}s&&(c=l.connectionPool.getInstanceByKey(s),c.asking())}c||(c=("function"==typeof r?null:l.connectionPool.getSampleInstance(r))||l.connectionPool.getSampleInstance("all"))}n&&!n.redis&&(n.redis=c)}c?c.sendCommand(e,t):l.options.enableOfflineQueue?l.offlineQueue.push({command:e,stream:t,node:n}):e.reject(new Error("Cluster isn't ready and enableOfflineQueue options is false"))}return c(),e.promise}sscanStream(e,t){return this.createScanStream("sscan",{key:e,options:t})}sscanBufferStream(e,t){return this.createScanStream("sscanBuffer",{key:e,options:t})}hscanStream(e,t){return this.createScanStream("hscan",{key:e,options:t})}hscanBufferStream(e,t){return this.createScanStream("hscanBuffer",{key:e,options:t})}zscanStream(e,t){return this.createScanStream("zscan",{key:e,options:t})}zscanBufferStream(e,t){return this.createScanStream("zscanBuffer",{key:e,options:t})}handleError(e,t,n){if(void 0===t.value?t.value=this.options.maxRedirections:t.value-=1,t.value<=0)return void n.maxRedirections(new Error("Too many Cluster redirections. Last error: "+e));const r=e.message.split(" ");if("MOVED"===r[0]){const e=this.options.retryDelayOnMoved;e&&"number"==typeof e?this.delayQueue.push("moved",n.moved.bind(null,r[1],r[2]),{timeout:e}):n.moved(r[1],r[2])}else"ASK"===r[0]?n.ask(r[1],r[2]):"TRYAGAIN"===r[0]?this.delayQueue.push("tryagain",n.tryagain,{timeout:this.options.retryDelayOnTryAgain}):"CLUSTERDOWN"===r[0]&&this.options.retryDelayOnClusterDown>0?this.delayQueue.push("clusterdown",n.connectionClosed,{timeout:this.options.retryDelayOnClusterDown,callback:this.refreshSlotsCache.bind(this)}):e.message===y.CONNECTION_CLOSED_ERROR_MSG&&this.options.retryDelayOnFailover>0&&"ready"===this.status?this.delayQueue.push("failover",n.connectionClosed,{timeout:this.options.retryDelayOnFailover,callback:this.refreshSlotsCache.bind(this)}):n.defaults()}resetOfflineQueue(){this.offlineQueue=new S}clearNodesRefreshInterval(){this.slotsTimer&&(clearTimeout(this.slotsTimer),this.slotsTimer=null)}resetNodesRefreshInterval(){if(this.slotsTimer||!this.options.slotsRefreshInterval)return;const e=()=>{this.slotsTimer=setTimeout(()=>{w('refreshing slot caches... (triggered by "slotsRefreshInterval" option)'),this.refreshSlotsCache(()=>{e()})},this.options.slotsRefreshInterval)};e()}setStatus(e){w("status: %s -> %s",this.status||"[empty]",e),this.status=e,process.nextTick(()=>{this.emit(e)})}handleCloseEvent(e){let t;e&&w("closed because %s",e),this.manuallyClosing||"function"!=typeof this.options.clusterRetryStrategy||(t=this.options.clusterRetryStrategy.call(this,++this.retryAttempts,e)),"number"==typeof t?(this.setStatus("reconnecting"),this.reconnectTimeout=setTimeout(()=>{this.reconnectTimeout=null,w("Cluster is disconnected. Retrying after %dms",t),this.connect().catch(function(e){w("Got error %s when reconnecting. Ignoring...",e)})},t)):(this.setStatus("end"),this.flushQueue(new Error("None of startup nodes is available")))}flushQueue(e){let t;for(;t=this.offlineQueue.shift();)t.command.reject(e)}executeOfflineCommands(){if(this.offlineQueue.length){w("send %d commands in offline queue",this.offlineQueue.length);const e=this.offlineQueue;let t;for(this.resetOfflineQueue();t=e.shift();)this.sendCommand(t.command,t.stream,t.node)}}natMapper(e){const t="string"==typeof e?e:`${e.host}:${e.port}`;let n=null;return this.options.natMap&&"function"==typeof this.options.natMap?n=this.options.natMap(t):this.options.natMap&&"object"==typeof this.options.natMap&&(n=this.options.natMap[t]),n?(w("NAT mapping %s -> %O",t,n),Object.assign({},n)):"string"==typeof e?(0,E.nodeKeyToRedisOptions)(e):e}getInfoFromNode(e,t){if(!e)return t(new Error("Node is disconnected"));const n=e.duplicate({enableOfflineQueue:!0,enableReadyCheck:!1,retryStrategy:null,connectionName:(0,E.getConnectionName)("refresher",this.options.redisOptions&&this.options.redisOptions.connectionName)});n.on("error",y.noop),n.cluster("SLOTS",(0,y.timeout)((e,r)=>{if(n.disconnect(),e)return w("error encountered running CLUSTER.SLOTS: %s",e),t(e);if("disconnecting"===this.status||"close"===this.status||"end"===this.status)return w("ignore CLUSTER.SLOTS results (count: %d) since cluster status is %s",r.length,this.status),void t();const i=[];w("cluster slots result count: %d",r.length);for(let e=0;e<r.length;++e){const t=r[e],n=t[0],a=t[1],s=[];for(let e=2;e<t.length;e++){if(!t[e][0])continue;const n=this.natMapper({host:t[e][0],port:t[e][1]});n.readOnly=2!==e,i.push(n),s.push(n.host+":"+n.port)}w("cluster slots result [%d]: slots %d~%d served by %s",e,n,a,s);for(let e=n;e<=a;e++)this.slots[e]=s}this._groupsIds=Object.create(null);let a=0;for(let e=0;e<16384;e++){const t=(this.slots[e]||[]).join(";");t.length?(this._groupsIds[t]||(this._groupsIds[t]=++a),this._groupsBySlot[e]=this._groupsIds[t]):this._groupsBySlot[e]=void 0}this.connectionPool.reset(i),t()},this.options.slotsRefreshTimeout))}invokeReadyDelayedCallbacks(e){for(const t of this._readyDelayedCallbacks)process.nextTick(t,e);this._readyDelayedCallbacks=[]}readyCheck(e){this.cluster("INFO",(t,n)=>{if(t)return e(t);if("string"!=typeof n)return e();let r;const i=n.split("\r\n");for(let e=0;e<i.length;++e){const t=i[e].split(":");if("cluster_state"===t[0]){r=t[1];break}}"fail"===r?(w("cluster state not ok (%s)",r),e(null,r)):e()})}resolveSrv(e){return new Promise((t,n)=>{this.options.resolveSrv(e,(e,r)=>{if(e)return n(e);const i=this,a=(0,E.groupSrvRecords)(r),s=Object.keys(a).sort((e,t)=>parseInt(e)-parseInt(t));!function e(r){if(!s.length)return n(r);const o=s[0],l=a[o],d=(0,E.weightSrvRecords)(l);l.records.length||s.shift(),i.dnsLookup(d.name).then(e=>t({host:e,port:d.port}),e)}()})})}dnsLookup(e){return new Promise((t,n)=>{this.options.dnsLookup(e,(r,i)=>{r?(w("failed to resolve hostname %s to IP: %s",e,r.message),n(r)):(w("resolved hostname %s to IP %s",e,i),t(i))})})}async resolveStartupNodeHostnames(){if(!Array.isArray(this.startupNodes)||0===this.startupNodes.length)throw new Error("`startupNodes` should contain at least one node.");const e=(0,E.normalizeNodeOptions)(this.startupNodes),t=(0,E.getUniqueHostnamesFromOptions)(e);if(0===t.length)return e;const n=await Promise.all(t.map((this.options.useSRVRecords?this.resolveSrv:this.dnsLookup).bind(this))),r=(0,y.zipMap)(t,n);return e.map(e=>{const t=r.get(e.host);return t?this.options.useSRVRecords?Object.assign({},e,t):Object.assign({},e,{host:t}):e})}createScanStream(e,{key:t,options:n={}}){return new p.default(function(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?i(Object(n),!0).forEach(function(t){r(e,t,n[t])}):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach(function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))})}return e}({objectMode:!0,key:t,redis:this,command:e},n))}}(0,m.default)(j,s.EventEmitter),(0,h.addTransactionSupport)(j.prototype),t.default=j},(e,t,n)=>{"use strict";const r=process.version.charCodeAt(1)<55&&46===process.version.charCodeAt(2)?n(31):n(32);e.exports=r},(e,t,n)=>{"use strict";const r=n(Object(function(){var e=new Error("Cannot find module 'assert'");throw e.code="MODULE_NOT_FOUND",e}())),i=n(Object(function(){var e=new Error("Cannot find module 'util'");throw e.code="MODULE_NOT_FOUND",e}()));function a(e){Object.defineProperty(this,"message",{value:e||"",configurable:!0,writable:!0}),Error.captureStackTrace(this,this.constructor)}function s(e,t,n){r(t),r.strictEqual(typeof n,"number"),Object.defineProperty(this,"message",{value:e||"",configurable:!0,writable:!0});const i=Error.stackTraceLimit;Error.stackTraceLimit=2,Error.captureStackTrace(this,this.constructor),Error.stackTraceLimit=i,this.offset=n,this.buffer=t}function o(e){Object.defineProperty(this,"message",{value:e||"",configurable:!0,writable:!0});const t=Error.stackTraceLimit;Error.stackTraceLimit=2,Error.captureStackTrace(this,this.constructor),Error.stackTraceLimit=t}function l(e){Object.defineProperty(this,"message",{value:e||"",configurable:!0,writable:!0}),Error.captureStackTrace(this,this.constructor)}function d(e){Object.defineProperty(this,"message",{value:e||"",configurable:!0,writable:!0}),Error.captureStackTrace(this,this.constructor)}i.inherits(a,Error),Object.defineProperty(a.prototype,"name",{value:"RedisError",configurable:!0,writable:!0}),i.inherits(s,a),Object.defineProperty(s.prototype,"name",{value:"ParserError",configurable:!0,writable:!0}),i.inherits(o,a),Object.defineProperty(o.prototype,"name",{value:"ReplyError",configurable:!0,writable:!0}),i.inherits(l,a),Object.defineProperty(l.prototype,"name",{value:"AbortError",configurable:!0,writable:!0}),i.inherits(d,l),Object.defineProperty(d.prototype,"name",{value:"InterruptError",configurable:!0,writable:!0}),e.exports={RedisError:a,ParserError:s,ReplyError:o,AbortError:l,InterruptError:d}},(e,t,n)=>{"use strict";const r=n(Object(function(){var e=new Error("Cannot find module 'assert'");throw e.code="MODULE_NOT_FOUND",e}()));class i extends Error{get name(){return this.constructor.name}}class a extends i{get name(){return this.constructor.name}}e.exports={RedisError:i,ParserError:class extends i{constructor(e,t,n){r(t),r.strictEqual(typeof n,"number");const i=Error.stackTraceLimit;Error.stackTraceLimit=2,super(e),Error.stackTraceLimit=i,this.offset=n,this.buffer=t}get name(){return this.constructor.name}},ReplyError:class extends i{constructor(e){const t=Error.stackTraceLimit;Error.stackTraceLimit=2,super(e),Error.stackTraceLimit=t}get name(){return this.constructor.name}},AbortError:a,InterruptError:class extends a{get name(){return this.constructor.name}}}},(e,t,n)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0});const r=n(25),i=n(34),a=n(27),s=n(35);class o{constructor(e,t=[],n={},r){if(this.name=e,this.inTransaction=!1,this.isResolved=!1,this.transformed=!1,this.replyEncoding=n.replyEncoding,this.errorStack=n.errorStack,this.args=t.flat(),this.callback=r,this.initPromise(),n.keyPrefix){const e=n.keyPrefix instanceof Buffer;let t=e?n.keyPrefix:null;this._iterateKeys(r=>r instanceof Buffer?(null===t&&(t=Buffer.from(n.keyPrefix)),Buffer.concat([t,r])):e?Buffer.concat([n.keyPrefix,Buffer.from(String(r))]):n.keyPrefix+r)}n.readOnly&&(this.isReadOnly=!0)}static checkFlag(e,t){return!!this.getFlagMap()[e][t]}static setArgumentTransformer(e,t){this._transformer.argument[e]=t}static setReplyTransformer(e,t){this._transformer.reply[e]=t}static getFlagMap(){return this.flagMap||(this.flagMap=Object.keys(o.FLAGS).reduce((e,t)=>(e[t]={},o.FLAGS[t].forEach(n=>{e[t][n]=!0}),e),{})),this.flagMap}getSlot(){if(void 0===this.slot){const e=this.getKeys()[0];this.slot=null==e?null:i(e)}return this.slot}getKeys(){return this._iterateKeys()}toWritable(e){let t;const n="*"+(this.args.length+1)+"\r\n$"+Buffer.byteLength(this.name)+"\r\n"+this.name+"\r\n";if(this.bufferMode){const e=new c;e.push(n);for(let t=0;t<this.args.length;++t){const n=this.args[t];n instanceof Buffer?0===n.length?e.push("$0\r\n\r\n"):(e.push("$"+n.length+"\r\n"),e.push(n),e.push("\r\n")):e.push("$"+Buffer.byteLength(n)+"\r\n"+n+"\r\n")}t=e.toBuffer()}else{t=n;for(let e=0;e<this.args.length;++e){const n=this.args[e];t+="$"+Buffer.byteLength(n)+"\r\n"+n+"\r\n"}}return t}stringifyArguments(){for(let e=0;e<this.args.length;++e){const t=this.args[e];"string"==typeof t||(t instanceof Buffer?this.bufferMode=!0:this.args[e]=(0,s.toArg)(t))}}transformReply(e){this.replyEncoding&&(e=(0,s.convertBufferToString)(e,this.replyEncoding));const t=o._transformer.reply[this.name];return t&&(e=t(e)),e}setTimeout(e){this._commandTimeoutTimer||(this._commandTimeoutTimer=setTimeout(()=>{this.isResolved||this.reject(new Error("Command timed out"))},e))}initPromise(){const e=new Promise((e,t)=>{if(!this.transformed){this.transformed=!0;const e=o._transformer.argument[this.name];e&&(this.args=e(this.args)),this.stringifyArguments()}this.resolve=this._convertValue(e),this.errorStack?this.reject=e=>{t((0,s.optimizeErrorStack)(e,this.errorStack.stack,"/"))}:this.reject=t});this.promise=(0,a.default)(e,this.callback)}_iterateKeys(e=e=>e){if(void 0===this.keys&&(this.keys=[],(0,r.exists)(this.name))){const t=(0,r.getKeyIndexes)(this.name,this.args);for(const n of t)this.args[n]=e(this.args[n]),this.keys.push(this.args[n])}return this.keys}_convertValue(e){return t=>{try{const n=this._commandTimeoutTimer;n&&(clearTimeout(n),delete this._commandTimeoutTimer),e(this.transformReply(t)),this.isResolved=!0}catch(e){this.reject(e)}return this.promise}}}t.default=o,o.FLAGS={VALID_IN_SUBSCRIBER_MODE:["subscribe","psubscribe","unsubscribe","punsubscribe","ssubscribe","sunsubscribe","ping","quit"],VALID_IN_MONITOR_MODE:["monitor","auth"],ENTER_SUBSCRIBER_MODE:["subscribe","psubscribe","ssubscribe"],EXIT_SUBSCRIBER_MODE:["unsubscribe","punsubscribe","sunsubscribe"],WILL_DISCONNECT:["quit"]},o._transformer={argument:{},reply:{}};const l=function(e){if(1===e.length){if(e[0]instanceof Map)return(0,s.convertMapToArray)(e[0]);if("object"==typeof e[0]&&null!==e[0])return(0,s.convertObjectToArray)(e[0])}return e},d=function(e){if(2===e.length){if(e[1]instanceof Map)return[e[0]].concat((0,s.convertMapToArray)(e[1]));if("object"==typeof e[1]&&null!==e[1])return[e[0]].concat((0,s.convertObjectToArray)(e[1]))}return e};o.setArgumentTransformer("mset",l),o.setArgumentTransformer("msetnx",l),o.setArgumentTransformer("hset",d),o.setArgumentTransformer("hmset",d),o.setReplyTransformer("hgetall",function(e){if(Array.isArray(e)){const t={};for(let n=0;n<e.length;n+=2){const r=e[n],i=e[n+1];r in t?Object.defineProperty(t,r,{value:i,configurable:!0,enumerable:!0,writable:!0}):t[r]=i}return t}return e});class c{constructor(){this.length=0,this.items=[]}push(e){this.length+=Buffer.byteLength(e),this.items.push(e)}toBuffer(){const e=Buffer.allocUnsafe(this.length);let t=0;for(const n of this.items){const r=Buffer.byteLength(n);Buffer.isBuffer(n)?n.copy(e,t):e.write(n,t,r),t+=r}return e}}},e=>{var t=[0,4129,8258,12387,16516,20645,24774,28903,33032,37161,41290,45419,49548,53677,57806,61935,4657,528,12915,8786,21173,17044,29431,25302,37689,33560,45947,41818,54205,50076,62463,58334,9314,13379,1056,5121,25830,29895,17572,21637,42346,46411,34088,38153,58862,62927,50604,54669,13907,9842,5649,1584,30423,26358,22165,18100,46939,42874,38681,34616,63455,59390,55197,51132,18628,22757,26758,30887,2112,6241,10242,14371,51660,55789,59790,63919,35144,39273,43274,47403,23285,19156,31415,27286,6769,2640,14899,10770,56317,52188,64447,60318,39801,35672,47931,43802,27814,31879,19684,23749,11298,15363,3168,7233,60846,64911,52716,56781,44330,48395,36200,40265,32407,28342,24277,20212,15891,11826,7761,3696,65439,61374,57309,53244,48923,44858,40793,36728,37256,33193,45514,41451,53516,49453,61774,57711,4224,161,12482,8419,20484,16421,28742,24679,33721,37784,41979,46042,49981,54044,58239,62302,689,4752,8947,13010,16949,21012,25207,29270,46570,42443,38312,34185,62830,58703,54572,50445,13538,9411,5280,1153,29798,25671,21540,17413,42971,47098,34713,38840,59231,63358,50973,55100,9939,14066,1681,5808,26199,30326,17941,22068,55628,51565,63758,59695,39368,35305,47498,43435,22596,18533,30726,26663,6336,2273,14466,10403,52093,56156,60223,64286,35833,39896,43963,48026,19061,23124,27191,31254,2801,6864,10931,14994,64814,60687,56684,52557,48554,44427,40424,36297,31782,27655,23652,19525,15522,11395,7392,3265,61215,65342,53085,57212,44955,49082,36825,40952,28183,32310,20053,24180,11923,16050,3793,7920],n=e.exports=function(e){for(var n,r=0,i=-1,a=0,s=0,o="string"==typeof e?function(e){for(var t,n=0,r=0,i=[],a=e.length;n<a;n++)(t=e.charCodeAt(n))<128?i[r++]=t:t<2048?(i[r++]=t>>6|192,i[r++]=63&t|128):55296==(64512&t)&&n+1<e.length&&56320==(64512&e.charCodeAt(n+1))?(t=65536+((1023&t)<<10)+(1023&e.charCodeAt(++n)),i[r++]=t>>18|240,i[r++]=t>>12&63|128,i[r++]=t>>6&63|128,i[r++]=63&t|128):(i[r++]=t>>12|224,i[r++]=t>>6&63|128,i[r++]=63&t|128);return i}(e):e,l=o.length;r<l;){if(n=o[r++],-1===i)123===n&&(i=r);else if(125!==n)s=t[255&(n^s>>8)]^s<<8;else if(r-1!==i)return 16383&s;a=t[255&(n^a>>8)]^a<<8}return 16383&a};e.exports.generateMulti=function(e){for(var t=1,r=e.length,i=n(e[0]);t<r;)if(n(e[t++])!==i)return-1;return i}},(e,t,n)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.noop=t.defaults=t.Debug=t.zipMap=t.CONNECTION_CLOSED_ERROR_MSG=t.shuffle=t.sample=t.resolveTLSProfile=t.parseURL=t.optimizeErrorStack=t.toArg=t.convertMapToArray=t.convertObjectToArray=t.timeout=t.packObject=t.isInt=t.wrapMultiResult=t.convertBufferToString=void 0;const r=n(Object(function(){var e=new Error("Cannot find module 'url'");throw e.code="MODULE_NOT_FOUND",e}())),i=n(36);Object.defineProperty(t,"defaults",{enumerable:!0,get:function(){return i.defaults}}),Object.defineProperty(t,"noop",{enumerable:!0,get:function(){return i.noop}});const a=n(39);t.Debug=a.default;const s=n(43);function o(e){const t=parseFloat(e);return!isNaN(e)&&(0|t)===t}t.convertBufferToString=function e(t,n){if(t instanceof Buffer)return t.toString(n);if(Array.isArray(t)){const r=t.length,i=Array(r);for(let a=0;a<r;++a)i[a]=t[a]instanceof Buffer&&"utf8"===n?t[a].toString():e(t[a],n);return i}return t},t.wrapMultiResult=function(e){if(!e)return null;const t=[],n=e.length;for(let r=0;r<n;++r){const n=e[r];n instanceof Error?t.push([n]):t.push([null,n])}return t},t.isInt=o,t.packObject=function(e){const t={},n=e.length;for(let r=1;r<n;r+=2)t[e[r-1]]=e[r];return t},t.timeout=function(e,t){let n=null;const r=function(){n&&(clearTimeout(n),n=null,e.apply(this,arguments))};return n=setTimeout(r,t,new Error("timeout")),r},t.convertObjectToArray=function(e){const t=[],n=Object.keys(e);for(let r=0,i=n.length;r<i;r++)t.push(n[r],e[n[r]]);return t},t.convertMapToArray=function(e){const t=[];let n=0;return e.forEach(function(e,r){t[n]=r,t[n+1]=e,n+=2}),t},t.toArg=function(e){return null==e?"":String(e)},t.optimizeErrorStack=function(e,t,n){const r=t.split("\n");let i,a="";for(i=1;i<r.length&&-1!==r[i].indexOf(n);++i);for(let e=i;e<r.length;++e)a+="\n"+r[e];if(e.stack){const t=e.stack.indexOf("\n");e.stack=e.stack.slice(0,t)+a}return e},t.parseURL=function(e){if(o(e))return{port:e};let t=(0,r.parse)(e,!0,!0);t.slashes||"/"===e[0]||(e="//"+e,t=(0,r.parse)(e,!0,!0));const n=t.query||{},a={};if(t.auth){const e=t.auth.indexOf(":");a.username=-1===e?t.auth:t.auth.slice(0,e),a.password=-1===e?"":t.auth.slice(e+1)}if(t.pathname&&("redis:"===t.protocol||"rediss:"===t.protocol?t.pathname.length>1&&(a.db=t.pathname.slice(1)):a.path=t.pathname),t.host&&(a.host=t.hostname),t.port&&(a.port=t.port),"string"==typeof n.family){const e=Number.parseInt(n.family,10);Number.isNaN(e)||(a.family=e)}return(0,i.defaults)(a,n),a},t.resolveTLSProfile=function(e){let t=null==e?void 0:e.tls;"string"==typeof t&&(t={profile:t});const n=s.default[null==t?void 0:t.profile];return n&&(t=Object.assign({},n,t),delete t.profile,e=Object.assign({},e,{tls:t})),e},t.sample=function(e,t=0){const n=e.length;return t>=n?null:e[t+Math.floor(Math.random()*(n-t))]},t.shuffle=function(e){let t=e.length;for(;t>0;){const n=Math.floor(Math.random()*t);t--,[e[t],e[n]]=[e[n],e[t]]}return e},t.CONNECTION_CLOSED_ERROR_MSG="Connection is closed.",t.zipMap=function(e,t){const n=new Map;return e.forEach((e,r)=>{n.set(e,t[r])}),n}},(e,t,n)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.isArguments=t.defaults=t.noop=void 0;const r=n(37);t.defaults=r;const i=n(38);t.isArguments=i,t.noop=function(){}},e=>{var t=9007199254740991,n="[object Arguments]",r="[object Function]",i="[object GeneratorFunction]",a=/^(?:0|[1-9]\d*)$/;function s(e,t,n){switch(n.length){case 0:return e.call(t);case 1:return e.call(t,n[0]);case 2:return e.call(t,n[0],n[1]);case 3:return e.call(t,n[0],n[1],n[2])}return e.apply(t,n)}var o=Object.prototype,l=o.hasOwnProperty,d=o.toString,c=o.propertyIsEnumerable,u=Math.max;function p(e,t){var r=v(e)||function(e){return function(e){return function(e){return!!e&&"object"==typeof e}(e)&&K(e)}(e)&&l.call(e,"callee")&&(!c.call(e,"callee")||d.call(e)==n)}(e)?function(e,t){for(var n=-1,r=Array(e);++n<e;)r[n]=t(n);return r}(e.length,String):[],i=r.length,a=!!i;for(var s in e)!t&&!l.call(e,s)||a&&("length"==s||b(s,i))||r.push(s);return r}function h(e,t,n,r){return void 0===e||g(e,o[n])&&!l.call(r,n)?t:e}function y(e,t,n){var r=e[t];l.call(e,t)&&g(r,n)&&(void 0!==n||t in e)||(e[t]=n)}function m(e){if(!E(e))return function(e){var t=[];if(null!=e)for(var n in Object(e))t.push(n);return t}(e);var t,n,r,i=(n=(t=e)&&t.constructor,r="function"==typeof n&&n.prototype||o,t===r),a=[];for(var s in e)("constructor"!=s||!i&&l.call(e,s))&&a.push(s);return a}function f(e,t){return t=u(void 0===t?e.length-1:t,0),function(){for(var n=arguments,r=-1,i=u(n.length-t,0),a=Array(i);++r<i;)a[r]=n[t+r];r=-1;for(var o=Array(t+1);++r<t;)o[r]=n[r];return o[t]=a,s(e,this,o)}}function b(e,n){return!!(n=null==n?t:n)&&("number"==typeof e||a.test(e))&&e>-1&&e%1==0&&e<n}function g(e,t){return e===t||e!=e&&t!=t}var v=Array.isArray;function K(e){return null!=e&&function(e){return"number"==typeof e&&e>-1&&e%1==0&&e<=t}(e.length)&&!function(e){var t=E(e)?d.call(e):"";return t==r||t==i}(e)}function E(e){var t=typeof e;return!!e&&("object"==t||"function"==t)}var S,I=(S=function(e,t,n,r){!function(e,t,n,r){n||(n={});for(var i=-1,a=t.length;++i<a;){var s=t[i],o=r?r(n[s],e[s],s,n,e):void 0;y(n,s,void 0===o?e[s]:o)}}(t,function(e){return K(e)?p(e,!0):m(e)}(t),e,r)},f(function(e,t){var n=-1,r=t.length,i=r>1?t[r-1]:void 0,a=r>2?t[2]:void 0;for(i=S.length>3&&"function"==typeof i?(r--,i):void 0,a&&function(e,t,n){if(!E(n))return!1;var r=typeof t;return!!("number"==r?K(n)&&b(t,n.length):"string"==r&&t in n)&&g(n[t],e)}(t[0],t[1],a)&&(i=r<3?void 0:i,r=1),e=Object(e);++n<r;){var s=t[n];s&&S(e,s,n,i)}return e})),w=f(function(e){return e.push(void 0,h),s(I,void 0,e)});e.exports=w},e=>{var t=9007199254740991,n="[object Function]",r="[object GeneratorFunction]",i=Object.prototype,a=i.hasOwnProperty,s=i.toString,o=i.propertyIsEnumerable;e.exports=function(e){return function(e){return function(e){return!!e&&"object"==typeof e}(e)&&function(e){return null!=e&&function(e){return"number"==typeof e&&e>-1&&e%1==0&&e<=t}(e.length)&&!function(e){var t=function(e){var t=typeof e;return!!e&&("object"==t||"function"==t)}(e)?s.call(e):"";return t==n||t==r}(e)}(e)}(e)&&a.call(e,"callee")&&(!o.call(e,"callee")||"[object Arguments]"==s.call(e))}},(e,t,n)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.genRedactedString=t.getStringValue=t.MAX_ARGUMENT_LENGTH=void 0;const r=n(40);t.MAX_ARGUMENT_LENGTH=200;function i(e){if(null!==e)switch(typeof e){case"boolean":case"number":return;case"object":if(Buffer.isBuffer(e))return e.toString("hex");if(Array.isArray(e))return e.join(",");try{return JSON.stringify(e)}catch(e){return}case"string":return e}}function a(e,t){const{length:n}=e;return n<=t?e:e.slice(0,t)+' ... <REDACTED full-length="'+n+'">'}t.getStringValue=i,t.genRedactedString=a,t.default=function(e){const t=(0,r.default)(`ioredis:${e}`);function n(...e){if(t.enabled){for(let t=1;t<e.length;t++){const n=i(e[t]);"string"==typeof n&&n.length>200&&(e[t]=a(n,200))}return t.apply(null,e)}}return Object.defineProperties(n,{namespace:{get:()=>t.namespace},enabled:{get:()=>t.enabled},destroy:{get:()=>t.destroy},log:{get:()=>t.log,set(e){t.log=e}}}),n}},(e,t,n)=>{t.formatArgs=function(t){if(t[0]=(this.useColors?"%c":"")+this.namespace+(this.useColors?" %c":" ")+t[0]+(this.useColors?"%c ":" ")+"+"+e.exports.humanize(this.diff),!this.useColors)return;const n="color: "+this.color;t.splice(1,0,n,"color: inherit");let r=0,i=0;t[0].replace(/%[a-zA-Z%]/g,e=>{"%%"!==e&&(r++,"%c"===e&&(i=r))}),t.splice(i,0,n)},t.save=function(e){try{e?t.storage.setItem("debug",e):t.storage.removeItem("debug")}catch(e){}},t.load=function(){let e;try{e=t.storage.getItem("debug")||t.storage.getItem("DEBUG")}catch(e){}!e&&"undefined"!=typeof process&&"env"in process&&(e=process.env.DEBUG);return e},t.useColors=function(){if("undefined"!=typeof window&&window.process&&("renderer"===window.process.type||window.process.__nwjs))return!0;if("undefined"!=typeof navigator&&navigator.userAgent&&navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/))return!1;let e;return"undefined"!=typeof document&&document.documentElement&&document.documentElement.style&&document.documentElement.style.WebkitAppearance||"undefined"!=typeof window&&window.console&&(window.console.firebug||window.console.exception&&window.console.table)||"undefined"!=typeof navigator&&navigator.userAgent&&(e=navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/))&&parseInt(e[1],10)>=31||"undefined"!=typeof navigator&&navigator.userAgent&&navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/)},t.storage=function(){try{return localStorage}catch(e){}}(),t.destroy=(()=>{let e=!1;return()=>{e||(e=!0,console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`."))}})(),t.colors=["#0000CC","#0000FF","#0033CC","#0033FF","#0066CC","#0066FF","#0099CC","#0099FF","#00CC00","#00CC33","#00CC66","#00CC99","#00CCCC","#00CCFF","#3300CC","#3300FF","#3333CC","#3333FF","#3366CC","#3366FF","#3399CC","#3399FF","#33CC00","#33CC33","#33CC66","#33CC99","#33CCCC","#33CCFF","#6600CC","#6600FF","#6633CC","#6633FF","#66CC00","#66CC33","#9900CC","#9900FF","#9933CC","#9933FF","#99CC00","#99CC33","#CC0000","#CC0033","#CC0066","#CC0099","#CC00CC","#CC00FF","#CC3300","#CC3333","#CC3366","#CC3399","#CC33CC","#CC33FF","#CC6600","#CC6633","#CC9900","#CC9933","#CCCC00","#CCCC33","#FF0000","#FF0033","#FF0066","#FF0099","#FF00CC","#FF00FF","#FF3300","#FF3333","#FF3366","#FF3399","#FF33CC","#FF33FF","#FF6600","#FF6633","#FF9900","#FF9933","#FFCC00","#FFCC33"],t.log=console.debug||console.log||(()=>{}),e.exports=n(41)(t);const{formatters:r}=e.exports;r.j=function(e){try{return JSON.stringify(e)}catch(e){return"[UnexpectedJSONParseError]: "+e.message}}},(e,t,n)=>{e.exports=function(e){function t(e){let n,i,a,s=null;function o(...e){if(!o.enabled)return;const r=o,i=Number(new Date),a=i-(n||i);r.diff=a,r.prev=n,r.curr=i,n=i,e[0]=t.coerce(e[0]),"string"!=typeof e[0]&&e.unshift("%O");let s=0;e[0]=e[0].replace(/%([a-zA-Z%])/g,(n,i)=>{if("%%"===n)return"%";s++;const a=t.formatters[i];if("function"==typeof a){const t=e[s];n=a.call(r,t),e.splice(s,1),s--}return n}),t.formatArgs.call(r,e);(r.log||t.log).apply(r,e)}return o.namespace=e,o.useColors=t.useColors(),o.color=t.selectColor(e),o.extend=r,o.destroy=t.destroy,Object.defineProperty(o,"enabled",{enumerable:!0,configurable:!1,get:()=>null!==s?s:(i!==t.namespaces&&(i=t.namespaces,a=t.enabled(e)),a),set:e=>{s=e}}),"function"==typeof t.init&&t.init(o),o}function r(e,n){const r=t(this.namespace+(void 0===n?":":n)+e);return r.log=this.log,r}function i(e,t){let n=0,r=0,i=-1,a=0;for(;n<e.length;)if(r<t.length&&(t[r]===e[n]||"*"===t[r]))"*"===t[r]?(i=r,a=n,r++):(n++,r++);else{if(-1===i)return!1;r=i+1,a++,n=a}for(;r<t.length&&"*"===t[r];)r++;return r===t.length}return t.debug=t,t.default=t,t.coerce=function(e){if(e instanceof Error)return e.stack||e.message;return e},t.disable=function(){const e=[...t.names,...t.skips.map(e=>"-"+e)].join(",");return t.enable(""),e},t.enable=function(e){t.save(e),t.namespaces=e,t.names=[],t.skips=[];const n=("string"==typeof e?e:"").trim().replace(/\s+/g,",").split(",").filter(Boolean);for(const e of n)"-"===e[0]?t.skips.push(e.slice(1)):t.names.push(e)},t.enabled=function(e){for(const n of t.skips)if(i(e,n))return!1;for(const n of t.names)if(i(e,n))return!0;return!1},t.humanize=n(42),t.destroy=function(){console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.")},Object.keys(e).forEach(n=>{t[n]=e[n]}),t.names=[],t.skips=[],t.formatters={},t.selectColor=function(e){let n=0;for(let t=0;t<e.length;t++)n=(n<<5)-n+e.charCodeAt(t),n|=0;return t.colors[Math.abs(n)%t.colors.length]},t.enable(t.load()),t}},e=>{var t=1e3,n=60*t,r=60*n,i=24*r,a=7*i,s=365.25*i;function o(e,t,n,r){var i=t>=1.5*n;return Math.round(e/n)+" "+r+(i?"s":"")}e.exports=function(e,l){l=l||{};var d=typeof e;if("string"===d&&e.length>0)return function(e){if((e=String(e)).length>100)return;var o=/^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(e);if(!o)return;var l=parseFloat(o[1]);switch((o[2]||"ms").toLowerCase()){case"years":case"year":case"yrs":case"yr":case"y":return l*s;case"weeks":case"week":case"w":return l*a;case"days":case"day":case"d":return l*i;case"hours":case"hour":case"hrs":case"hr":case"h":return l*r;case"minutes":case"minute":case"mins":case"min":case"m":return l*n;case"seconds":case"second":case"secs":case"sec":case"s":return l*t;case"milliseconds":case"millisecond":case"msecs":case"msec":case"ms":return l;default:return}}(e);if("number"===d&&isFinite(e))return l.long?function(e){var a=Math.abs(e);if(a>=i)return o(e,a,i,"day");if(a>=r)return o(e,a,r,"hour");if(a>=n)return o(e,a,n,"minute");if(a>=t)return o(e,a,t,"second");return e+" ms"}(e):function(e){var a=Math.abs(e);if(a>=i)return Math.round(e/i)+"d";if(a>=r)return Math.round(e/r)+"h";if(a>=n)return Math.round(e/n)+"m";if(a>=t)return Math.round(e/t)+"s";return e+"ms"}(e);throw new Error("val is not a non-empty string or a valid number. val="+JSON.stringify(e))}},(e,t)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0});const n="-----BEGIN CERTIFICATE-----\nMIIDTzCCAjegAwIBAgIJAKSVpiDswLcwMA0GCSqGSIb3DQEBBQUAMD4xFjAUBgNV\nBAoMDUdhcmFudGlhIERhdGExJDAiBgNVBAMMG1NTTCBDZXJ0aWZpY2F0aW9uIEF1\ndGhvcml0eTAeFw0xMzEwMDExMjE0NTVaFw0yMzA5MjkxMjE0NTVaMD4xFjAUBgNV\nBAoMDUdhcmFudGlhIERhdGExJDAiBgNVBAMMG1NTTCBDZXJ0aWZpY2F0aW9uIEF1\ndGhvcml0eTCCASIwDQYJKoZIhvcNAQEBBQADggEPADCCAQoCggEBALZqkh/DczWP\nJnxnHLQ7QL0T4B4CDKWBKCcisriGbA6ZePWVNo4hfKQC6JrzfR+081NeD6VcWUiz\nrmd+jtPhIY4c+WVQYm5PKaN6DT1imYdxQw7aqO5j2KUCEh/cznpLxeSHoTxlR34E\nQwF28Wl3eg2vc5ct8LjU3eozWVk3gb7alx9mSA2SgmuX5lEQawl++rSjsBStemY2\nBDwOpAMXIrdEyP/cVn8mkvi/BDs5M5G+09j0gfhyCzRWMQ7Hn71u1eolRxwVxgi3\nTMn+/vTaFSqxKjgck6zuAYjBRPaHe7qLxHNr1So/Mc9nPy+3wHebFwbIcnUojwbp\n4nctkWbjb2cCAwEAAaNQME4wHQYDVR0OBBYEFP1whtcrydmW3ZJeuSoKZIKjze3w\nMB8GA1UdIwQYMBaAFP1whtcrydmW3ZJeuSoKZIKjze3wMAwGA1UdEwQFMAMBAf8w\nDQYJKoZIhvcNAQEFBQADggEBAG2erXhwRAa7+ZOBs0B6X57Hwyd1R4kfmXcs0rta\nlbPpvgULSiB+TCbf3EbhJnHGyvdCY1tvlffLjdA7HJ0PCOn+YYLBA0pTU/dyvrN6\nSu8NuS5yubnt9mb13nDGYo1rnt0YRfxN+8DM3fXIVr038A30UlPX2Ou1ExFJT0MZ\nuFKY6ZvLdI6/1cbgmguMlAhM+DhKyV6Sr5699LM3zqeI816pZmlREETYkGr91q7k\nBpXJu/dtHaGxg1ZGu6w/PCsYGUcECWENYD4VQPd8N32JjOfu6vEgoEAwfPP+3oGp\nZ4m3ewACcWOAenqflb+cQYC4PsF7qbXDmRaWrbKntOlZ3n0=\n-----END CERTIFICATE-----\n-----BEGIN CERTIFICATE-----\nMIIGMTCCBBmgAwIBAgICEAAwDQYJKoZIhvcNAQELBQAwajELMAkGA1UEBhMCVVMx\nCzAJBgNVBAgMAkNBMQswCQYDVQQHDAJDQTESMBAGA1UECgwJUmVkaXNMYWJzMS0w\nKwYDVQQDDCRSZWRpc0xhYnMgUm9vdCBDZXJ0aWZpY2F0ZSBBdXRob3JpdHkwHhcN\nMTgwMjI1MTUzNzM3WhcNMjgwMjIzMTUzNzM3WjBfMQswCQYDVQQGEwJVUzELMAkG\nA1UECAwCQ0ExEjAQBgNVBAoMCVJlZGlzTGFiczEvMC0GA1UEAwwmUkNQIEludGVy\nbWVkaWF0ZSBDZXJ0aWZpY2F0ZSBBdXRob3JpdHkwggIiMA0GCSqGSIb3DQEBAQUA\nA4ICDwAwggIKAoICAQDf9dqbxc8Bq7Ctq9rWcxrGNKKHivqLAFpPq02yLPx6fsOv\nTq7GsDChAYBBc4v7Y2Ap9RD5Vs3dIhEANcnolf27QwrG9RMnnvzk8pCvp1o6zSU4\nVuOE1W66/O1/7e2rVxyrnTcP7UgK43zNIXu7+tiAqWsO92uSnuMoGPGpeaUm1jym\nhjWKtkAwDFSqvHY+XL5qDVBEjeUe+WHkYUg40cAXjusAqgm2hZt29c2wnVrxW25W\nP0meNlzHGFdA2AC5z54iRiqj57dTfBTkHoBczQxcyw6hhzxZQ4e5I5zOKjXXEhZN\nr0tA3YC14CTabKRus/JmZieyZzRgEy2oti64tmLYTqSlAD78pRL40VNoaSYetXLw\nhhNsXCHgWaY6d5bLOc/aIQMAV5oLvZQKvuXAF1IDmhPA+bZbpWipp0zagf1P1H3s\nUzsMdn2KM0ejzgotbtNlj5TcrVwpmvE3ktvUAuA+hi3FkVx1US+2Gsp5x4YOzJ7u\nP1WPk6ShF0JgnJH2ILdj6kttTWwFzH17keSFICWDfH/+kM+k7Y1v3EXMQXE7y0T9\nMjvJskz6d/nv+sQhY04xt64xFMGTnZjlJMzfQNi7zWFLTZnDD0lPowq7l3YiPoTT\nt5Xky83lu0KZsZBo0WlWaDG00gLVdtRgVbcuSWxpi5BdLb1kRab66JptWjxwXQID\nAQABo4HrMIHoMDoGA1UdHwQzMDEwL6AtoCuGKWh0dHBzOi8vcmwtY2Etc2VydmVy\nLnJlZGlzbGFicy5jb20vdjEvY3JsMEYGCCsGAQUFBwEBBDowODA2BggrBgEFBQcw\nAYYqaHR0cHM6Ly9ybC1jYS1zZXJ2ZXIucmVkaXNsYWJzLmNvbS92MS9vY3NwMB0G\nA1UdDgQWBBQHar5OKvQUpP2qWt6mckzToeCOHDAfBgNVHSMEGDAWgBQi42wH6hM4\nL2sujEvLM0/u8lRXTzASBgNVHRMBAf8ECDAGAQH/AgEAMA4GA1UdDwEB/wQEAwIB\nhjANBgkqhkiG9w0BAQsFAAOCAgEAirEn/iTsAKyhd+pu2W3Z5NjCko4NPU0EYUbr\nAP7+POK2rzjIrJO3nFYQ/LLuC7KCXG+2qwan2SAOGmqWst13Y+WHp44Kae0kaChW\nvcYLXXSoGQGC8QuFSNUdaeg3RbMDYFT04dOkqufeWVccoHVxyTSg9eD8LZuHn5jw\n7QDLiEECBmIJHk5Eeo2TAZrx4Yx6ufSUX5HeVjlAzqwtAqdt99uCJ/EL8bgpWbe+\nXoSpvUv0SEC1I1dCAhCKAvRlIOA6VBcmzg5Am12KzkqTul12/VEFIgzqu0Zy2Jbc\nAUPrYVu/+tOGXQaijy7YgwH8P8n3s7ZeUa1VABJHcxrxYduDDJBLZi+MjheUDaZ1\njQRHYevI2tlqeSBqdPKG4zBY5lS0GiAlmuze5oENt0P3XboHoZPHiqcK3VECgTVh\n/BkJcuudETSJcZDmQ8YfoKfBzRQNg2sv/hwvUv73Ss51Sco8GEt2lD8uEdib1Q6z\nzDT5lXJowSzOD5ZA9OGDjnSRL+2riNtKWKEqvtEG3VBJoBzu9GoxbAc7wIZLxmli\niF5a/Zf5X+UXD3s4TMmy6C4QZJpAA2egsSQCnraWO2ULhh7iXMysSkF/nzVfZn43\niqpaB8++9a37hWq14ZmOv0TJIDz//b2+KC4VFXWQ5W5QC6whsjT+OlG4p5ZYG0jo\n616pxqo=\n-----END CERTIFICATE-----\n-----BEGIN CERTIFICATE-----\nMIIFujCCA6KgAwIBAgIJAJ1aTT1lu2ScMA0GCSqGSIb3DQEBCwUAMGoxCzAJBgNV\nBAYTAlVTMQswCQYDVQQIDAJDQTELMAkGA1UEBwwCQ0ExEjAQBgNVBAoMCVJlZGlz\nTGFiczEtMCsGA1UEAwwkUmVkaXNMYWJzIFJvb3QgQ2VydGlmaWNhdGUgQXV0aG9y\naXR5MB4XDTE4MDIyNTE1MjA0MloXDTM4MDIyMDE1MjA0MlowajELMAkGA1UEBhMC\nVVMxCzAJBgNVBAgMAkNBMQswCQYDVQQHDAJDQTESMBAGA1UECgwJUmVkaXNMYWJz\nMS0wKwYDVQQDDCRSZWRpc0xhYnMgUm9vdCBDZXJ0aWZpY2F0ZSBBdXRob3JpdHkw\nggIiMA0GCSqGSIb3DQEBAQUAA4ICDwAwggIKAoICAQDLEjXy7YrbN5Waau5cd6g1\nG5C2tMmeTpZ0duFAPxNU4oE3RHS5gGiok346fUXuUxbZ6QkuzeN2/2Z+RmRcJhQY\nDm0ZgdG4x59An1TJfnzKKoWj8ISmoHS/TGNBdFzXV7FYNLBuqZouqePI6ReC6Qhl\npp45huV32Q3a6IDrrvx7Wo5ZczEQeFNbCeCOQYNDdTmCyEkHqc2AGo8eoIlSTutT\nULOC7R5gzJVTS0e1hesQ7jmqHjbO+VQS1NAL4/5K6cuTEqUl+XhVhPdLWBXJQ5ag\n54qhX4v+ojLzeU1R/Vc6NjMvVtptWY6JihpgplprN0Yh2556ewcXMeturcKgXfGJ\nxeYzsjzXerEjrVocX5V8BNrg64NlifzTMKNOOv4fVZszq1SIHR8F9ROrqiOdh8iC\nJpUbLpXH9hWCSEO6VRMB2xJoKu3cgl63kF30s77x7wLFMEHiwsQRKxooE1UhgS9K\n2sO4TlQ1eWUvFvHSTVDQDlGQ6zu4qjbOpb3Q8bQwoK+ai2alkXVR4Ltxe9QlgYK3\nStsnPhruzZGA0wbXdpw0bnM+YdlEm5ffSTpNIfgHeaa7Dtb801FtA71ZlH7A6TaI\nSIQuUST9EKmv7xrJyx0W1pGoPOLw5T029aTjnICSLdtV9bLwysrLhIYG5bnPq78B\ncS+jZHFGzD7PUVGQD01nOQIDAQABo2MwYTAdBgNVHQ4EFgQUIuNsB+oTOC9rLoxL\nyzNP7vJUV08wHwYDVR0jBBgwFoAUIuNsB+oTOC9rLoxLyzNP7vJUV08wDwYDVR0T\nAQH/BAUwAwEB/zAOBgNVHQ8BAf8EBAMCAYYwDQYJKoZIhvcNAQELBQADggIBAHfg\nz5pMNUAKdMzK1aS1EDdK9yKz4qicILz5czSLj1mC7HKDRy8cVADUxEICis++CsCu\nrYOvyCVergHQLREcxPq4rc5Nq1uj6J6649NEeh4WazOOjL4ZfQ1jVznMbGy+fJm3\n3Hoelv6jWRG9iqeJZja7/1s6YC6bWymI/OY1e4wUKeNHAo+Vger7MlHV+RuabaX+\nhSJ8bJAM59NCM7AgMTQpJCncrcdLeceYniGy5Q/qt2b5mJkQVkIdy4TPGGB+AXDJ\nD0q3I/JDRkDUFNFdeW0js7fHdsvCR7O3tJy5zIgEV/o/BCkmJVtuwPYOrw/yOlKj\nTY/U7ATAx9VFF6/vYEOMYSmrZlFX+98L6nJtwDqfLB5VTltqZ4H/KBxGE3IRSt9l\nFXy40U+LnXzhhW+7VBAvyYX8GEXhHkKU8Gqk1xitrqfBXY74xKgyUSTolFSfFVgj\nmcM/X4K45bka+qpkj7Kfv/8D4j6aZekwhN2ly6hhC1SmQ8qjMjpG/mrWOSSHZFmf\nybu9iD2AYHeIOkshIl6xYIa++Q/00/vs46IzAbQyriOi0XxlSMMVtPx0Q3isp+ji\nn8Mq9eOuxYOEQ4of8twUkUDd528iwGtEdwf0Q01UyT84S62N8AySl1ZBKXJz6W4F\nUhWfa/HQYOAPDdEjNgnVwLI23b8t0TozyCWw7q8h\n-----END CERTIFICATE-----\n\n-----BEGIN CERTIFICATE-----\nMIIEjzCCA3egAwIBAgIQe55B/ALCKJDZtdNT8kD6hTANBgkqhkiG9w0BAQsFADBM\nMSAwHgYDVQQLExdHbG9iYWxTaWduIFJvb3QgQ0EgLSBSMzETMBEGA1UEChMKR2xv\nYmFsU2lnbjETMBEGA1UEAxMKR2xvYmFsU2lnbjAeFw0yMjAxMjYxMjAwMDBaFw0y\nNTAxMjYwMDAwMDBaMFgxCzAJBgNVBAYTAkJFMRkwFwYDVQQKExBHbG9iYWxTaWdu\nIG52LXNhMS4wLAYDVQQDEyVHbG9iYWxTaWduIEF0bGFzIFIzIE9WIFRMUyBDQSAy\nMDIyIFEyMIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAmGmg1LW9b7Lf\n8zDD83yBDTEkt+FOxKJZqF4veWc5KZsQj9HfnUS2e5nj/E+JImlGPsQuoiosLuXD\nBVBNAMcUFa11buFMGMeEMwiTmCXoXRrXQmH0qjpOfKgYc5gHG3BsRGaRrf7VR4eg\nofNMG9wUBw4/g/TT7+bQJdA4NfE7Y4d5gEryZiBGB/swaX6Jp/8MF4TgUmOWmalK\ndZCKyb4sPGQFRTtElk67F7vU+wdGcrcOx1tDcIB0ncjLPMnaFicagl+daWGsKqTh\ncounQb6QJtYHa91KvCfKWocMxQ7OIbB5UARLPmC4CJ1/f8YFm35ebfzAeULYdGXu\njE9CLor0OwIDAQABo4IBXzCCAVswDgYDVR0PAQH/BAQDAgGGMB0GA1UdJQQWMBQG\nCCsGAQUFBwMBBggrBgEFBQcDAjASBgNVHRMBAf8ECDAGAQH/AgEAMB0GA1UdDgQW\nBBSH5Zq7a7B/t95GfJWkDBpA8HHqdjAfBgNVHSMEGDAWgBSP8Et/qC5FJK5NUPpj\nmove4t0bvDB7BggrBgEFBQcBAQRvMG0wLgYIKwYBBQUHMAGGImh0dHA6Ly9vY3Nw\nMi5nbG9iYWxzaWduLmNvbS9yb290cjMwOwYIKwYBBQUHMAKGL2h0dHA6Ly9zZWN1\ncmUuZ2xvYmFsc2lnbi5jb20vY2FjZXJ0L3Jvb3QtcjMuY3J0MDYGA1UdHwQvMC0w\nK6ApoCeGJWh0dHA6Ly9jcmwuZ2xvYmFsc2lnbi5jb20vcm9vdC1yMy5jcmwwIQYD\nVR0gBBowGDAIBgZngQwBAgIwDAYKKwYBBAGgMgoBAjANBgkqhkiG9w0BAQsFAAOC\nAQEAKRic9/f+nmhQU/wz04APZLjgG5OgsuUOyUEZjKVhNGDwxGTvKhyXGGAMW2B/\n3bRi+aElpXwoxu3pL6fkElbX3B0BeS5LoDtxkyiVEBMZ8m+sXbocwlPyxrPbX6mY\n0rVIvnuUeBH8X0L5IwfpNVvKnBIilTbcebfHyXkPezGwz7E1yhUULjJFm2bt0SdX\ny+4X/WeiiYIv+fTVgZZgl+/2MKIsu/qdBJc3f3TvJ8nz+Eax1zgZmww+RSQWeOj3\n15Iw6Z5FX+NwzY/Ab+9PosR5UosSeq+9HhtaxZttXG1nVh+avYPGYddWmiMT90J5\nZgKnO/Fx2hBgTxhOTMYaD312kg==\n-----END CERTIFICATE-----\n\n-----BEGIN CERTIFICATE-----\nMIIDXzCCAkegAwIBAgILBAAAAAABIVhTCKIwDQYJKoZIhvcNAQELBQAwTDEgMB4G\nA1UECxMXR2xvYmFsU2lnbiBSb290IENBIC0gUjMxEzARBgNVBAoTCkdsb2JhbFNp\nZ24xEzARBgNVBAMTCkdsb2JhbFNpZ24wHhcNMDkwMzE4MTAwMDAwWhcNMjkwMzE4\nMTAwMDAwWjBMMSAwHgYDVQQLExdHbG9iYWxTaWduIFJvb3QgQ0EgLSBSMzETMBEG\nA1UEChMKR2xvYmFsU2lnbjETMBEGA1UEAxMKR2xvYmFsU2lnbjCCASIwDQYJKoZI\nhvcNAQEBBQADggEPADCCAQoCggEBAMwldpB5BngiFvXAg7aEyiie/QV2EcWtiHL8\nRgJDx7KKnQRfJMsuS+FggkbhUqsMgUdwbN1k0ev1LKMPgj0MK66X17YUhhB5uzsT\ngHeMCOFJ0mpiLx9e+pZo34knlTifBtc+ycsmWQ1z3rDI6SYOgxXG71uL0gRgykmm\nKPZpO/bLyCiR5Z2KYVc3rHQU3HTgOu5yLy6c+9C7v/U9AOEGM+iCK65TpjoWc4zd\nQQ4gOsC0p6Hpsk+QLjJg6VfLuQSSaGjlOCZgdbKfd/+RFO+uIEn8rUAVSNECMWEZ\nXriX7613t2Saer9fwRPvm2L7DWzgVGkWqQPabumDk3F2xmmFghcCAwEAAaNCMEAw\nDgYDVR0PAQH/BAQDAgEGMA8GA1UdEwEB/wQFMAMBAf8wHQYDVR0OBBYEFI/wS3+o\nLkUkrk1Q+mOai97i3Ru8MA0GCSqGSIb3DQEBCwUAA4IBAQBLQNvAUKr+yAzv95ZU\nRUm7lgAJQayzE4aGKAczymvmdLm6AC2upArT9fHxD4q/c2dKg8dEe3jgr25sbwMp\njjM5RcOO5LlXbKr8EpbsU8Yt5CRsuZRj+9xTaGdWPoO4zzUhw8lo/s7awlOqzJCK\n6fBdRoyV3XpYKBovHd7NADdBj+1EbddTKJd+82cEHhXXipa0095MJ6RMG3NzdvQX\nmcIfeg7jLQitChws/zyrVQ4PkX4268NXSb7hLi18YIvDQVETI53O9zJrlAGomecs\nMx86OyXShkDOOyyGeMlhLxS67ttVb9+E7gUJTb0o2HLO02JQZR7rkpeDMdmztcpH\nWD9f\n-----END CERTIFICATE-----",r={RedisCloudFixed:{ca:n},RedisCloudFlexible:{ca:n}};t.default=r},(e,t,n)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0});const r=n(30);class i extends r.RedisError{constructor(e,t){super(e),this.lastNodeError=t,Error.captureStackTrace(this,this.constructor)}get name(){return this.constructor.name}}t.default=i,i.defaultMessage="Failed to refresh slots cache."},(e,t,n)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0});const r=n(46);class i extends r.Readable{constructor(e){super(e),this.opt=e,this._redisCursor="0",this._redisDrained=!1}_read(){if(this._redisDrained)return void this.push(null);const e=[this._redisCursor];this.opt.key&&e.unshift(this.opt.key),this.opt.match&&e.push("MATCH",this.opt.match),this.opt.type&&e.push("TYPE",this.opt.type),this.opt.count&&e.push("COUNT",String(this.opt.count)),this.opt.noValues&&e.push("NOVALUES"),this.opt.redis[this.opt.command](e,(e,t)=>{e?this.emit("error",e):(this._redisCursor=t[0]instanceof Buffer?t[0].toString():t[0],"0"===this._redisCursor&&(this._redisDrained=!0),this.push(t[1]))})}close(){this._redisDrained=!0}}t.default=i},()=>{},(e,t,n)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.addTransactionSupport=void 0;const r=n(35),i=n(27),a=n(48);t.addTransactionSupport=function(e){e.pipeline=function(e){const t=new a.default(this);return Array.isArray(e)&&t.addBatch(e),t};const{multi:t}=e;e.multi=function(e,n){if(void 0!==n||Array.isArray(e)||(n=e,e=null),n&&!1===n.pipeline)return t.call(this);const s=new a.default(this);s.multi(),Array.isArray(e)&&s.addBatch(e);const o=s.exec;s.exec=function(e){if(this.isCluster&&!this.redis.slots.length)return"wait"===this.redis.status&&this.redis.connect().catch(r.noop),(0,i.default)(new Promise((e,t)=>{this.redis.delayUntilReady(n=>{n?t(n):this.exec(s).then(e,t)})}),e);if(this._transactions>0&&o.call(s),this.nodeifiedPromise)return o.call(s);const t=o.call(s);return(0,i.default)(t.then(function(e){const t=e[e.length-1];if(void 0===t)throw new Error("Pipeline cannot be used to send any commands when the `exec()` has been called on it.");if(t[0]){t[0].previousErrors=[];for(let n=0;n<e.length-1;++n)e[n][0]&&t[0].previousErrors.push(e[n][0]);throw t[0]}return(0,r.wrapMultiResult)(t[1])}),e)};const{execBuffer:l}=s;return s.execBuffer=function(e){return this._transactions>0&&l.call(s),s.exec(e)},s};const{exec:n}=e;e.exec=function(e){return(0,i.default)(n.call(this).then(function(e){return Array.isArray(e)&&(e=(0,r.wrapMultiResult)(e)),e}),e)}}},(e,t,n)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0});const r=n(34),i=n(25),a=n(27),s=n(Object(function(){var e=new Error("Cannot find module 'util'");throw e.code="MODULE_NOT_FOUND",e}())),o=n(33),l=n(35),d=n(49);class c extends d.default{constructor(e){super(),this.redis=e,this.isPipeline=!0,this.replyPending=0,this._queue=[],this._result=[],this._transactions=0,this._shaToScript={},this.isCluster="Cluster"===this.redis.constructor.name||this.redis.isCluster,this.options=e.options,Object.keys(e.scriptsSet).forEach(t=>{const n=e.scriptsSet[t];this._shaToScript[n.sha]=n,this[t]=e[t],this[t+"Buffer"]=e[t+"Buffer"]}),e.addedBuiltinSet.forEach(t=>{this[t]=e[t],this[t+"Buffer"]=e[t+"Buffer"]}),this.promise=new Promise((e,t)=>{this.resolve=e,this.reject=t});const t=this;Object.defineProperty(this,"length",{get:function(){return t._queue.length}})}fillResult(e,t){if("exec"===this._queue[t].name&&Array.isArray(e[1])){const n=e[1].length;for(let r=0;r<n;r++){if(e[1][r]instanceof Error)continue;const i=this._queue[t-(n-r)];try{e[1][r]=i.transformReply(e[1][r])}catch(t){e[1][r]=t}}}if(this._result[t]=e,--this.replyPending)return;if(this.isCluster){let e,t=!0;for(let n=0;n<this._result.length;++n){const r=this._result[n][0],a=this._queue[n];if(r){if("exec"===a.name&&"EXECABORT Transaction discarded because of previous errors."===r.message)continue;if(e){if(e.name!==r.name||e.message!==r.message){t=!1;break}}else e={name:r.name,message:r.message}}else if(!a.inTransaction){if(!((0,i.exists)(a.name)&&(0,i.hasFlag)(a.name,"readonly"))){t=!1;break}}}if(e&&t){const t=this,n=e.message.split(" "),r=this._queue;let i=!1;this._queue=[];for(let e=0;e<r.length;++e){if(!("ASK"!==n[0]||i||"asking"===r[e].name||r[e-1]&&"asking"===r[e-1].name)){const e=new o.default("asking");e.ignore=!0,this.sendCommand(e)}r[e].initPromise(),this.sendCommand(r[e]),i=r[e].inTransaction}let a=!0;void 0===this.leftRedirections&&(this.leftRedirections={});const s=function(){t.exec()},l=this.redis;if(l.handleError(e,this.leftRedirections,{moved:function(e,r){t.preferKey=r,l.slots[n[1]]=[r],l._groupsBySlot[n[1]]=l._groupsIds[l.slots[n[1]].join(";")],l.refreshSlotsCache(),t.exec()},ask:function(e,n){t.preferKey=n,t.exec()},tryagain:s,clusterDown:s,connectionClosed:s,maxRedirections:()=>{a=!1},defaults:()=>{a=!1}}),a)return}}let n=0;for(let e=0;e<this._queue.length-n;++e)this._queue[e+n].ignore&&(n+=1),this._result[e]=this._result[e+n];this.resolve(this._result.slice(0,this._result.length-n))}sendCommand(e){this._transactions>0&&(e.inTransaction=!0);const t=this._queue.length;return e.pipelineIndex=t,e.promise.then(e=>{this.fillResult([null,e],t)}).catch(e=>{this.fillResult([e],t)}),this._queue.push(e),this}addBatch(e){let t,n,r;for(let i=0;i<e.length;++i)t=e[i],n=t[0],r=t.slice(1),this[n].apply(this,r);return this}}t.default=c;const u=c.prototype.multi;c.prototype.multi=function(){return this._transactions+=1,u.apply(this,arguments)};const p=c.prototype.execBuffer;c.prototype.execBuffer=(0,s.deprecate)(function(){return this._transactions>0&&(this._transactions-=1),p.apply(this,arguments)},"Pipeline#execBuffer: Use Pipeline#exec instead"),c.prototype.exec=function(e){if(this.isCluster&&!this.redis.slots.length)return"wait"===this.redis.status&&this.redis.connect().catch(l.noop),e&&!this.nodeifiedPromise&&(this.nodeifiedPromise=!0,(0,a.default)(this.promise,e)),this.redis.delayUntilReady(t=>{t?this.reject(t):this.exec(e)}),this.promise;if(this._transactions>0)return this._transactions-=1,p.apply(this,arguments);let t;if(this.nodeifiedPromise||(this.nodeifiedPromise=!0,(0,a.default)(this.promise,e)),this._queue.length||this.resolve([]),this.isCluster){const e=[];for(let t=0;t<this._queue.length;t++){const n=this._queue[t].getKeys();if(n.length&&e.push(n[0]),n.length&&r.generateMulti(n)<0)return this.reject(new Error("All the keys in a pipeline command should belong to the same slot")),this.promise}if(e.length){if(t=function(e,t){const n=r(t[0]),i=e._groupsBySlot[n];for(let n=1;n<t.length;n++)if(e._groupsBySlot[r(t[n])]!==i)return-1;return n}(this.redis,e),t<0)return this.reject(new Error("All keys in the pipeline should belong to the same slots allocation group")),this.promise}else t=16384*Math.random()|0}const n=this;return function(){let e,r=n.replyPending=n._queue.length;n.isCluster&&(e={slot:t,redis:n.redis.connectionPool.nodes.all[n.preferKey]});let i,a="";const s={isPipeline:!0,destination:n.isCluster?e:{redis:n.redis},write(e){"string"!=typeof e?(i||(i=[]),a&&(i.push(Buffer.from(a,"utf8")),a=""),i.push(e)):a+=e,--r||(i?(a&&i.push(Buffer.from(a,"utf8")),s.destination.redis.stream.write(Buffer.concat(i))):s.destination.redis.stream.write(a),r=n._queue.length,a="",i=void 0)}};for(let t=0;t<n._queue.length;++t)n.redis.sendCommand(n._queue[t],s,e);n.promise}(),this.promise}},(e,t,n)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0});const r=n(25),i=n(50),a=n(33),s=n(51);class o{constructor(){this.options={},this.scriptsSet={},this.addedBuiltinSet=new Set}getBuiltinCommands(){return l.slice(0)}createBuiltinCommand(e){return{string:d(null,e,"utf8"),buffer:d(null,e,null)}}addBuiltinCommand(e){this.addedBuiltinSet.add(e),this[e]=d(e,e,"utf8"),this[e+"Buffer"]=d(e+"Buffer",e,null)}defineCommand(e,t){const n=new s.default(t.lua,t.numberOfKeys,this.options.keyPrefix,t.readOnly);this.scriptsSet[e]=n,this[e]=c(e,e,n,"utf8"),this[e+"Buffer"]=c(e+"Buffer",e,n,null)}sendCommand(e,t,n){throw new Error('"sendCommand" is not implemented')}}const l=r.list.filter(e=>"monitor"!==e);function d(e,t,n){return void 0===n&&(n=t,t=null),function(...r){const s=t||r.shift();let o=r[r.length-1];"function"==typeof o?r.pop():o=void 0;const l={errorStack:this.options.showFriendlyErrorStack?new Error:void 0,keyPrefix:this.options.keyPrefix,replyEncoding:n};return(0,i.shouldUseAutoPipelining)(this,e,s)?(0,i.executeWithAutoPipelining)(this,e,s,r,o):this.sendCommand(new a.default(s,r,l,o))}}function c(e,t,n,r){return function(...a){const s="function"==typeof a[a.length-1]?a.pop():void 0,o={replyEncoding:r};return this.options.showFriendlyErrorStack&&(o.errorStack=new Error),(0,i.shouldUseAutoPipelining)(this,e,t)?(0,i.executeWithAutoPipelining)(this,e,t,a,s):n.execute(this,a,o,s)}}l.push("sentinel"),l.forEach(function(e){o.prototype[e]=d(e,e,"utf8"),o.prototype[e+"Buffer"]=d(e+"Buffer",e,null)}),o.prototype.call=d("call","utf8"),o.prototype.callBuffer=d("callBuffer",null),o.prototype.send_command=o.prototype.call,t.default=o},(e,t,n)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.executeWithAutoPipelining=t.getFirstValueInFlattenedArray=t.shouldUseAutoPipelining=t.notAllowedAutoPipelineCommands=t.kCallbacks=t.kExec=void 0;const r=n(36),i=n(34),a=n(27);function s(e,n){if(e._runningAutoPipelines.has(n))return;if(!e._autoPipelines.has(n))return;e._runningAutoPipelines.add(n);const r=e._autoPipelines.get(n);e._autoPipelines.delete(n);const i=r[t.kCallbacks];r[t.kCallbacks]=null,r.exec(function(t,r){if(e._runningAutoPipelines.delete(n),t)for(let e=0;e<i.length;e++)process.nextTick(i[e],t);else for(let e=0;e<i.length;e++)process.nextTick(i[e],...r[e]);e._autoPipelines.has(n)&&s(e,n)})}function o(e){for(let t=0;t<e.length;t++){const n=e[t];if("string"==typeof n)return n;if(Array.isArray(n)||(0,r.isArguments)(n)){if(0===n.length)continue;return n[0]}const i=[n].flat();if(i.length>0)return i[0]}}t.kExec=Symbol("exec"),t.kCallbacks=Symbol("callbacks"),t.notAllowedAutoPipelineCommands=["auth","info","script","quit","cluster","pipeline","multi","subscribe","psubscribe","unsubscribe","unpsubscribe","select"],t.shouldUseAutoPipelining=function(e,n,r){return n&&e.options.enableAutoPipelining&&!e.isPipeline&&!t.notAllowedAutoPipelineCommands.includes(r)&&!e.options.autoPipeliningIgnoredCommands.includes(r)},t.getFirstValueInFlattenedArray=o,t.executeWithAutoPipelining=function e(n,l,d,c,u){if(n.isCluster&&!n.slots.length)return"wait"===n.status&&n.connect().catch(r.noop),(0,a.default)(new Promise(function(t,r){n.delayUntilReady(i=>{i?r(i):e(n,l,d,c,null).then(t,r)})}),u);const p=n.options.keyPrefix||"",h=n.isCluster?n.slots[i(`${p}${o(c)}`)].join(","):"main";if(!n._autoPipelines.has(h)){const e=n.pipeline();e[t.kExec]=!1,e[t.kCallbacks]=[],n._autoPipelines.set(h,e)}const y=n._autoPipelines.get(h);y[t.kExec]||(y[t.kExec]=!0,setImmediate(s,n,h));const m=new Promise(function(e,n){y[t.kCallbacks].push(function(t,r){t?n(t):e(r)}),"call"===l&&c.unshift(d),y[l](...c)});return(0,a.default)(m,u)}},(e,t,n)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0});const r=n(52),i=n(33),a=n(27);t.default=class{constructor(e,t=null,n="",a=!1){this.lua=e,this.numberOfKeys=t,this.keyPrefix=n,this.readOnly=a,this.sha=(0,r.createHash)("sha1").update(e).digest("hex");const s=this.sha,o=new WeakSet;this.Command=class extends i.default{toWritable(t){const n=this.reject;return this.reject=e=>{-1!==e.message.indexOf("NOSCRIPT")&&o.delete(t),n.call(this,e)},o.has(t)?"eval"===this.name&&(this.name="evalsha",this.args[0]=s):(o.add(t),this.name="eval",this.args[0]=e),super.toWritable(t)}}}execute(e,t,n,r){"number"==typeof this.numberOfKeys&&t.unshift(this.numberOfKeys),this.keyPrefix&&(n.keyPrefix=this.keyPrefix),this.readOnly&&(n.readOnly=!0);const i=new this.Command("evalsha",[this.sha,...t],n);return i.promise=i.promise.catch(r=>{if(-1===r.message.indexOf("NOSCRIPT"))throw r;const i=new this.Command("evalsha",[this.sha,...t],n);return(e.isPipeline?e.redis:e).sendCommand(i)}),(0,a.default)(i.promise,r),e.sendCommand(i)}}},()=>{},(e,t)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.default=function(e,t){Object.getOwnPropertyNames(t.prototype).forEach(n=>{Object.defineProperty(e.prototype,n,Object.getOwnPropertyDescriptor(t.prototype,n))})}},(e,t,n)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.DEFAULT_CLUSTER_OPTIONS=void 0;const r=n(55);t.DEFAULT_CLUSTER_OPTIONS={clusterRetryStrategy:e=>Math.min(100+2*e,2e3),enableOfflineQueue:!0,enableReadyCheck:!0,scaleReads:"master",maxRedirections:16,retryDelayOnMoved:0,retryDelayOnFailover:100,retryDelayOnClusterDown:100,retryDelayOnTryAgain:100,slotsRefreshTimeout:1e3,useSRVRecords:!1,resolveSrv:r.resolveSrv,dnsLookup:r.lookup,enableAutoPipelining:!1,autoPipeliningIgnoredCommands:[],shardedSubscribers:!1}},()=>{},(e,t,n)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0});const r=n(57),i=n(35),a=n(20),s=(0,i.Debug)("cluster:subscriber");t.default=class{constructor(e,t,n=!1){this.connectionPool=e,this.emitter=t,this.isSharded=n,this.started=!1,this.subscriber=null,this.slotRange=[],this.onSubscriberEnd=()=>{this.started?(s("subscriber has disconnected, selecting a new one..."),this.selectSubscriber()):s("subscriber has disconnected, but ClusterSubscriber is not started, so not reconnecting.")},this.connectionPool.on("-node",(e,t)=>{this.started&&this.subscriber&&(0,r.getNodeKey)(this.subscriber.options)===t&&(s("subscriber has left, selecting a new one..."),this.selectSubscriber())}),this.connectionPool.on("+node",()=>{this.started&&!this.subscriber&&(s("a new node is discovered and there is no subscriber, selecting a new one..."),this.selectSubscriber())})}getInstance(){return this.subscriber}associateSlotRange(e){return this.isSharded&&(this.slotRange=e),this.slotRange}start(){this.started=!0,this.selectSubscriber(),s("started")}stop(){this.started=!1,this.subscriber&&(this.subscriber.disconnect(),this.subscriber=null)}isStarted(){return this.started}selectSubscriber(){const e=this.lastActiveSubscriber;e&&(e.off("end",this.onSubscriberEnd),e.disconnect()),this.subscriber&&(this.subscriber.off("end",this.onSubscriberEnd),this.subscriber.disconnect());const t=(0,i.sample)(this.connectionPool.getNodes());if(!t)return s("selecting subscriber failed since there is no node discovered in the cluster yet"),void(this.subscriber=null);const{options:n}=t;s("selected a subscriber %s:%s",n.host,n.port);let o="subscriber";this.isSharded&&(o="ssubscriber"),this.subscriber=new a.default({port:n.port,host:n.host,username:n.username,password:n.password,enableReadyCheck:!0,connectionName:(0,r.getConnectionName)(o,n.connectionName),lazyConnect:!0,tls:n.tls,retryStrategy:null}),this.subscriber.on("error",i.noop),this.subscriber.once("end",this.onSubscriberEnd);const l={subscribe:[],psubscribe:[],ssubscribe:[]};if(e){const t=e.condition||e.prevCondition;t&&t.subscriber&&(l.subscribe=t.subscriber.channels("subscribe"),l.psubscribe=t.subscriber.channels("psubscribe"),l.ssubscribe=t.subscriber.channels("ssubscribe"))}if(l.subscribe.length||l.psubscribe.length||l.ssubscribe.length){let e=0;for(const t of["subscribe","psubscribe","ssubscribe"]){const n=l[t];n.length&&(e+=1,s("%s %d channels",t,n.length),this.subscriber[t](n).then(()=>{--e||(this.lastActiveSubscriber=this.subscriber)}).catch(()=>{s("failed to %s %d channels",t,n.length)}))}}else this.lastActiveSubscriber=this.subscriber;for(const e of["message","messageBuffer"])this.subscriber.on(e,(t,n)=>{this.emitter.emit(e,t,n)});for(const e of["pmessage","pmessageBuffer"])this.subscriber.on(e,(t,n,r)=>{this.emitter.emit(e,t,n,r)});if(1==this.isSharded)for(const e of["smessage","smessageBuffer"])this.subscriber.on(e,(t,n)=>{this.emitter.emit(e,t,n)})}}},(e,t,n)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.getConnectionName=t.weightSrvRecords=t.groupSrvRecords=t.getUniqueHostnamesFromOptions=t.normalizeNodeOptions=t.nodeKeyToRedisOptions=t.getNodeKey=void 0;const r=n(35),i=n(58);t.getNodeKey=function(e){return e.port=e.port||6379,e.host=e.host||"127.0.0.1",e.host+":"+e.port},t.nodeKeyToRedisOptions=function(e){const t=e.lastIndexOf(":");if(-1===t)throw new Error(`Invalid node key ${e}`);return{host:e.slice(0,t),port:Number(e.slice(t+1))}},t.normalizeNodeOptions=function(e){return e.map(e=>{const t={};if("object"==typeof e)Object.assign(t,e);else if("string"==typeof e)Object.assign(t,(0,r.parseURL)(e));else{if("number"!=typeof e)throw new Error("Invalid argument "+e);t.port=e}return"string"==typeof t.port&&(t.port=parseInt(t.port,10)),delete t.db,t.port||(t.port=6379),t.host||(t.host="127.0.0.1"),(0,r.resolveTLSProfile)(t)})},t.getUniqueHostnamesFromOptions=function(e){const t={};return e.forEach(e=>{t[e.host]=!0}),Object.keys(t).filter(e=>!(0,i.isIP)(e))},t.groupSrvRecords=function(e){const t={};for(const n of e)t.hasOwnProperty(n.priority)?(t[n.priority].totalWeight+=n.weight,t[n.priority].records.push(n)):t[n.priority]={totalWeight:n.weight,records:[n]};return t},t.weightSrvRecords=function(e){if(1===e.records.length)return e.totalWeight=0,e.records.shift();const t=Math.floor(Math.random()*(e.totalWeight+e.records.length));let n=0;for(const[r,i]of e.records.entries())if(n+=1+i.weight,n>t)return e.totalWeight-=i.weight,e.records.splice(r,1),i},t.getConnectionName=function(e,t){const n=`ioredis-cluster(${e})`;return t?`${n}:${t}`:n}},()=>{},(e,t,n)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0});const r=n(14),i=n(35),a=n(57),s=n(20),o=(0,i.Debug)("cluster:connectionPool");class l extends r.EventEmitter{constructor(e){super(),this.redisOptions=e,this.nodes={all:{},master:{},slave:{}},this.specifiedOptions={}}getNodes(e="all"){const t=this.nodes[e];return Object.keys(t).map(e=>t[e])}getInstanceByKey(e){return this.nodes.all[e]}getSampleInstance(e){const t=Object.keys(this.nodes[e]),n=(0,i.sample)(t);return this.nodes[e][n]}addMasterNode(e){const t=(0,a.getNodeKey)(e.options),n=this.createRedisFromOptions(e,e.options.readOnly);return!e.options.readOnly&&(this.nodes.all[t]=n,this.nodes.master[t]=n,!0)}createRedisFromOptions(e,t){return new s.default((0,i.defaults)({retryStrategy:null,enableOfflineQueue:!0,readOnly:t},e,this.redisOptions,{lazyConnect:!0}))}findOrCreate(e,t=!1){const n=(0,a.getNodeKey)(e);let r;return t=Boolean(t),this.specifiedOptions[n]?Object.assign(e,this.specifiedOptions[n]):this.specifiedOptions[n]=e,this.nodes.all[n]?(r=this.nodes.all[n],r.options.readOnly!==t&&(r.options.readOnly=t,o("Change role of %s to %s",n,t?"slave":"master"),r[t?"readonly":"readwrite"]().catch(i.noop),t?(delete this.nodes.master[n],this.nodes.slave[n]=r):(delete this.nodes.slave[n],this.nodes.master[n]=r))):(o("Connecting to %s as %s",n,t?"slave":"master"),r=this.createRedisFromOptions(e,t),this.nodes.all[n]=r,this.nodes[t?"slave":"master"][n]=r,r.once("end",()=>{this.removeNode(n),this.emit("-node",r,n),Object.keys(this.nodes.all).length||this.emit("drain")}),this.emit("+node",r,n),r.on("error",function(e){this.emit("nodeError",e,n)})),r}reset(e){o("Reset with %O",e);const t={};e.forEach(e=>{const n=(0,a.getNodeKey)(e);e.readOnly&&t[n]||(t[n]=e)}),Object.keys(this.nodes.all).forEach(e=>{t[e]||(o("Disconnect %s because the node does not hold any slot",e),this.nodes.all[e].disconnect(),this.removeNode(e))}),Object.keys(t).forEach(e=>{const n=t[e];this.findOrCreate(n,n.readOnly)})}removeNode(e){const{nodes:t}=this;t.all[e]&&(o("Remove %s from the pool",e),delete t.all[e]),delete t.master[e],delete t.slave[e]}}t.default=l},(e,t,n)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0});const r=n(35),i=n(61),a=(0,r.Debug)("delayqueue");t.default=class{constructor(){this.queues={},this.timeouts={}}push(e,t,n){const r=n.callback||process.nextTick;this.queues[e]||(this.queues[e]=new i);this.queues[e].push(t),this.timeouts[e]||(this.timeouts[e]=setTimeout(()=>{r(()=>{this.timeouts[e]=null,this.execute(e)})},n.timeout))}execute(e){const t=this.queues[e];if(!t)return;const{length:n}=t;if(n)for(a("send %d commands in %s queue",n,e),this.queues[e]=null;t.length>0;)t.shift()()}}},e=>{"use strict";function t(e,t){t=t||{};this._capacity=t.capacity,this._head=0,this._tail=0,Array.isArray(e)?this._fromArray(e):(this._capacityMask=3,this._list=new Array(4))}t.prototype.peekAt=function(e){var t=e;if(t===(0|t)){var n=this.size();if(!(t>=n||t<-n))return t<0&&(t+=n),t=this._head+t&this._capacityMask,this._list[t]}},t.prototype.get=function(e){return this.peekAt(e)},t.prototype.peek=function(){if(this._head!==this._tail)return this._list[this._head]},t.prototype.peekFront=function(){return this.peek()},t.prototype.peekBack=function(){return this.peekAt(-1)},Object.defineProperty(t.prototype,"length",{get:function(){return this.size()}}),t.prototype.size=function(){return this._head===this._tail?0:this._head<this._tail?this._tail-this._head:this._capacityMask+1-(this._head-this._tail)},t.prototype.unshift=function(e){if(0===arguments.length)return this.size();var t=this._list.length;return this._head=this._head-1+t&this._capacityMask,this._list[this._head]=e,this._tail===this._head&&this._growArray(),this._capacity&&this.size()>this._capacity&&this.pop(),this._head<this._tail?this._tail-this._head:this._capacityMask+1-(this._head-this._tail)},t.prototype.shift=function(){var e=this._head;if(e!==this._tail){var t=this._list[e];return this._list[e]=void 0,this._head=e+1&this._capacityMask,e<2&&this._tail>1e4&&this._tail<=this._list.length>>>2&&this._shrinkArray(),t}},t.prototype.push=function(e){if(0===arguments.length)return this.size();var t=this._tail;return this._list[t]=e,this._tail=t+1&this._capacityMask,this._tail===this._head&&this._growArray(),this._capacity&&this.size()>this._capacity&&this.shift(),this._head<this._tail?this._tail-this._head:this._capacityMask+1-(this._head-this._tail)},t.prototype.pop=function(){var e=this._tail;if(e!==this._head){var t=this._list.length;this._tail=e-1+t&this._capacityMask;var n=this._list[this._tail];return this._list[this._tail]=void 0,this._head<2&&e>1e4&&e<=t>>>2&&this._shrinkArray(),n}},t.prototype.removeOne=function(e){var t=e;if(t===(0|t)&&this._head!==this._tail){var n=this.size(),r=this._list.length;if(!(t>=n||t<-n)){t<0&&(t+=n),t=this._head+t&this._capacityMask;var i,a=this._list[t];if(e<n/2){for(i=e;i>0;i--)this._list[t]=this._list[t=t-1+r&this._capacityMask];this._list[t]=void 0,this._head=this._head+1+r&this._capacityMask}else{for(i=n-1-e;i>0;i--)this._list[t]=this._list[t=t+1+r&this._capacityMask];this._list[t]=void 0,this._tail=this._tail-1+r&this._capacityMask}return a}}},t.prototype.remove=function(e,t){var n,r=e,i=t;if(r===(0|r)&&this._head!==this._tail){var a=this.size(),s=this._list.length;if(!(r>=a||r<-a||t<1)){if(r<0&&(r+=a),1===t||!t)return(n=new Array(1))[0]=this.removeOne(r),n;if(0===r&&r+t>=a)return n=this.toArray(),this.clear(),n;var o;for(r+t>a&&(t=a-r),n=new Array(t),o=0;o<t;o++)n[o]=this._list[this._head+r+o&this._capacityMask];if(r=this._head+r&this._capacityMask,e+t===a){for(this._tail=this._tail-t+s&this._capacityMask,o=t;o>0;o--)this._list[r=r+1+s&this._capacityMask]=void 0;return n}if(0===e){for(this._head=this._head+t+s&this._capacityMask,o=t-1;o>0;o--)this._list[r=r+1+s&this._capacityMask]=void 0;return n}if(r<a/2){for(this._head=this._head+e+t+s&this._capacityMask,o=e;o>0;o--)this.unshift(this._list[r=r-1+s&this._capacityMask]);for(r=this._head-1+s&this._capacityMask;i>0;)this._list[r=r-1+s&this._capacityMask]=void 0,i--;e<0&&(this._tail=r)}else{for(this._tail=r,r=r+t+s&this._capacityMask,o=a-(t+e);o>0;o--)this.push(this._list[r++]);for(r=this._tail;i>0;)this._list[r=r+1+s&this._capacityMask]=void 0,i--}return this._head<2&&this._tail>1e4&&this._tail<=s>>>2&&this._shrinkArray(),n}}},t.prototype.splice=function(e,t){var n=e;if(n===(0|n)){var r=this.size();if(n<0&&(n+=r),!(n>r)){if(arguments.length>2){var i,a,s,o=arguments.length,l=this._list.length,d=2;if(!r||n<r/2){for(a=new Array(n),i=0;i<n;i++)a[i]=this._list[this._head+i&this._capacityMask];for(0===t?(s=[],n>0&&(this._head=this._head+n+l&this._capacityMask)):(s=this.remove(n,t),this._head=this._head+n+l&this._capacityMask);o>d;)this.unshift(arguments[--o]);for(i=n;i>0;i--)this.unshift(a[i-1])}else{var c=(a=new Array(r-(n+t))).length;for(i=0;i<c;i++)a[i]=this._list[this._head+n+t+i&this._capacityMask];for(0===t?(s=[],n!=r&&(this._tail=this._head+n+l&this._capacityMask)):(s=this.remove(n,t),this._tail=this._tail-c+l&this._capacityMask);d<o;)this.push(arguments[d++]);for(i=0;i<c;i++)this.push(a[i])}return s}return this.remove(n,t)}}},t.prototype.clear=function(){this._list=new Array(this._list.length),this._head=0,this._tail=0},t.prototype.isEmpty=function(){return this._head===this._tail},t.prototype.toArray=function(){return this._copyArray(!1)},t.prototype._fromArray=function(e){var t=e.length,n=this._nextPowerOf2(t);this._list=new Array(n),this._capacityMask=n-1,this._tail=t;for(var r=0;r<t;r++)this._list[r]=e[r]},t.prototype._copyArray=function(e,t){var n=this._list,r=n.length,i=this.length;if((t|=i)==i&&this._head<this._tail)return this._list.slice(this._head,this._tail);var a,s=new Array(t),o=0;if(e||this._head>this._tail){for(a=this._head;a<r;a++)s[o++]=n[a];for(a=0;a<this._tail;a++)s[o++]=n[a]}else for(a=this._head;a<this._tail;a++)s[o++]=n[a];return s},t.prototype._growArray=function(){if(0!=this._head){var e=this._copyArray(!0,this._list.length<<1);this._tail=this._list.length,this._head=0,this._list=e}else this._tail=this._list.length,this._list.length<<=1;this._capacityMask=this._capacityMask<<1|1},t.prototype._shrinkArray=function(){this._list.length>>>=1,this._capacityMask>>>=1},t.prototype._nextPowerOf2=function(e){var t=1<<Math.log(e)/Math.log(2)+1;return Math.max(t,4)},e.exports=t},(e,t,n)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0});const r=n(35),i=n(56),a=n(59),s=n(57),o=n(34),l=(0,r.Debug)("cluster:subscriberGroup");t.default=class{constructor(e){this.cluster=e,this.shardedSubscribers=new Map,this.clusterSlots=[],this.subscriberToSlotsIndex=new Map,this.channels=new Map,e.on("+node",e=>{this._addSubscriber(e)}),e.on("-node",e=>{this._removeSubscriber(e)}),e.on("refresh",()=>{this._refreshSlots(e)})}getResponsibleSubscriber(e){const t=this.clusterSlots[e][0];return this.shardedSubscribers.get(t)}addChannels(e){const t=o(e[0]);e.forEach(e=>{if(o(e)!=t)return-1});const n=this.channels.get(t);return n?this.channels.set(t,n.concat(e)):this.channels.set(t,e),[...this.channels.values()].flatMap(e=>e).length}removeChannels(e){const t=o(e[0]);e.forEach(e=>{if(o(e)!=t)return-1});const n=this.channels.get(t);if(n){const r=n.filter(t=>!e.includes(t));this.channels.set(t,r)}return[...this.channels.values()].flatMap(e=>e).length}stop(){for(const e of this.shardedSubscribers.values())e.stop()}start(){for(const e of this.shardedSubscribers.values())e.isStarted()||e.start()}_addSubscriber(e){const t=new a.default(e.options);if(t.addMasterNode(e)){const n=new i.default(t,this.cluster,!0),r=(0,s.getNodeKey)(e.options);return this.shardedSubscribers.set(r,n),n.start(),this._resubscribe(),this.cluster.emit("+subscriber"),n}return null}_removeSubscriber(e){const t=(0,s.getNodeKey)(e.options),n=this.shardedSubscribers.get(t);return n&&(n.stop(),this.shardedSubscribers.delete(t),this._resubscribe(),this.cluster.emit("-subscriber")),this.shardedSubscribers}_refreshSlots(e){if(!this._slotsAreEqual(e.slots)){l("Refreshing the slots of the subscriber group."),this.subscriberToSlotsIndex=new Map;for(let t=0;t<e.slots.length;t++){const n=e.slots[t][0];this.subscriberToSlotsIndex.has(n)||this.subscriberToSlotsIndex.set(n,[]),this.subscriberToSlotsIndex.get(n).push(Number(t))}return this._resubscribe(),this.clusterSlots=JSON.parse(JSON.stringify(e.slots)),this.cluster.emit("subscribersReady"),!0}return l("Nothing to refresh because the new cluster map is equal to the previous one."),!1}_resubscribe(){this.shardedSubscribers&&this.shardedSubscribers.forEach((e,t)=>{const n=this.subscriberToSlotsIndex.get(t);n&&(e.associateSlotRange(n),n.forEach(t=>{const n=e.getInstance(),r=this.channels.get(t);r&&r.length>0&&n&&(n.ssubscribe(r),n.on("ready",()=>{n.ssubscribe(r)}))}))})}_slotsAreEqual(e){return void 0!==this.clusterSlots&&JSON.stringify(this.clusterSlots)===JSON.stringify(e)}}},(e,t,n)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.SentinelConnector=t.StandaloneConnector=void 0;const r=n(64);t.StandaloneConnector=r.default;const i=n(68);t.SentinelConnector=i.default},(e,t,n)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0});const r=n(65),i=n(66),a=n(35),s=n(67);class o extends s.default{constructor(e){super(e.disconnectTimeout),this.options=e}connect(e){const{options:t}=this;let n;return this.connecting=!0,"path"in t&&t.path?n={path:t.path}:(n={},"port"in t&&null!=t.port&&(n.port=t.port),"host"in t&&null!=t.host&&(n.host=t.host),"family"in t&&null!=t.family&&(n.family=t.family)),t.tls&&Object.assign(n,t.tls),new Promise((e,s)=>{process.nextTick(()=>{if(this.connecting){try{t.tls?this.stream=(0,i.connect)(n):this.stream=(0,r.createConnection)(n)}catch(e){return void s(e)}this.stream.once("error",e=>{this.firstError=e}),e(this.stream)}else s(new Error(a.CONNECTION_CLOSED_ERROR_MSG))})})}}t.default=o},()=>{},()=>{},(e,t,n)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0});const r=(0,n(35).Debug)("AbstractConnector");t.default=class{constructor(e){this.connecting=!1,this.disconnectTimeout=e}check(e){return!0}disconnect(){if(this.connecting=!1,this.stream){const e=this.stream,t=setTimeout(()=>{r("stream %s:%s still open, destroying it",e.remoteAddress,e.remotePort),e.destroy()},this.disconnectTimeout);e.on("close",()=>clearTimeout(t)),e.end()}}}},(e,t,n)=>{"use strict";var r=n(21);function i(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter(function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable})),n.push.apply(n,r)}return n}Object.defineProperty(t,"__esModule",{value:!0}),t.SentinelIterator=void 0;const a=n(69),s=n(35),o=n(70),l=n(71);t.SentinelIterator=l.default;const d=n(67),c=n(20),u=n(72),p=(0,s.Debug)("SentinelConnector");class h extends d.default{constructor(e){if(super(e.disconnectTimeout),this.options=e,this.emitter=null,this.failoverDetector=null,!this.options.sentinels.length)throw new Error("Requires at least one sentinel to connect to.");if(!this.options.name)throw new Error("Requires the name of master.");this.sentinelIterator=new l.default(this.options.sentinels)}check(e){const t=!e.role||this.options.role===e.role;return t||(p("role invalid, expected %s, but got %s",this.options.role,e.role),this.sentinelIterator.next(),this.sentinelIterator.next(),this.sentinelIterator.reset(!0)),t}disconnect(){super.disconnect(),this.failoverDetector&&this.failoverDetector.cleanup()}connect(e){let t;this.connecting=!0,this.retryAttempts=0;const n=async()=>{const r=this.sentinelIterator.next();if(r.done){this.sentinelIterator.reset(!1);const r="function"==typeof this.options.sentinelRetryStrategy?this.options.sentinelRetryStrategy(++this.retryAttempts):null;let i="number"!=typeof r?"All sentinels are unreachable and retry is disabled.":`All sentinels are unreachable. Retrying from scratch after ${r}ms.`;t&&(i+=` Last error: ${t.message}`),p(i);const a=new Error(i);if("number"==typeof r)return e("error",a),await new Promise(e=>setTimeout(e,r)),n();throw a}let i=null,l=null;try{i=await this.resolve(r.value)}catch(e){l=e}if(!this.connecting)throw new Error(s.CONNECTION_CLOSED_ERROR_MSG);const d=r.value.host+":"+r.value.port;if(i)return p("resolved: %s:%s from sentinel %s",i.host,i.port,d),this.options.enableTLSForSentinelMode&&this.options.tls?(Object.assign(i,this.options.tls),this.stream=(0,o.connect)(i),this.stream.once("secureConnect",this.initFailoverDetector.bind(this))):(this.stream=(0,a.createConnection)(i),this.stream.once("connect",this.initFailoverDetector.bind(this))),this.stream.once("error",e=>{this.firstError=e}),this.stream;{const r=l?"failed to connect to sentinel "+d+" because "+l.message:"connected to sentinel "+d+" successfully, but got an invalid reply: "+i;return p(r),e("sentinelError",new Error(r)),l&&(t=l),n()}};return n()}async updateSentinels(e){if(!this.options.updateSentinels)return;const t=await e.sentinel("sentinels",this.options.name);Array.isArray(t)&&(t.map(s.packObject).forEach(e=>{if(-1===(e.flags?e.flags.split(","):[]).indexOf("disconnected")&&e.ip&&e.port){const t=this.sentinelNatResolve(y(e));this.sentinelIterator.add(t)&&p("adding sentinel %s:%s",t.host,t.port)}}),p("Updated internal sentinels: %s",this.sentinelIterator))}async resolveMaster(e){const t=await e.sentinel("get-master-addr-by-name",this.options.name);return await this.updateSentinels(e),this.sentinelNatResolve(Array.isArray(t)?{host:t[0],port:Number(t[1])}:null)}async resolveSlave(e){const t=await e.sentinel("slaves",this.options.name);if(!Array.isArray(t))return null;const n=t.map(s.packObject).filter(e=>e.flags&&!e.flags.match(/(disconnected|s_down|o_down)/));return this.sentinelNatResolve(function(e,t){if(0===e.length)return null;let n;if("function"==typeof t)n=t(e);else if(null!==t&&"object"==typeof t){const r=Array.isArray(t)?t:[t];r.sort((e,t)=>(e.prio||(e.prio=1),t.prio||(t.prio=1),e.prio<t.prio?-1:e.prio>t.prio?1:0));for(let t=0;t<r.length;t++){for(let i=0;i<e.length;i++){const a=e[i];if(a.ip===r[t].ip&&a.port===r[t].port){n=a;break}}if(n)break}}n||(n=(0,s.sample)(e));return y(n)}(n,this.options.preferredSlaves))}sentinelNatResolve(e){if(!e||!this.options.natMap)return e;const t=`${e.host}:${e.port}`;let n=e;return"function"==typeof this.options.natMap?n=this.options.natMap(t)||e:"object"==typeof this.options.natMap&&(n=this.options.natMap[t]||e),n}connectToSentinel(e,t){const n=new c.default(function(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?i(Object(n),!0).forEach(function(t){r(e,t,n[t])}):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach(function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))})}return e}({port:e.port||26379,host:e.host,username:this.options.sentinelUsername||null,password:this.options.sentinelPassword||null,family:e.family||("path"in this.options&&this.options.path?void 0:this.options.family),tls:this.options.sentinelTLS,retryStrategy:null,enableReadyCheck:!1,connectTimeout:this.options.connectTimeout,commandTimeout:this.options.sentinelCommandTimeout},t));return n}async resolve(e){const t=this.connectToSentinel(e);t.on("error",m);try{return"slave"===this.options.role?await this.resolveSlave(t):await this.resolveMaster(t)}finally{t.disconnect()}}async initFailoverDetector(){var e;if(!this.options.failoverDetector)return;this.sentinelIterator.reset(!0);const t=[];for(;t.length<this.options.sentinelMaxConnections;){const{done:e,value:n}=this.sentinelIterator.next();if(e)break;const r=this.connectToSentinel(n,{lazyConnect:!0,retryStrategy:this.options.sentinelReconnectStrategy});r.on("reconnecting",()=>{var e;null===(e=this.emitter)||void 0===e||e.emit("sentinelReconnecting")}),t.push({address:n,client:r})}this.sentinelIterator.reset(!1),this.failoverDetector&&this.failoverDetector.cleanup(),this.failoverDetector=new u.FailoverDetector(this,t),await this.failoverDetector.subscribe(),null===(e=this.emitter)||void 0===e||e.emit("failoverSubscribed")}}function y(e){return{host:e.ip,port:Number(e.port)}}function m(){}t.default=h},()=>{},()=>{},(e,t)=>{"use strict";function n(e,t){return(e.host||"127.0.0.1")===(t.host||"127.0.0.1")&&(e.port||26379)===(t.port||26379)}Object.defineProperty(t,"__esModule",{value:!0});t.default=class{constructor(e){this.cursor=0,this.sentinels=e.slice(0)}next(){const e=this.cursor>=this.sentinels.length;return{done:e,value:e?void 0:this.sentinels[this.cursor++]}}reset(e){e&&this.sentinels.length>1&&1!==this.cursor&&this.sentinels.unshift(...this.sentinels.splice(this.cursor-1)),this.cursor=0}add(e){for(let t=0;t<this.sentinels.length;t++)if(n(e,this.sentinels[t]))return!1;return this.sentinels.push(e),!0}toString(){return`${JSON.stringify(this.sentinels)} @${this.cursor}`}}},(e,t,n)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.FailoverDetector=void 0;const r=(0,n(35).Debug)("FailoverDetector"),i="+switch-master";t.FailoverDetector=class{constructor(e,t){this.isDisconnected=!1,this.connector=e,this.sentinels=t}cleanup(){this.isDisconnected=!0;for(const e of this.sentinels)e.client.disconnect()}async subscribe(){r("Starting FailoverDetector");const e=[];for(const t of this.sentinels){const n=t.client.subscribe(i).catch(e=>{r("Failed to subscribe to failover messages on sentinel %s:%s (%s)",t.address.host||"127.0.0.1",t.address.port||26739,e.message)});e.push(n),t.client.on("message",e=>{this.isDisconnected||e!==i||this.disconnect()})}await Promise.all(e)}disconnect(){this.isDisconnected=!0,r("Failover detected, disconnecting"),this.connector.disconnect()}}},(e,t,n)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.readyHandler=t.errorHandler=t.closeHandler=t.connectHandler=void 0;const r=n(30),i=n(33),a=n(74),s=n(35),o=n(76),l=(0,s.Debug)("connection");function d(e){const t=new r.AbortError("Command aborted due to connection close");return t.command={name:e.name,args:e.args},t}t.connectHandler=function(e){return function(){e.setStatus("connect"),e.resetCommandQueue();let n=!1;const{connectionEpoch:r}=e;e.condition.auth&&e.auth(e.condition.auth,function(t){r===e.connectionEpoch&&t&&(-1!==t.message.indexOf("no password is set")?console.warn("[WARN] Redis server does not require a password, but a password was supplied."):-1!==t.message.indexOf("without any password configured for the default user")?console.warn("[WARN] This Redis server's `default` user does not require a password, but a password was supplied"):-1!==t.message.indexOf("wrong number of arguments for 'auth' command")?console.warn("[ERROR] The server returned \"wrong number of arguments for 'auth' command\". You are probably passing both username and password to Redis version 5 or below. You should only pass the 'password' option for Redis version 5 and under."):(n=!0,e.recoverFromFatalError(t,t)))}),e.condition.select&&e.select(e.condition.select).catch(t=>{e.silentEmit("error",t)}),e.options.enableReadyCheck||t.readyHandler(e)(),new o.default(e,{stringNumbers:e.options.stringNumbers}),e.options.enableReadyCheck&&e._readyCheck(function(i,a){r===e.connectionEpoch&&(i?n||e.recoverFromFatalError(new Error("Ready check failed: "+i.message),i):e.connector.check(a)?t.readyHandler(e)():e.disconnect(!0))})}},t.closeHandler=function(e){return function(){const n=e.status;if(e.setStatus("close"),e.commandQueue.length&&function(e){var t;let n=0;for(let r=0;r<e.length;){const i=null===(t=e.peekAt(r))||void 0===t?void 0:t.command,a=i.pipelineIndex;void 0!==a&&0!==a||(n=0),void 0===a||a===n++?r++:(e.remove(r,1),i.reject(d(i)))}}(e.commandQueue),e.offlineQueue.length&&function(e){var t;for(let n=0;n<e.length;){const r=null===(t=e.peekAt(n))||void 0===t?void 0:t.command;if("multi"===r.name)break;if("exec"===r.name){e.remove(n,1),r.reject(d(r));break}r.inTransaction?(e.remove(n,1),r.reject(d(r))):n++}}(e.offlineQueue),"ready"===n&&(e.prevCondition||(e.prevCondition=e.condition),e.commandQueue.length&&(e.prevCommandQueue=e.commandQueue)),e.manuallyClosing)return e.manuallyClosing=!1,l("skip reconnecting since the connection is manually closed."),t();if("function"!=typeof e.options.retryStrategy)return l("skip reconnecting because `retryStrategy` is not a function"),t();const r=e.options.retryStrategy(++e.retryAttempts);if("number"!=typeof r)return l("skip reconnecting because `retryStrategy` doesn't return a number"),t();l("reconnect in %sms",r),e.setStatus("reconnecting",r),e.reconnectTimeout=setTimeout(function(){e.reconnectTimeout=null,e.connect().catch(s.noop)},r);const{maxRetriesPerRequest:i}=e.options;if("number"==typeof i)if(i<0)l("maxRetriesPerRequest is negative, ignoring...");else{0===e.retryAttempts%(i+1)&&(l("reach maxRetriesPerRequest limitation, flushing command queue..."),e.flushQueue(new a.MaxRetriesPerRequestError(i)))}};function t(){e.setStatus("end"),e.flushQueue(new Error(s.CONNECTION_CLOSED_ERROR_MSG))}},t.errorHandler=function(e){return function(t){l("error: %s",t),e.silentEmit("error",t)}},t.readyHandler=function(e){return function(){if(e.setStatus("ready"),e.retryAttempts=0,e.options.monitor){e.call("monitor").then(()=>e.setStatus("monitoring"),t=>e.emit("error",t));const{sendCommand:t}=e;return e.sendCommand=function(n){return i.default.checkFlag("VALID_IN_MONITOR_MODE",n.name)?t.call(e,n):(n.reject(new Error("Connection is in monitoring mode, can't process commands.")),n.promise)},void e.once("close",function(){delete e.sendCommand})}const t=e.prevCondition?e.prevCondition.select:e.condition.select;if(e.options.connectionName&&(l("set the connection name [%s]",e.options.connectionName),e.client("setname",e.options.connectionName).catch(s.noop)),e.options.readOnly&&(l("set the connection to readonly mode"),e.readonly().catch(s.noop)),e.prevCondition){const n=e.prevCondition;if(e.prevCondition=null,n.subscriber&&e.options.autoResubscribe){e.condition.select!==t&&(l("connect to db [%d]",t),e.select(t));const r=n.subscriber.channels("subscribe");r.length&&(l("subscribe %d channels",r.length),e.subscribe(r));const i=n.subscriber.channels("psubscribe");i.length&&(l("psubscribe %d channels",i.length),e.psubscribe(i));const a=n.subscriber.channels("ssubscribe");a.length&&(l("ssubscribe %d channels",a.length),e.ssubscribe(a))}}if(e.prevCommandQueue)if(e.options.autoResendUnfulfilledCommands)for(l("resend %d unfulfilled commands",e.prevCommandQueue.length);e.prevCommandQueue.length>0;){const t=e.prevCommandQueue.shift();t.select!==e.condition.select&&"select"!==t.command.name&&e.select(t.select),e.sendCommand(t.command,t.stream)}else e.prevCommandQueue=null;if(e.offlineQueue.length){l("send %d commands in offline queue",e.offlineQueue.length);const t=e.offlineQueue;for(e.resetOfflineQueue();t.length>0;){const n=t.shift();n.select!==e.condition.select&&"select"!==n.command.name&&e.select(n.select),e.sendCommand(n.command,n.stream)}}e.condition.select!==t&&(l("connect to db [%d]",t),e.select(t))}}},(e,t,n)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.MaxRetriesPerRequestError=void 0;const r=n(75);t.MaxRetriesPerRequestError=r.default},(e,t,n)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0});const r=n(30);class i extends r.AbortError{constructor(e){super(`Reached the max retries per request limit (which is ${e}). Refer to "maxRetriesPerRequest" option for details.`),Error.captureStackTrace(this,this.constructor)}get name(){return this.constructor.name}}t.default=i},(e,t,n)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0});const r=n(33),i=n(35),a=n(77),s=n(81),o=(0,i.Debug)("dataHandler");t.default=class{constructor(e,t){this.redis=e;const n=new a({stringNumbers:t.stringNumbers,returnBuffers:!0,returnError:e=>{this.returnError(e)},returnFatalError:e=>{this.returnFatalError(e)},returnReply:e=>{this.returnReply(e)}});e.stream.prependListener("data",e=>{n.execute(e)}),e.stream.resume()}returnFatalError(e){e.message+=". Please report this.",this.redis.recoverFromFatalError(e,e,{offlineQueue:!1})}returnError(e){const t=this.shiftCommand(e);t&&(e.command={name:t.command.name,args:t.command.args},this.redis.handleReconnection(e,t))}returnReply(e){if(this.handleMonitorReply(e))return;if(this.handleSubscriberReply(e))return;const t=this.shiftCommand(e);t&&(r.default.checkFlag("ENTER_SUBSCRIBER_MODE",t.command.name)?(this.redis.condition.subscriber=new s.default,this.redis.condition.subscriber.add(t.command.name,e[1].toString()),d(t.command,e[2])||this.redis.commandQueue.unshift(t)):r.default.checkFlag("EXIT_SUBSCRIBER_MODE",t.command.name)?c(t.command,e[2])||this.redis.commandQueue.unshift(t):t.command.resolve(e))}handleSubscriberReply(e){if(!this.redis.condition.subscriber)return!1;const t=Array.isArray(e)?e[0].toString():null;switch(o('receive reply "%s" in subscriber mode',t),t){case"message":this.redis.listeners("message").length>0&&this.redis.emit("message",e[1].toString(),e[2]?e[2].toString():""),this.redis.emit("messageBuffer",e[1],e[2]);break;case"pmessage":{const t=e[1].toString();this.redis.listeners("pmessage").length>0&&this.redis.emit("pmessage",t,e[2].toString(),e[3].toString()),this.redis.emit("pmessageBuffer",t,e[2],e[3]);break}case"smessage":this.redis.listeners("smessage").length>0&&this.redis.emit("smessage",e[1].toString(),e[2]?e[2].toString():""),this.redis.emit("smessageBuffer",e[1],e[2]);break;case"ssubscribe":case"subscribe":case"psubscribe":{const n=e[1].toString();this.redis.condition.subscriber.add(t,n);const r=this.shiftCommand(e);if(!r)return;d(r.command,e[2])||this.redis.commandQueue.unshift(r);break}case"sunsubscribe":case"unsubscribe":case"punsubscribe":{const n=e[1]?e[1].toString():null;n&&this.redis.condition.subscriber.del(t,n);const r=e[2];0===Number(r)&&(this.redis.condition.subscriber=!1);const i=this.shiftCommand(e);if(!i)return;c(i.command,r)||this.redis.commandQueue.unshift(i);break}default:{const t=this.shiftCommand(e);if(!t)return;t.command.resolve(e)}}return!0}handleMonitorReply(e){if("monitoring"!==this.redis.status)return!1;const t=e.toString();if("OK"===t)return!1;const n=t.indexOf(" "),r=t.slice(0,n),i=t.indexOf('"'),a=t.slice(i+1,-1).split('" "').map(e=>e.replace(/\\"/g,'"')),s=t.slice(n+2,i-2).split(" ");return this.redis.emit("monitor",r,a,s[1],s[0]),!0}shiftCommand(e){const t=this.redis.commandQueue.shift();if(!t){const t=new Error("Command queue state error. If you can reproduce this, please report it."+(e instanceof Error?` Last error: ${e.message}`:` Last reply: ${e.toString()}`));return this.redis.emit("error",t),null}return t}};const l=new WeakMap;function d(e,t){let n=l.has(e)?l.get(e):e.args.length;return n-=1,n<=0?(e.resolve(t),l.delete(e),!0):(l.set(e,n),!1)}function c(e,t){let n=l.has(e)?l.get(e):e.args.length;return 0===n?0===Number(t)&&(l.delete(e),e.resolve(t),!0):(n-=1,n<=0?(e.resolve(t),!0):(l.set(e,n),!1))}},(e,t,n)=>{"use strict";e.exports=n(78)},(e,t,n)=>{"use strict";const r=Object(function(){var e=new Error("Cannot find module 'buffer'");throw e.code="MODULE_NOT_FOUND",e}()),i=new(0,n(79).StringDecoder),a=n(30),s=a.ReplyError,o=a.ParserError;var l=r.allocUnsafe(32768),d=0,c=null,u=0,p=0;function h(e){const t=e.offset,n=e.buffer,r=n.length-1;for(var i=t;i<r;)if(13===n[i++])return e.offset=i+1,!0===e.optionReturnBuffers?e.buffer.slice(t,i-1):e.buffer.toString("utf8",t,i-1)}function y(e){const t=e.buffer.length-1;for(var n=e.offset,r=0;n<t;){const t=e.buffer[n++];if(13===t)return e.offset=n+1,r;r=10*r+(t-48)}}function m(e,t,n){e.arrayCache.push(t),e.arrayPos.push(n)}function f(e){const t=e.arrayCache.pop();var n=e.arrayPos.pop();if(e.arrayCache.length){const r=f(e);if(void 0===r)return void m(e,t,n);t[n++]=r}return b(e,t,n)}function b(e,t,n){const r=e.buffer.length;for(;n<t.length;){const i=e.offset;if(e.offset>=r)return void m(e,t,n);const a=g(e,e.buffer[e.offset++]);if(void 0===a)return e.arrayCache.length||e.bufferCache.length||(e.offset=i),void m(e,t,n);t[n]=a,n++}return t}function g(e,t){switch(t){case 36:return function(e){const t=y(e);if(void 0===t)return;if(t<0)return null;const n=e.offset+t;if(n+2>e.buffer.length)return e.bigStrSize=n+2,e.totalChunkSize=e.buffer.length,void e.bufferCache.push(e.buffer);const r=e.offset;return e.offset=n+2,!0===e.optionReturnBuffers?e.buffer.slice(r,n):e.buffer.toString("utf8",r,n)}(e);case 43:return h(e);case 42:return function(e){const t=y(e);if(void 0===t)return;return t<0?null:b(e,new Array(t),0)}(e);case 58:return function(e){return!0===e.optionStringNumbers?function(e){const t=e.buffer.length-1;var n=e.offset,r=0,i="";for(45===e.buffer[n]&&(i+="-",n++);n<t;){var a=e.buffer[n++];if(13===a)return e.offset=n+1,0!==r&&(i+=r),i;r>429496728?(i+=10*r+(a-48),r=0):48===a&&0===r?i+=0:r=10*r+(a-48)}}(e):function(e){const t=e.buffer.length-1;var n=e.offset,r=0,i=1;for(45===e.buffer[n]&&(i=-1,n++);n<t;){const t=e.buffer[n++];if(13===t)return e.offset=n+1,i*r;r=10*r+(t-48)}}(e)}(e);case 45:return function(e){var t=h(e);if(void 0!==t)return!0===e.optionReturnBuffers&&(t=t.toString()),new s(t)}(e);default:return function(e,t){const n=new o("Protocol error, got "+JSON.stringify(String.fromCharCode(t))+" as reply type byte",JSON.stringify(e.buffer),e.offset);e.buffer=null,e.returnFatalError(n)}(e,t)}}function v(){if(l.length>51200)if(1===u||p>2*u){const e=Math.floor(l.length/10),t=e<d?d:e;d=0,l=l.slice(t,l.length)}else p++,u--;else clearInterval(c),u=0,p=0,c=null}function K(e){const t=e.bufferCache,n=e.offset,i=e.bigStrSize-n-2;var a=t.length,s=e.bigStrSize-e.totalChunkSize;if(e.offset=s,s<=2){if(2===a)return t[0].slice(n,t[0].length+s-2);a--,s=t[t.length-2].length+s}!function(e){if(l.length<e+d){const t=e>78643200?2:3;d>116391936&&(d=52428800),l=r.allocUnsafe(e*t+d),d=0,u++,null===c&&(c=setInterval(v,50))}}(i);const o=d;t[0].copy(l,o,n,t[0].length),d+=t[0].length-n;for(var p=1;p<a-1;p++)t[p].copy(l,d),d+=t[p].length;return t[p].copy(l,d,0,s-2),d+=s-2,l.slice(o,d)}e.exports=class{constructor(e){if(!e)throw new TypeError("Options are mandatory.");if("function"!=typeof e.returnError||"function"!=typeof e.returnReply)throw new TypeError("The returnReply and returnError options have to be functions.");this.setReturnBuffers(!!e.returnBuffers),this.setStringNumbers(!!e.stringNumbers),this.returnError=e.returnError,this.returnFatalError=e.returnFatalError||e.returnError,this.returnReply=e.returnReply,this.reset()}reset(){this.offset=0,this.buffer=null,this.bigStrSize=0,this.totalChunkSize=0,this.bufferCache=[],this.arrayCache=[],this.arrayPos=[]}setReturnBuffers(e){if("boolean"!=typeof e)throw new TypeError("The returnBuffers argument has to be a boolean");this.optionReturnBuffers=e}setStringNumbers(e){if("boolean"!=typeof e)throw new TypeError("The stringNumbers argument has to be a boolean");this.optionStringNumbers=e}execute(e){if(null===this.buffer)this.buffer=e,this.offset=0;else if(0===this.bigStrSize){const t=this.buffer.length,n=t-this.offset,i=r.allocUnsafe(n+e.length);if(this.buffer.copy(i,0,this.offset,t),e.copy(i,n,0,e.length),this.buffer=i,this.offset=0,this.arrayCache.length){const e=f(this);if(void 0===e)return;this.returnReply(e)}}else{if(!(this.totalChunkSize+e.length>=this.bigStrSize))return this.bufferCache.push(e),void(this.totalChunkSize+=e.length);this.bufferCache.push(e);var t=this.optionReturnBuffers?K(this):function(e){const t=e.bufferCache,n=e.offset;var r=t.length,a=e.bigStrSize-e.totalChunkSize;if(e.offset=a,a<=2){if(2===r)return t[0].toString("utf8",n,t[0].length+a-2);r--,a=t[t.length-2].length+a}for(var s=i.write(t[0].slice(n)),o=1;o<r-1;o++)s+=i.write(t[o]);return s+i.end(t[o].slice(0,a-2))}(this);if(this.bigStrSize=0,this.bufferCache=[],this.buffer=e,this.arrayCache.length&&(this.arrayCache[0][this.arrayPos[0]++]=t,void 0===(t=f(this))))return;this.returnReply(t)}for(;this.offset<this.buffer.length;){const e=this.offset,t=this.buffer[this.offset++],n=g(this,t);if(void 0===n)return void(this.arrayCache.length||this.bufferCache.length||(this.offset=e));45===t?this.returnError(n):this.returnReply(n)}this.buffer=null}}},(e,t,n)=>{"use strict";var r=n(80).Buffer,i=r.isEncoding||function(e){switch((e=""+e)&&e.toLowerCase()){case"hex":case"utf8":case"utf-8":case"ascii":case"binary":case"base64":case"ucs2":case"ucs-2":case"utf16le":case"utf-16le":case"raw":return!0;default:return!1}};function a(e){var t;switch(this.encoding=function(e){var t=function(e){if(!e)return"utf8";for(var t;;)switch(e){case"utf8":case"utf-8":return"utf8";case"ucs2":case"ucs-2":case"utf16le":case"utf-16le":return"utf16le";case"latin1":case"binary":return"latin1";case"base64":case"ascii":case"hex":return e;default:if(t)return;e=(""+e).toLowerCase(),t=!0}}(e);if("string"!=typeof t&&(r.isEncoding===i||!i(e)))throw new Error("Unknown encoding: "+e);return t||e}(e),this.encoding){case"utf16le":this.text=l,this.end=d,t=4;break;case"utf8":this.fillLast=o,t=4;break;case"base64":this.text=c,this.end=u,t=3;break;default:return this.write=p,void(this.end=h)}this.lastNeed=0,this.lastTotal=0,this.lastChar=r.allocUnsafe(t)}function s(e){return e<=127?0:e>>5==6?2:e>>4==14?3:e>>3==30?4:e>>6==2?-1:-2}function o(e){var t=this.lastTotal-this.lastNeed,n=function(e,t){if(128!=(192&t[0]))return e.lastNeed=0,"";if(e.lastNeed>1&&t.length>1){if(128!=(192&t[1]))return e.lastNeed=1,"";if(e.lastNeed>2&&t.length>2&&128!=(192&t[2]))return e.lastNeed=2,""}}(this,e);return void 0!==n?n:this.lastNeed<=e.length?(e.copy(this.lastChar,t,0,this.lastNeed),this.lastChar.toString(this.encoding,0,this.lastTotal)):(e.copy(this.lastChar,t,0,e.length),void(this.lastNeed-=e.length))}function l(e,t){if((e.length-t)%2==0){var n=e.toString("utf16le",t);if(n){var r=n.charCodeAt(n.length-1);if(r>=55296&&r<=56319)return this.lastNeed=2,this.lastTotal=4,this.lastChar[0]=e[e.length-2],this.lastChar[1]=e[e.length-1],n.slice(0,-1)}return n}return this.lastNeed=1,this.lastTotal=2,this.lastChar[0]=e[e.length-1],e.toString("utf16le",t,e.length-1)}function d(e){var t=e&&e.length?this.write(e):"";if(this.lastNeed){var n=this.lastTotal-this.lastNeed;return t+this.lastChar.toString("utf16le",0,n)}return t}function c(e,t){var n=(e.length-t)%3;return 0===n?e.toString("base64",t):(this.lastNeed=3-n,this.lastTotal=3,1===n?this.lastChar[0]=e[e.length-1]:(this.lastChar[0]=e[e.length-2],this.lastChar[1]=e[e.length-1]),e.toString("base64",t,e.length-n))}function u(e){var t=e&&e.length?this.write(e):"";return this.lastNeed?t+this.lastChar.toString("base64",0,3-this.lastNeed):t}function p(e){return e.toString(this.encoding)}function h(e){return e&&e.length?this.write(e):""}t.StringDecoder=a,a.prototype.write=function(e){if(0===e.length)return"";var t,n;if(this.lastNeed){if(void 0===(t=this.fillLast(e)))return"";n=this.lastNeed,this.lastNeed=0}else n=0;return n<e.length?t?t+this.text(e,n):this.text(e,n):t||""},a.prototype.end=function(e){var t=e&&e.length?this.write(e):"";return this.lastNeed?t+"":t},a.prototype.text=function(e,t){var n=function(e,t,n){var r=t.length-1;if(r<n)return 0;var i=s(t[r]);if(i>=0)return i>0&&(e.lastNeed=i-1),i;if(--r<n||-2===i)return 0;if(i=s(t[r]),i>=0)return i>0&&(e.lastNeed=i-2),i;if(--r<n||-2===i)return 0;if(i=s(t[r]),i>=0)return i>0&&(2===i?i=0:e.lastNeed=i-3),i;return 0}(this,e,t);if(!this.lastNeed)return e.toString("utf8",t);this.lastTotal=n;var r=e.length-(n-this.lastNeed);return e.copy(this.lastChar,0,r),e.toString("utf8",t,r)},a.prototype.fillLast=function(e){if(this.lastNeed<=e.length)return e.copy(this.lastChar,this.lastTotal-this.lastNeed,0,this.lastNeed),this.lastChar.toString(this.encoding,0,this.lastTotal);e.copy(this.lastChar,this.lastTotal-this.lastNeed,0,e.length),this.lastNeed-=e.length}},(e,t,n)=>{var r=n(Object(function(){var e=new Error("Cannot find module 'buffer'");throw e.code="MODULE_NOT_FOUND",e}())),i=r.Buffer;function a(e,t){for(var n in e)t[n]=e[n]}function s(e,t,n){return i(e,t,n)}i.from&&i.alloc&&i.allocUnsafe&&i.allocUnsafeSlow?e.exports=r:(a(r,t),t.Buffer=s),s.prototype=Object.create(i.prototype),a(i,s),s.from=function(e,t,n){if("number"==typeof e)throw new TypeError("Argument must not be a number");return i(e,t,n)},s.alloc=function(e,t,n){if("number"!=typeof e)throw new TypeError("Argument must be a number");var r=i(e);return void 0!==t?"string"==typeof n?r.fill(t,n):r.fill(t):r.fill(0),r},s.allocUnsafe=function(e){if("number"!=typeof e)throw new TypeError("Argument must be a number");return i(e)},s.allocUnsafeSlow=function(e){if("number"!=typeof e)throw new TypeError("Argument must be a number");return r.SlowBuffer(e)}},(e,t)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0});function n(e){return"unsubscribe"===e?"subscribe":"punsubscribe"===e?"psubscribe":"sunsubscribe"===e?"ssubscribe":e}t.default=class{constructor(){this.set={subscribe:{},psubscribe:{},ssubscribe:{}}}add(e,t){this.set[n(e)][t]=!0}del(e,t){delete this.set[n(e)][t]}channels(e){return Object.keys(this.set[n(e)])}isEmpty(){return 0===this.channels("subscribe").length&&0===this.channels("psubscribe").length&&0===this.channels("ssubscribe").length}}},(e,t)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.DEFAULT_REDIS_OPTIONS=void 0,t.DEFAULT_REDIS_OPTIONS={port:6379,host:"localhost",family:4,connectTimeout:1e4,disconnectTimeout:2e3,retryStrategy:function(e){return Math.min(50*e,2e3)},keepAlive:0,noDelay:!0,connectionName:null,sentinels:null,name:null,role:"master",sentinelRetryStrategy:function(e){return Math.min(10*e,1e3)},sentinelReconnectStrategy:function(){return 6e4},natMap:null,enableTLSForSentinelMode:!1,updateSentinels:!0,failoverDetector:!1,username:null,password:null,db:0,enableOfflineQueue:!0,enableReadyCheck:!0,autoResubscribe:!0,autoResendUnfulfilledCommands:!0,lazyConnect:!1,keyPrefix:"",reconnectOnError:null,readOnly:!1,stringNumbers:!1,maxRetriesPerRequest:20,maxLoadingRetryTime:1e4,enableAutoPipelining:!1,autoPipeliningIgnoredCommands:[],sentinelMaxConnections:10}},(e,t,n)=>{"use strict";n.r(t),n.d(t,{Scripts:()=>l,raw2NextJobData:()=>d});var r=n(84),i=n(8),a=n(18),s=n(93);const o=new r.Packr({useRecords:!1,encodeUndefinedAsNil:!0}).pack;class l{constructor(e){this.queue=e,this.version=s.version;const t=this.queue.keys;this.moveToFinishedKeys=[t.wait,t.active,t.prioritized,t.events,t.stalled,t.limiter,t.delayed,t.paused,t.meta,t.pc,void 0,void 0,void 0,void 0]}execCommand(e,t,n){return e[`${t}:${this.version}`](n)}async isJobInList(e,t){const n=await this.queue.client;let r;return r=(0,a.isRedisVersionLowerThan)(this.queue.redisVersion,"6.0.6")?await this.execCommand(n,"isJobInList",[e,t]):await n.lpos(e,t),Number.isInteger(r)}addDelayedJobArgs(e,t,n){const r=this.queue.keys,i=[r.marker,r.meta,r.id,r.delayed,r.completed,r.events];return i.push(o(n),e.data,t),i}addDelayedJob(e,t,n,r){const i=this.addDelayedJobArgs(t,n,r);return this.execCommand(e,"addDelayedJob",i)}addPrioritizedJobArgs(e,t,n){const r=this.queue.keys,i=[r.marker,r.meta,r.id,r.prioritized,r.delayed,r.completed,r.active,r.events,r.pc];return i.push(o(n),e.data,t),i}addPrioritizedJob(e,t,n,r){const i=this.addPrioritizedJobArgs(t,n,r);return this.execCommand(e,"addPrioritizedJob",i)}addParentJobArgs(e,t,n){const r=this.queue.keys,i=[r.meta,r.id,r.delayed,r.completed,r.events];return i.push(o(n),e.data,t),i}addParentJob(e,t,n,r){const i=this.addParentJobArgs(t,n,r);return this.execCommand(e,"addParentJob",i)}addStandardJobArgs(e,t,n){const r=this.queue.keys,i=[r.wait,r.paused,r.meta,r.id,r.completed,r.delayed,r.active,r.events,r.marker];return i.push(o(n),e.data,t),i}addStandardJob(e,t,n,r){const i=this.addStandardJobArgs(t,n,r);return this.execCommand(e,"addStandardJob",i)}async addJob(e,t,n,r,i={}){const a=this.queue.keys,s=t.parent,l=[a[""],void 0!==r?r:"",t.name,t.timestamp,t.parentKey||null,i.waitChildrenKey||null,i.parentDependenciesKey||null,s,t.repeatJobKey,t.deduplicationId?`${a.de}:${t.deduplicationId}`:null];let d,c;if(n.repeat){const e=Object.assign({},n.repeat);e.startDate&&(e.startDate=+new Date(e.startDate)),e.endDate&&(e.endDate=+new Date(e.endDate)),d=o(Object.assign(Object.assign({},n),{repeat:e}))}else d=o(n);if(c=i.waitChildrenKey?await this.addParentJob(e,t,d,l):"number"==typeof n.delay&&n.delay>0?await this.addDelayedJob(e,t,d,l):n.priority?await this.addPrioritizedJob(e,t,d,l):await this.addStandardJob(e,t,d,l),c<0)throw this.finishedErrors({code:c,parentKey:i.parentKey,command:"addJob"});return c}pauseArgs(e){let t="wait",n="paused";e||(t="paused",n="wait");const r=[t,n,"meta","prioritized"].map(e=>this.queue.toKey(e));r.push(this.queue.keys.events,this.queue.keys.delayed,this.queue.keys.marker);const i=[e?"paused":"resumed"];return r.concat(i)}async pause(e){const t=await this.queue.client,n=this.pauseArgs(e);return this.execCommand(t,"pause",n)}addRepeatableJobArgs(e,t,n,r){const i=this.queue.keys,a=[i.repeat,i.delayed],s=[t,o(n),r,e,i[""]];return a.concat(s)}async addRepeatableJob(e,t,n,r){const i=await this.queue.client,a=this.addRepeatableJobArgs(e,t,n,r);return this.execCommand(i,"addRepeatableJob",a)}async addJobScheduler(e,t,n,r,i,a,s){const l=await this.queue.client,d=this.queue.keys,c=[d.repeat,d.delayed,d.wait,d.paused,d.meta,d.prioritized,d.marker,d.id,d.events,d.pc,d.active],u=[t,o(i),e,n,o(r),o(a),Date.now(),d[""],s?this.queue.toKey(s):""];return this.execCommand(l,"addJobScheduler",c.concat(u))}async updateRepeatableJobMillis(e,t,n,r){const i=[this.queue.keys.repeat,n,t,r];return this.execCommand(e,"updateRepeatableJobMillis",i)}async updateJobSchedulerNextMillis(e,t,n,r,i){const a=await this.queue.client,s=this.queue.keys,l=[s.repeat,s.delayed,s.wait,s.paused,s.meta,s.prioritized,s.marker,s.id,s.events,s.pc,i?this.queue.toKey(i):"",s.active],d=[t,e,n,o(r),Date.now(),s[""],i];return this.execCommand(a,"updateJobScheduler",l.concat(d))}removeRepeatableArgs(e,t,n){const r=this.queue.keys,i=[r.repeat,r.delayed,r.events],a=[e,this.getRepeatConcatOptions(t,n),n,r[""]];return i.concat(a)}getRepeatConcatOptions(e,t){return t&&t.split(":").length>2?t:e}async removeRepeatable(e,t,n){const r=await this.queue.client,i=this.removeRepeatableArgs(e,t,n);return this.execCommand(r,"removeRepeatable",i)}async removeJobScheduler(e){const t=await this.queue.client,n=this.queue.keys,r=[n.repeat,n.delayed,n.events],i=[e,n[""]];return this.execCommand(t,"removeJobScheduler",r.concat(i))}removeArgs(e,t){const n=[e,"repeat"].map(e=>this.queue.toKey(e)),r=[e,t?1:0,this.queue.toKey("")];return n.concat(r)}async remove(e,t){const n=await this.queue.client,r=this.removeArgs(e,t),i=await this.execCommand(n,"removeJob",r);if(i<0)throw this.finishedErrors({code:i,jobId:e,command:"removeJob"});return i}async removeUnprocessedChildren(e){const t=await this.queue.client,n=[this.queue.toKey(e),this.queue.keys.meta,this.queue.toKey(""),e];await this.execCommand(t,"removeUnprocessedChildren",n)}async extendLock(e,t,n,r){r=r||await this.queue.client;const i=[this.queue.toKey(e)+":lock",this.queue.keys.stalled,t,n,e];return this.execCommand(r,"extendLock",i)}async extendLocks(e,t,n){const r=await this.queue.client,i=[this.queue.keys.stalled,this.queue.toKey(""),o(t),o(e),n];return this.execCommand(r,"extendLocks",i)}async updateData(e,t){const n=await this.queue.client,r=[this.queue.toKey(e.id)],i=JSON.stringify(t),a=await this.execCommand(n,"updateData",r.concat([i]));if(a<0)throw this.finishedErrors({code:a,jobId:e.id,command:"updateData"})}async updateProgress(e,t){const n=await this.queue.client,r=[this.queue.toKey(e),this.queue.keys.events,this.queue.keys.meta],i=JSON.stringify(t),a=await this.execCommand(n,"updateProgress",r.concat([e,i]));if(a<0)throw this.finishedErrors({code:a,jobId:e,command:"updateProgress"})}async addLog(e,t,n){const r=await this.queue.client,i=[this.queue.toKey(e),this.queue.toKey(e)+":logs"],a=await this.execCommand(r,"addLog",i.concat([e,t,n||""]));if(a<0)throw this.finishedErrors({code:a,jobId:e,command:"addLog"});return a}moveToFinishedArgs(e,t,n,r,i,s,l,d=!0,c){var u,p,h,y,m,f,b;const g=this.queue.keys,v=this.queue.opts,K="completed"===i?v.removeOnComplete:v.removeOnFail,E=this.queue.toKey(`metrics:${i}`),S=this.moveToFinishedKeys;S[10]=g[i],S[11]=this.queue.toKey(null!==(u=e.id)&&void 0!==u?u:""),S[12]=E,S[13]=this.queue.keys.marker;const I=this.getKeepJobs(r,K),w=[e.id,l,n,void 0===t?"null":t,i,!d||this.queue.closing?0:1,g[""],o({token:s,name:v.name,keepJobs:I,limiter:v.limiter,lockDuration:v.lockDuration,attempts:e.opts.attempts,maxMetricsSize:(null===(p=v.metrics)||void 0===p?void 0:p.maxDataPoints)?null===(h=v.metrics)||void 0===h?void 0:h.maxDataPoints:"",fpof:!!(null===(y=e.opts)||void 0===y?void 0:y.failParentOnFailure),cpof:!!(null===(m=e.opts)||void 0===m?void 0:m.continueParentOnFailure),idof:!!(null===(f=e.opts)||void 0===f?void 0:f.ignoreDependencyOnFailure),rdof:!!(null===(b=e.opts)||void 0===b?void 0:b.removeDependencyOnFailure)}),c?o((0,a.objectToFlatArray)(c)):void 0];return S.concat(w)}getKeepJobs(e,t){return void 0===e?t||{count:e?0:-1}:"object"==typeof e?e:"number"==typeof e?{count:e}:{count:e?0:-1}}async moveToFinished(e,t){const n=await this.queue.client,r=await this.execCommand(n,"moveToFinished",t);if(r<0)throw this.finishedErrors({code:r,jobId:e,command:"moveToFinished",state:"active"});if(void 0!==r)return d(r)}drainArgs(e){const t=this.queue.keys,n=[t.wait,t.paused,t.delayed,t.prioritized,t.repeat],r=[t[""],e?"1":"0"];return n.concat(r)}async drain(e){const t=await this.queue.client,n=this.drainArgs(e);return this.execCommand(t,"drain",n)}removeChildDependencyArgs(e,t){const n=[this.queue.keys[""]],r=[this.queue.toKey(e),t];return n.concat(r)}async removeChildDependency(e,t){const n=await this.queue.client,r=this.removeChildDependencyArgs(e,t),i=await this.execCommand(n,"removeChildDependency",r);switch(i){case 0:return!0;case 1:return!1;default:throw this.finishedErrors({code:i,jobId:e,parentKey:t,command:"removeChildDependency"})}}getRangesArgs(e,t,n,r){const i=this.queue.keys,a=[t,n,r?"1":"0",...e.map(e=>"waiting"===e?"wait":e)];return[i[""]].concat(a)}async getRanges(e,t=0,n=1,r=!1){const i=await this.queue.client,a=this.getRangesArgs(e,t,n,r);return await this.execCommand(i,"getRanges",a)}getCountsArgs(e){const t=this.queue.keys,n=[...e.map(e=>"waiting"===e?"wait":e)];return[t[""]].concat(n)}async getCounts(e){const t=await this.queue.client,n=this.getCountsArgs(e);return await this.execCommand(t,"getCounts",n)}getCountsPerPriorityArgs(e){const t=e;return[this.queue.keys.wait,this.queue.keys.paused,this.queue.keys.meta,this.queue.keys.prioritized].concat(t)}async getCountsPerPriority(e){const t=await this.queue.client,n=this.getCountsPerPriorityArgs(e);return await this.execCommand(t,"getCountsPerPriority",n)}getDependencyCountsArgs(e,t){const n=t;return[`${e}:processed`,`${e}:dependencies`,`${e}:failed`,`${e}:unsuccessful`].map(e=>this.queue.toKey(e)).concat(n)}async getDependencyCounts(e,t){const n=await this.queue.client,r=this.getDependencyCountsArgs(e,t);return await this.execCommand(n,"getDependencyCounts",r)}moveToCompletedArgs(e,t,n,r,i=!1){const a=Date.now();return this.moveToFinishedArgs(e,t,"returnvalue",n,"completed",r,a,i)}moveToFailedArgs(e,t,n,r,i=!1,a){const s=Date.now();return this.moveToFinishedArgs(e,t,"failedReason",n,"failed",r,s,i,a)}async isFinished(e,t=!1){const n=await this.queue.client,r=["completed","failed",e].map(e=>this.queue.toKey(e));return this.execCommand(n,"isFinished",r.concat([e,t?"1":""]))}async getState(e){const t=await this.queue.client,n=["completed","failed","delayed","active","wait","paused","waiting-children","prioritized"].map(e=>this.queue.toKey(e));return(0,a.isRedisVersionLowerThan)(this.queue.redisVersion,"6.0.6")?this.execCommand(t,"getState",n.concat([e])):this.execCommand(t,"getStateV2",n.concat([e]))}async changeDelay(e,t){const n=await this.queue.client,r=this.changeDelayArgs(e,t),i=await this.execCommand(n,"changeDelay",r);if(i<0)throw this.finishedErrors({code:i,jobId:e,command:"changeDelay",state:"delayed"})}changeDelayArgs(e,t){const n=Date.now();return[this.queue.keys.delayed,this.queue.keys.meta,this.queue.keys.marker,this.queue.keys.events].concat([t,JSON.stringify(n),e,this.queue.toKey(e)])}async changePriority(e,t=0,n=!1){const r=await this.queue.client,i=this.changePriorityArgs(e,t,n),a=await this.execCommand(r,"changePriority",i);if(a<0)throw this.finishedErrors({code:a,jobId:e,command:"changePriority"})}changePriorityArgs(e,t=0,n=!1){return[this.queue.keys.wait,this.queue.keys.paused,this.queue.keys.meta,this.queue.keys.prioritized,this.queue.keys.active,this.queue.keys.pc,this.queue.keys.marker].concat([t,this.queue.toKey(""),e,n?1:0])}moveToDelayedArgs(e,t,n,r,i={}){const s=this.queue.keys;return[s.marker,s.active,s.prioritized,s.delayed,this.queue.toKey(e),s.events,s.meta,s.stalled].concat([this.queue.keys[""],t,e,n,r,i.skipAttempt?"1":"0",i.fieldsToUpdate?o((0,a.objectToFlatArray)(i.fieldsToUpdate)):void 0])}moveToWaitingChildrenArgs(e,t,n){const r=Date.now(),i=(0,a.getParentKey)(n.child);return["active","waiting-children",e,`${e}:dependencies`,`${e}:unsuccessful`,"stalled","failed","events"].map(e=>this.queue.toKey(e)).concat([t,null!=i?i:"",JSON.stringify(r),e,this.queue.toKey("")])}isMaxedArgs(){const e=this.queue.keys;return[e.meta,e.active]}async isMaxed(){const e=await this.queue.client,t=this.isMaxedArgs();return!!await this.execCommand(e,"isMaxed",t)}async moveToDelayed(e,t,n,r="0",i={}){const a=await this.queue.client,s=this.moveToDelayedArgs(e,t,r,n,i),o=await this.execCommand(a,"moveToDelayed",s);if(o<0)throw this.finishedErrors({code:o,jobId:e,command:"moveToDelayed",state:"active"})}async moveToWaitingChildren(e,t,n={}){const r=await this.queue.client,i=this.moveToWaitingChildrenArgs(e,t,n),a=await this.execCommand(r,"moveToWaitingChildren",i);switch(a){case 0:return!0;case 1:return!1;default:throw this.finishedErrors({code:a,jobId:e,command:"moveToWaitingChildren",state:"active"})}}getRateLimitTtlArgs(e){return[this.queue.keys.limiter].concat([null!=e?e:"0"])}async getRateLimitTtl(e){const t=await this.queue.client,n=this.getRateLimitTtlArgs(e);return this.execCommand(t,"getRateLimitTtl",n)}async cleanJobsInSet(e,t,n=0){const r=await this.queue.client;return this.execCommand(r,"cleanJobsInSet",[this.queue.toKey(e),this.queue.toKey("events"),this.queue.toKey("repeat"),this.queue.toKey(""),t,n,e])}getJobSchedulerArgs(e){return[this.queue.keys.repeat].concat([e])}async getJobScheduler(e){const t=await this.queue.client,n=this.getJobSchedulerArgs(e);return this.execCommand(t,"getJobScheduler",n)}retryJobArgs(e,t,n,r={}){const i=(t?"R":"L")+"PUSH";return[this.queue.keys.active,this.queue.keys.wait,this.queue.keys.paused,this.queue.toKey(e),this.queue.keys.meta,this.queue.keys.events,this.queue.keys.delayed,this.queue.keys.prioritized,this.queue.keys.pc,this.queue.keys.marker,this.queue.keys.stalled].concat([this.queue.toKey(""),Date.now(),i,e,n,r.fieldsToUpdate?o((0,a.objectToFlatArray)(r.fieldsToUpdate)):void 0])}async retryJob(e,t,n="0",r={}){const i=await this.queue.client,a=this.retryJobArgs(e,t,n,r),s=await this.execCommand(i,"retryJob",a);if(s<0)throw this.finishedErrors({code:s,jobId:e,command:"retryJob",state:"active"})}moveJobsToWaitArgs(e,t,n){const r=[t,n,e];return[this.queue.toKey(""),this.queue.keys.events,this.queue.toKey(e),this.queue.toKey("wait"),this.queue.toKey("paused"),this.queue.keys.meta,this.queue.keys.active,this.queue.keys.marker].concat(r)}async retryJobs(e="failed",t=1e3,n=(new Date).getTime()){const r=await this.queue.client,i=this.moveJobsToWaitArgs(e,t,n);return this.execCommand(r,"moveJobsToWait",i)}async promoteJobs(e=1e3){const t=await this.queue.client,n=this.moveJobsToWaitArgs("delayed",e,Number.MAX_VALUE);return this.execCommand(t,"moveJobsToWait",n)}async reprocessJob(e,t){const n=await this.queue.client,r=[this.queue.toKey(e.id),this.queue.keys.events,this.queue.toKey(t),this.queue.keys.wait,this.queue.keys.meta,this.queue.keys.paused,this.queue.keys.active,this.queue.keys.marker],i=[e.id,(e.opts.lifo?"R":"L")+"PUSH","failed"===t?"failedReason":"returnvalue",t],a=await this.execCommand(n,"reprocessJob",r.concat(i));if(1!==a)throw this.finishedErrors({code:a,jobId:e.id,command:"reprocessJob",state:t})}async moveToActive(e,t,n){const r=this.queue.opts,i=this.queue.keys,a=[i.wait,i.active,i.prioritized,i.events,i.stalled,i.limiter,i.delayed,i.paused,i.meta,i.pc,i.marker],s=[i[""],Date.now(),o({token:t,lockDuration:r.lockDuration,limiter:r.limiter,name:n})];return d(await this.execCommand(e,"moveToActive",a.concat(s)))}async promote(e){const t=await this.queue.client,n=[this.queue.keys.delayed,this.queue.keys.wait,this.queue.keys.paused,this.queue.keys.meta,this.queue.keys.prioritized,this.queue.keys.active,this.queue.keys.pc,this.queue.keys.events,this.queue.keys.marker],r=[this.queue.toKey(""),e],i=await this.execCommand(t,"promote",n.concat(r));if(i<0)throw this.finishedErrors({code:i,jobId:e,command:"promote",state:"delayed"})}moveStalledJobsToWaitArgs(){const e=this.queue.opts,t=[this.queue.keys.stalled,this.queue.keys.wait,this.queue.keys.active,this.queue.keys["stalled-check"],this.queue.keys.meta,this.queue.keys.paused,this.queue.keys.marker,this.queue.keys.events],n=[e.maxStalledCount,this.queue.toKey(""),Date.now(),e.stalledInterval];return t.concat(n)}async moveStalledJobsToWait(){const e=await this.queue.client,t=this.moveStalledJobsToWaitArgs();return this.execCommand(e,"moveStalledJobsToWait",t)}async moveJobFromActiveToWait(e,t="0"){const n=await this.queue.client,r=[this.queue.keys.active,this.queue.keys.wait,this.queue.keys.stalled,this.queue.keys.paused,this.queue.keys.meta,this.queue.keys.limiter,this.queue.keys.prioritized,this.queue.keys.marker,this.queue.keys.events],i=[e,t,this.queue.toKey(e)],a=await this.execCommand(n,"moveJobFromActiveToWait",r.concat(i));if(a<0)throw this.finishedErrors({code:a,jobId:e,command:"moveJobFromActiveToWait",state:"active"});return a}async obliterate(e){const t=await this.queue.client,n=[this.queue.keys.meta,this.queue.toKey("")],r=[e.count,e.force?"force":null],i=await this.execCommand(t,"obliterate",n.concat(r));if(i<0)switch(i){case-1:throw new Error("Cannot obliterate non-paused queue");case-2:throw new Error("Cannot obliterate queue with active jobs")}return i}async paginate(e,t){const n=await this.queue.client,r=[e],i=t.end>=0?t.end-t.start+1:1/0;let s,o,l,d="0",c=0,u=[],p=[];do{const e=[t.start+u.length,t.end,d,c,5];t.fetchJobs&&e.push(1),[d,c,s,o,l]=await this.execCommand(n,"paginate",r.concat(e)),u=u.concat(s),l&&l.length&&(p=p.concat(l.map(a.array2obj)))}while("0"!=d&&u.length<i);if(u.length&&Array.isArray(u[0])){const e=[];for(let t=0;t<u.length;t++){const[n,r]=u[t];try{e.push({id:n,v:JSON.parse(r)})}catch(t){e.push({id:n,err:t.message})}}return{cursor:d,items:e,total:o,jobs:p}}return{cursor:d,items:u.map(e=>({id:e})),total:o,jobs:p}}finishedErrors({code:e,jobId:t,parentKey:n,command:r,state:a}){switch(e){case i.ErrorCode.JobNotExist:return new Error(`Missing key for job ${t}. ${r}`);case i.ErrorCode.JobLockNotExist:return new Error(`Missing lock for job ${t}. ${r}`);case i.ErrorCode.JobNotInState:return new Error(`Job ${t} is not in the ${a} state. ${r}`);case i.ErrorCode.JobPendingChildren:return new Error(`Job ${t} has pending dependencies. ${r}`);case i.ErrorCode.ParentJobNotExist:return new Error(`Missing key for parent job ${n}. ${r}`);case i.ErrorCode.JobLockMismatch:return new Error(`Lock mismatch for job ${t}. Cmd ${r} from ${a}`);case i.ErrorCode.ParentJobCannotBeReplaced:return new Error(`The parent job ${n} cannot be replaced. ${r}`);case i.ErrorCode.JobBelongsToJobScheduler:return new Error(`Job ${t} belongs to a job scheduler and cannot be removed directly. ${r}`);case i.ErrorCode.JobFailedChildren:return new Error(`Job ${t} has failed children. ${r}`);default:return new Error(`Unknown code ${e} error for ${t}. ${r}`)}}}function d(e){if(e){const t=[null,e[1],e[2],e[3]];return e[0]&&(t[0]=(0,a.array2obj)(e[0])),t}return[]}},(e,t,n)=>{"use strict";n.r(t),n.d(t,{ALWAYS:()=>r.ALWAYS,C1:()=>i.C1,DECIMAL_FIT:()=>r.DECIMAL_FIT,DECIMAL_ROUND:()=>r.DECIMAL_ROUND,Decoder:()=>i.Decoder,Encoder:()=>r.Encoder,FLOAT32_OPTIONS:()=>i.FLOAT32_OPTIONS,NEVER:()=>r.NEVER,Packr:()=>r.Packr,RESERVE_START_SPACE:()=>r.RESERVE_START_SPACE,RESET_BUFFER_MODE:()=>r.RESET_BUFFER_MODE,REUSE_BUFFER_MODE:()=>r.REUSE_BUFFER_MODE,Unpackr:()=>i.Unpackr,addExtension:()=>r.addExtension,clearSource:()=>i.clearSource,decode:()=>i.decode,decodeIter:()=>a.decodeIter,encode:()=>r.encode,encodeIter:()=>a.encodeIter,isNativeAccelerationEnabled:()=>i.isNativeAccelerationEnabled,mapsAsObjects:()=>o,pack:()=>r.pack,roundFloat32:()=>i.roundFloat32,unpack:()=>i.unpack,unpackMultiple:()=>i.unpackMultiple,useRecords:()=>s});var r=n(85),i=n(86),a=n(87);const s=!1,o=!0},(e,t,n)=>{"use strict";n.r(t),n.d(t,{ALWAYS:()=>R,DECIMAL_FIT:()=>M,DECIMAL_ROUND:()=>P,Encoder:()=>D,FLOAT32_OPTIONS:()=>r.FLOAT32_OPTIONS,NEVER:()=>C,Packr:()=>K,RECORD_SYMBOL:()=>v,RESERVE_START_SPACE:()=>J,RESET_BUFFER_MODE:()=>L,REUSE_BUFFER_MODE:()=>N,addExtension:()=>k,encode:()=>O,pack:()=>A,setWriteStructSlots:()=>x});var r=n(86);let i,a,s;try{i=new TextEncoder}catch(e){}const o="undefined"!=typeof Buffer,l=o?function(e){return Buffer.allocUnsafeSlow(e)}:Uint8Array,d=o?Buffer:Uint8Array,c=o?4294967296:2144337920;let u,p,h,y,m,f=0,b=null;const g=/[\u0080-\uFFFF]/,v=Symbol("record-id");class K extends r.Unpackr{constructor(e){let t,n,o,K;super(e),this.offset=0;let E=d.prototype.utf8Write?function(e,t){return u.utf8Write(e,t,u.byteLength-t)}:!(!i||!i.encodeInto)&&function(e,t){return i.encodeInto(e,u.subarray(t)).written},S=this;e||(e={});let k=e&&e.sequential,x=e.structures||e.saveStructures,T=e.maxSharedStructures;if(null==T&&(T=x?32:0),T>8160)throw new Error("Maximum maxSharedStructure is 8160");e.structuredClone&&null==e.moreTypes&&(this.moreTypes=!0);let A=e.maxOwnStructures;null==A&&(A=x?32:64),this.structures||0==e.useRecords||(this.structures=[]);let O=T>32||A+T>64,D=T+64,C=T+A+64;if(C>8256)throw new Error("Maximum maxSharedStructure + maxOwnStructure is 8192");let R=[],P=0,M=0;this.pack=this.encode=function(e,r){if(u||(u=new l(8192),h=u.dataView||(u.dataView=new DataView(u.buffer,0,8192)),f=0),y=u.length-10,y-f<2048?(u=new l(u.length),h=u.dataView||(u.dataView=new DataView(u.buffer,0,u.length)),y=u.length-10,f=0):f=f+7&2147483640,t=f,r&J&&(f+=255&r),K=S.structuredClone?new Map:null,S.bundleStrings&&"string"!=typeof e?(b=[],b.size=1/0):b=null,o=S.structures,o){o.uninitialized&&(o=S._mergeStructures(S.getStructures()));let e=o.sharedLength||0;if(e>T)throw new Error("Shared structures is larger than maximum shared structures, try increasing maxSharedStructures to "+o.sharedLength);if(!o.transitions){o.transitions=Object.create(null);for(let t=0;t<e;t++){let e=o[t];if(!e)continue;let n,r=o.transitions;for(let t=0,i=e.length;t<i;t++){let i=e[t];n=r[i],n||(n=r[i]=Object.create(null)),r=n}r[v]=t+64}this.lastNamedStructuresLength=e}k||(o.nextId=e+64)}let i;n&&(n=!1);try{S.randomAccessStructure&&e&&e.constructor&&e.constructor===Object?Q(e):V(e);let n=b;if(b&&w(t,V,0),K&&K.idsToInsert){let e=K.idsToInsert.sort((e,t)=>e.offset>t.offset?1:-1),r=e.length,i=-1;for(;n&&r>0;){let a=e[--r].offset+t;a<n.stringsPosition+t&&-1===i&&(i=0),a>n.position+t?i>=0&&(i+=6):(i>=0&&(h.setUint32(n.position+t,h.getUint32(n.position+t)+i),i=-1),n=n.previous,r++)}i>=0&&n&&h.setUint32(n.position+t,h.getUint32(n.position+t)+i),f+=6*e.length,f>y&&B(f),S.offset=f;let a=function(e,t){let n,r=6*t.length,i=e.length-r;for(;n=t.pop();){let t=n.offset,a=n.id;e.copyWithin(t+r,t,i),r-=6;let s=t+r;e[s++]=214,e[s++]=105,e[s++]=a>>24,e[s++]=a>>16&255,e[s++]=a>>8&255,e[s++]=255&a,i=t}return e}(u.subarray(t,f),e);return K=null,a}return S.offset=f,r&N?(u.start=t,u.end=f,u):u.subarray(t,f)}catch(e){throw i=e,e}finally{if(o&&(_(),n&&S.saveStructures)){let n=o.sharedLength||0,a=u.subarray(t,f),s=j(o,S);if(!i)return!1===S.saveStructures(s,s.isCompatible)?S.pack(e,r):(S.lastNamedStructuresLength=n,u.length>1073741824&&(u=null),a)}u.length>1073741824&&(u=null),r&L&&(f=t)}};const _=()=>{M<10&&M++;let e=o.sharedLength||0;if(o.length>e&&!k&&(o.length=e),P>1e4)o.transitions=null,M=0,P=0,R.length>0&&(R=[]);else if(R.length>0&&!k){for(let e=0,t=R.length;e<t;e++)R[e][v]=0;R=[]}},F=e=>{var t=e.length;t<16?u[f++]=144|t:t<65536?(u[f++]=220,u[f++]=t>>8,u[f++]=255&t):(u[f++]=221,h.setUint32(f,t),f+=4);for(let n=0;n<t;n++)V(e[n])},V=e=>{f>y&&(u=B(f));var n,i=typeof e;if("string"===i){let r,i=e.length;if(b&&i>=4&&i<4096){if((b.size+=i)>21760){let e,n,r=(b[0]?3*b[0].length+b[1].length:0)+10;f+r>y&&(u=B(f+r)),b.position?(n=b,u[f]=200,f+=3,u[f++]=98,e=f-t,f+=4,w(t,V,0),h.setUint16(e+t-3,f-t-e)):(u[f++]=214,u[f++]=98,e=f-t,f+=4),b=["",""],b.previous=n,b.size=0,b.position=e}let n=g.test(e);return b[n?0:1]+=e,u[f++]=193,void V(n?-i:i)}r=i<32?1:i<256?2:i<65536?3:5;let a=3*i;if(f+a>y&&(u=B(f+a)),i<64||!E){let t,a,s,o=f+r;for(t=0;t<i;t++)a=e.charCodeAt(t),a<128?u[o++]=a:a<2048?(u[o++]=a>>6|192,u[o++]=63&a|128):55296==(64512&a)&&56320==(64512&(s=e.charCodeAt(t+1)))?(a=65536+((1023&a)<<10)+(1023&s),t++,u[o++]=a>>18|240,u[o++]=a>>12&63|128,u[o++]=a>>6&63|128,u[o++]=63&a|128):(u[o++]=a>>12|224,u[o++]=a>>6&63|128,u[o++]=63&a|128);n=o-f-r}else n=E(e,f+r);n<32?u[f++]=160|n:n<256?(r<2&&u.copyWithin(f+2,f+1,f+1+n),u[f++]=217,u[f++]=n):n<65536?(r<3&&u.copyWithin(f+3,f+2,f+2+n),u[f++]=218,u[f++]=n>>8,u[f++]=255&n):(r<5&&u.copyWithin(f+5,f+3,f+3+n),u[f++]=219,h.setUint32(f,n),f+=4),f+=n}else if("number"===i)if(e>>>0===e)e<32||e<128&&!1===this.useRecords||e<64&&!this.randomAccessStructure?u[f++]=e:e<256?(u[f++]=204,u[f++]=e):e<65536?(u[f++]=205,u[f++]=e>>8,u[f++]=255&e):(u[f++]=206,h.setUint32(f,e),f+=4);else if((e|0)===e)e>=-32?u[f++]=256+e:e>=-128?(u[f++]=208,u[f++]=e+256):e>=-32768?(u[f++]=209,h.setInt16(f,e),f+=2):(u[f++]=210,h.setInt32(f,e),f+=4);else{let t;if((t=this.useFloat32)>0&&e<4294967296&&e>=-2147483648){let n;if(u[f++]=202,h.setFloat32(f,e),t<4||((n=e*r.mult10[(127&u[f])<<1|u[f+1]>>7])|0)===n)return void(f+=4);f--}u[f++]=203,h.setFloat64(f,e),f+=8}else if("object"===i||"function"===i)if(e){if(K){let n=K.get(e);if(n){if(!n.id){let e=K.idsToInsert||(K.idsToInsert=[]);n.id=e.push(n)}return u[f++]=214,u[f++]=112,h.setUint32(f,n.id),void(f+=4)}K.set(e,{offset:f-t})}let r=e.constructor;if(r===Object)U(e);else if(r===Array)F(e);else if(r===Map)if(this.mapAsEmptyObject)u[f++]=128;else{(n=e.size)<16?u[f++]=128|n:n<65536?(u[f++]=222,u[f++]=n>>8,u[f++]=255&n):(u[f++]=223,h.setUint32(f,n),f+=4);for(let[t,n]of e)V(t),V(n)}else{for(let t=0,n=a.length;t<n;t++){if(e instanceof s[t]){let n=a[t];if(n.write){n.type&&(u[f++]=212,u[f++]=n.type,u[f++]=0);let t=n.write.call(this,e);return void(t===e?Array.isArray(e)?F(e):U(e):V(t))}let r,i=u,s=h,o=f;u=null;try{r=n.pack.call(this,e,e=>(u=i,i=null,f+=e,f>y&&B(f),{target:u,targetView:h,position:f-e}),V)}finally{i&&(u=i,h=s,f=o,y=u.length-10)}return void(r&&(r.length+f>y&&B(r.length+f),f=I(r,u,f,n.type)))}}if(Array.isArray(e))F(e);else{if(e.toJSON){const t=e.toJSON();if(t!==e)return V(t)}if("function"===i)return V(this.writeFunction&&this.writeFunction(e));U(e)}}}else u[f++]=192;else if("boolean"===i)u[f++]=e?195:194;else if("bigint"===i){if(e<0x8000000000000000&&e>=-0x8000000000000000)u[f++]=211,h.setBigInt64(f,e);else if(e<0x10000000000000000&&e>0)u[f++]=207,h.setBigUint64(f,e);else{if(!this.largeBigIntToFloat){if(this.largeBigIntToString)return V(e.toString());if((this.useBigIntExtension||this.moreTypes)&&e<BigInt(2)**BigInt(1023)&&e>-(BigInt(2)**BigInt(1023))){u[f++]=199,f++,u[f++]=66;let t,n=[];do{let r=e&BigInt(255);t=(r&BigInt(128))===(e<BigInt(0)?BigInt(128):BigInt(0)),n.push(r),e>>=BigInt(8)}while(e!==BigInt(0)&&e!==BigInt(-1)||!t);u[f-2]=n.length;for(let e=n.length;e>0;)u[f++]=Number(n[--e]);return}throw new RangeError(e+" was too large to fit in MessagePack 64-bit integer format, use useBigIntExtension, or set largeBigIntToFloat to convert to float-64, or set largeBigIntToString to convert to string")}u[f++]=203,h.setFloat64(f,Number(e))}f+=8}else{if("undefined"!==i)throw new Error("Unknown type: "+i);this.encodeUndefinedAsNil?u[f++]=192:(u[f++]=212,u[f++]=0,u[f++]=0)}},G=this.variableMapSize||this.coercibleKeyAsNumber||this.skipValues?e=>{let t;if(this.skipValues){t=[];for(let n in e)"function"==typeof e.hasOwnProperty&&!e.hasOwnProperty(n)||this.skipValues.includes(e[n])||t.push(n)}else t=Object.keys(e);let n,r=t.length;if(r<16?u[f++]=128|r:r<65536?(u[f++]=222,u[f++]=r>>8,u[f++]=255&r):(u[f++]=223,h.setUint32(f,r),f+=4),this.coercibleKeyAsNumber)for(let i=0;i<r;i++){n=t[i];let r=Number(n);V(isNaN(r)?n:r),V(e[n])}else for(let i=0;i<r;i++)V(n=t[i]),V(e[n])}:e=>{u[f++]=222;let n=f-t;f+=2;let r=0;for(let t in e)("function"!=typeof e.hasOwnProperty||e.hasOwnProperty(t))&&(V(t),V(e[t]),r++);if(r>65535)throw new Error('Object is too large to serialize with fast 16-bit map size, use the "variableMapSize" option to serialize this object');u[n+++t]=r>>8,u[n+t]=255&r},q=!1===this.useRecords?G:e.progressiveRecords&&!O?e=>{let n,r,i=o.transitions||(o.transitions=Object.create(null)),a=f++-t;for(let s in e)if("function"!=typeof e.hasOwnProperty||e.hasOwnProperty(s)){if(n=i[s],n)i=n;else{let l=Object.keys(e),d=i;i=o.transitions;let c=0;for(let e=0,t=l.length;e<t;e++){let t=l[e];n=i[t],n||(n=i[t]=Object.create(null),c++),i=n}a+t+1==f?(f--,W(i,l,c)):z(i,l,a,c),r=!0,i=d[s]}V(e[s])}if(!r){let n=i[v];n?u[a+t]=n:z(i,Object.keys(e),a,0)}}:e=>{let t,n=o.transitions||(o.transitions=Object.create(null)),r=0;for(let i in e)("function"!=typeof e.hasOwnProperty||e.hasOwnProperty(i))&&(t=n[i],t||(t=n[i]=Object.create(null),r++),n=t);let i=n[v];i?i>=96&&O?(u[f++]=96+(31&(i-=96)),u[f++]=i>>5):u[f++]=i:W(n,n.__keys__||Object.keys(e),r);for(let t in e)("function"!=typeof e.hasOwnProperty||e.hasOwnProperty(t))&&V(e[t])},Y="function"==typeof this.useRecords&&this.useRecords,U=Y?e=>{Y(e)?q(e):G(e)}:q,B=e=>{let n;if(e>16777216){if(e-t>c)throw new Error("Packed buffer would be larger than maximum buffer size");n=Math.min(c,4096*Math.round(Math.max((e-t)*(e>67108864?1.25:2),4194304)/4096))}else n=1+(Math.max(e-t<<2,u.length-1)>>12)<<12;let r=new l(n);return h=r.dataView||(r.dataView=new DataView(r.buffer,0,n)),e=Math.min(e,u.length),u.copy?u.copy(r,0,t,e):r.set(u.slice(t,e)),f-=t,t=0,y=r.length-10,u=r},W=(e,t,r)=>{let i=o.nextId;i||(i=64),i<D&&this.shouldShareStructure&&!this.shouldShareStructure(t)?(i=o.nextOwnId,i<C||(i=D),o.nextOwnId=i+1):(i>=C&&(i=D),o.nextId=i+1);let a=t.highByte=i>=96&&O?i-96>>5:-1;e[v]=i,e.__keys__=t,o[i-64]=t,i<D?(t.isShared=!0,o.sharedLength=i-63,n=!0,a>=0?(u[f++]=96+(31&i),u[f++]=a):u[f++]=i):(a>=0?(u[f++]=213,u[f++]=114,u[f++]=96+(31&i),u[f++]=a):(u[f++]=212,u[f++]=114,u[f++]=i),r&&(P+=M*r),R.length>=A&&(R.shift()[v]=0),R.push(e),V(t))},z=(e,n,r,i)=>{let a=u,s=f,o=y,d=t;u=p,f=0,t=0,u||(p=u=new l(8192)),y=u.length-10,W(e,n,i),p=u;let c=f;if(u=a,f=s,y=o,t=d,c>1){let e=f+c-1;e>y&&B(e);let n=r+t;u.copyWithin(n+c,n+1,f),u.set(p.slice(0,c),n),f=e}else u[r+t]=p[0]},Q=e=>{let r=m(e,u,t,f,o,B,(e,t,r)=>{if(r)return n=!0;f=t;let i=u;return V(e),_(),i!==u?{position:f,targetView:h,target:u}:f},this);if(0===r)return U(e);f=r}}useBuffer(e){u=e,u.dataView||(u.dataView=new DataView(u.buffer,u.byteOffset,u.byteLength)),f=0}set position(e){f=e}get position(){return f}clearSharedData(){this.structures&&(this.structures=[]),this.typedStructs&&(this.typedStructs=[])}}function E(e,t,n,r){let i=e.byteLength;if(i+1<256){var{target:a,position:s}=n(4+i);a[s++]=199,a[s++]=i+1}else if(i+1<65536){var{target:a,position:s}=n(5+i);a[s++]=200,a[s++]=i+1>>8,a[s++]=i+1&255}else{var{target:a,position:s,targetView:o}=n(7+i);a[s++]=201,o.setUint32(s,i+1),s+=4}a[s++]=116,a[s++]=t,e.buffer||(e=new Uint8Array(e)),a.set(new Uint8Array(e.buffer,e.byteOffset,e.byteLength),s)}function S(e,t){let n=e.byteLength;var r,i;if(n<256){var{target:r,position:i}=t(n+2);r[i++]=196,r[i++]=n}else if(n<65536){var{target:r,position:i}=t(n+3);r[i++]=197,r[i++]=n>>8,r[i++]=255&n}else{var{target:r,position:i,targetView:a}=t(n+5);r[i++]=198,a.setUint32(i,n),i+=4}r.set(e,i)}function I(e,t,n,r){let i=e.length;switch(i){case 1:t[n++]=212;break;case 2:t[n++]=213;break;case 4:t[n++]=214;break;case 8:t[n++]=215;break;case 16:t[n++]=216;break;default:i<256?(t[n++]=199,t[n++]=i):i<65536?(t[n++]=200,t[n++]=i>>8,t[n++]=255&i):(t[n++]=201,t[n++]=i>>24,t[n++]=i>>16&255,t[n++]=i>>8&255,t[n++]=255&i)}return t[n++]=r,t.set(e,n),n+=i}function w(e,t,n){if(b.length>0){h.setUint32(b.position+e,f+n-b.position-e),b.stringsPosition=f-e;let r=b;b=null,t(r[0]),t(r[1])}}function k(e){if(e.Class){if(!e.pack&&!e.write)throw new Error("Extension has no pack or write function");if(e.pack&&!e.type)throw new Error("Extension has no type (numeric code to identify the extension)");s.unshift(e.Class),a.unshift(e)}(0,r.addExtension)(e)}function j(e,t){return e.isCompatible=e=>{let n=!e||(t.lastNamedStructuresLength||0)===e.length;return n||t._mergeStructures(e),n},e}function x(e,t){m=e,j=t}s=[Date,Set,Error,RegExp,ArrayBuffer,Object.getPrototypeOf(Uint8Array.prototype).constructor,DataView,r.C1Type],a=[{pack(e,t,n){let r=e.getTime()/1e3;if((this.useTimestamp32||0===e.getMilliseconds())&&r>=0&&r<4294967296){let{target:e,targetView:n,position:i}=t(6);e[i++]=214,e[i++]=255,n.setUint32(i,r)}else if(r>0&&r<4294967296){let{target:n,targetView:i,position:a}=t(10);n[a++]=215,n[a++]=255,i.setUint32(a,4e6*e.getMilliseconds()+(r/1e3/4294967296|0)),i.setUint32(a+4,r)}else if(isNaN(r)){if(this.onInvalidDate)return t(0),n(this.onInvalidDate());let{target:e,targetView:r,position:i}=t(3);e[i++]=212,e[i++]=255,e[i++]=255}else{let{target:n,targetView:i,position:a}=t(15);n[a++]=199,n[a++]=12,n[a++]=255,i.setUint32(a,1e6*e.getMilliseconds()),i.setBigInt64(a+4,BigInt(Math.floor(r)))}}},{pack(e,t,n){if(this.setAsEmptyObject)return t(0),n({});let r=Array.from(e),{target:i,position:a}=t(this.moreTypes?3:0);this.moreTypes&&(i[a++]=212,i[a++]=115,i[a++]=0),n(r)}},{pack(e,t,n){let{target:r,position:i}=t(this.moreTypes?3:0);this.moreTypes&&(r[i++]=212,r[i++]=101,r[i++]=0),n([e.name,e.message,e.cause])}},{pack(e,t,n){let{target:r,position:i}=t(this.moreTypes?3:0);this.moreTypes&&(r[i++]=212,r[i++]=120,r[i++]=0),n([e.source,e.flags])}},{pack(e,t){this.moreTypes?E(e,16,t):S(o?Buffer.from(e):new Uint8Array(e),t)}},{pack(e,t){let n=e.constructor;n!==d&&this.moreTypes?E(e,r.typedArrays.indexOf(n.name),t):S(e,t)}},{pack(e,t){this.moreTypes?E(e,17,t):S(o?Buffer.from(e):new Uint8Array(e),t)}},{pack(e,t){let{target:n,position:r}=t(1);n[r]=193}}];let T=new K({useRecords:!1});const A=T.pack,O=T.pack,D=K,{NEVER:C,ALWAYS:R,DECIMAL_ROUND:P,DECIMAL_FIT:M}=r.FLOAT32_OPTIONS,N=512,L=1024,J=2048},(e,t,n)=>{"use strict";var r,i,a;n.r(t),n.d(t,{C1:()=>E,C1Type:()=>K,Decoder:()=>ce,FLOAT32_OPTIONS:()=>me,Unpackr:()=>x,addExtension:()=>le,checkedRead:()=>A,clearSource:()=>oe,decode:()=>ye,getPosition:()=>T,isNativeAccelerationEnabled:()=>F,loadStructures:()=>M,mult10:()=>de,read:()=>D,readString:()=>q,roundFloat32:()=>ge,setExtractor:()=>V,setReadStruct:()=>ve,typedArrays:()=>re,unpack:()=>pe,unpackMultiple:()=>he});try{r=new TextDecoder}catch(e){}var s=0;const o=[];var l,d,c,u,p,h=o,y=0,m={},f=0,b=0,g=[],v={useRecords:!1,mapsAsObjects:!0};class K{}const E=new K;E.name="MessagePack 0xC1";var S,I,w,k=!1,j=2;try{new Function("")}catch(e){j=1/0}class x{constructor(e){e&&(!1===e.useRecords&&void 0===e.mapsAsObjects&&(e.mapsAsObjects=!0),e.sequential&&!1!==e.trusted&&(e.trusted=!0,e.structures||0==e.useRecords||(e.structures=[],e.maxSharedStructures||(e.maxSharedStructures=0))),e.structures?e.structures.sharedLength=e.structures.length:e.getStructures&&((e.structures=[]).uninitialized=!0,e.structures.sharedLength=0),e.int64AsNumber&&(e.int64AsType="number")),Object.assign(this,e)}unpack(e,t){if(i)return se(()=>(oe(),this?this.unpack(e,t):x.prototype.unpack.call(v,e,t)));e.buffer||e.constructor!==ArrayBuffer||(e="undefined"!=typeof Buffer?Buffer.from(e):new Uint8Array(e)),"object"==typeof t?(a=t.end||e.length,s=t.start||0):(s=0,a=t>-1?t:e.length),y=0,b=0,d=null,h=o,c=null,i=e;try{p=e.dataView||(e.dataView=new DataView(e.buffer,e.byteOffset,e.byteLength))}catch(t){if(i=null,e instanceof Uint8Array)throw t;throw new Error("Source must be a Uint8Array or Buffer but was a "+(e&&"object"==typeof e?e.constructor.name:typeof e))}if(this instanceof x){if(m=this,this.structures)return l=this.structures,A(t);(!l||l.length>0)&&(l=[])}else m=v,(!l||l.length>0)&&(l=[]);return A(t)}unpackMultiple(e,t){let n,r=0;try{k=!0;let i=e.length,a=this?this.unpack(e,i):ue.unpack(e,i);if(!t){for(n=[a];s<i;)r=s,n.push(A());return n}if(!1===t(a,r,s))return;for(;s<i;)if(r=s,!1===t(A(),r,s))return}catch(e){throw e.lastPosition=r,e.values=n,e}finally{k=!1,oe()}}_mergeStructures(e,t){I&&(e=I.call(this,e)),e=e||[],Object.isFrozen(e)&&(e=e.map(e=>e.slice(0)));for(let t=0,n=e.length;t<n;t++){let n=e[t];n&&(n.isShared=!0,t>=32&&(n.highByte=t-32>>5))}e.sharedLength=e.length;for(let n in t||[])if(n>=0){let r=e[n],i=t[n];i&&(r&&((e.restoreStructures||(e.restoreStructures=[]))[n]=r),e[n]=i)}return this.structures=e}decode(e,t){return this.unpack(e,t)}}function T(){return s}function A(e){try{if(!m.trusted&&!k){let e=l.sharedLength||0;e<l.length&&(l.length=e)}let t;if(m.randomAccessStructure&&i[s]<64&&i[s]>=32&&S?(t=S(i,s,a,m),i=null,e&&e.lazy||!t||(t=t.toJSON()),s=a):t=D(),c&&(s=c.postBundlePosition,c=null),k&&(l.restoreStructures=null),s==a)l&&l.restoreStructures&&O(),l=null,i=null,u&&(u=null);else{if(s>a)throw new Error("Unexpected end of MessagePack data");if(!k){let e;try{e=JSON.stringify(t,(e,t)=>"bigint"==typeof t?`${t}n`:t).slice(0,100)}catch(t){e="(JSON view not available "+t+")"}throw new Error("Data read, but end of buffer not reached "+e)}}return t}catch(e){throw l&&l.restoreStructures&&O(),oe(),(e instanceof RangeError||e.message.startsWith("Unexpected end of buffer")||s>a)&&(e.incomplete=!0),e}}function O(){for(let e in l.restoreStructures)l[e]=l.restoreStructures[e];l.restoreStructures=null}function D(){let e=i[s++];if(e<160){if(e<128){if(e<64)return e;{let t=l[63&e]||m.getStructures&&M()[63&e];return t?(t.read||(t.read=R(t,63&e)),t.read()):e}}if(e<144){if(e-=128,m.mapsAsObjects){let t={};for(let n=0;n<e;n++){let e=X();"__proto__"===e&&(e="__proto_"),t[e]=D()}return t}{let t=new Map;for(let n=0;n<e;n++)t.set(D(),D());return t}}{e-=144;let t=new Array(e);for(let n=0;n<e;n++)t[n]=D();return m.freezeData?Object.freeze(t):t}}if(e<192){let t=e-160;if(b>=s)return d.slice(s-f,(s+=t)-f);if(0==b&&a<140){let e=t<16?z(t):W(t);if(null!=e)return e}return N(t)}{let t;switch(e){case 192:return null;case 193:return c?(t=D(),t>0?c[1].slice(c.position1,c.position1+=t):c[0].slice(c.position0,c.position0-=t)):E;case 194:return!1;case 195:return!0;case 196:if(t=i[s++],void 0===t)throw new Error("Unexpected end of buffer");return $(t);case 197:return t=p.getUint16(s),s+=2,$(t);case 198:return t=p.getUint32(s),s+=4,$(t);case 199:return Z(i[s++]);case 200:return t=p.getUint16(s),s+=2,Z(t);case 201:return t=p.getUint32(s),s+=4,Z(t);case 202:if(t=p.getFloat32(s),m.useFloat32>2){let e=de[(127&i[s])<<1|i[s+1]>>7];return s+=4,(e*t+(t>0?.5:-.5)|0)/e}return s+=4,t;case 203:return t=p.getFloat64(s),s+=8,t;case 204:return i[s++];case 205:return t=p.getUint16(s),s+=2,t;case 206:return t=p.getUint32(s),s+=4,t;case 207:return"number"===m.int64AsType?(t=4294967296*p.getUint32(s),t+=p.getUint32(s+4)):"string"===m.int64AsType?t=p.getBigUint64(s).toString():"auto"===m.int64AsType?(t=p.getBigUint64(s),t<=BigInt(2)<<BigInt(52)&&(t=Number(t))):t=p.getBigUint64(s),s+=8,t;case 208:return p.getInt8(s++);case 209:return t=p.getInt16(s),s+=2,t;case 210:return t=p.getInt32(s),s+=4,t;case 211:return"number"===m.int64AsType?(t=4294967296*p.getInt32(s),t+=p.getUint32(s+4)):"string"===m.int64AsType?t=p.getBigInt64(s).toString():"auto"===m.int64AsType?(t=p.getBigInt64(s),t>=BigInt(-2)<<BigInt(52)&&t<=BigInt(2)<<BigInt(52)&&(t=Number(t))):t=p.getBigInt64(s),s+=8,t;case 212:if(t=i[s++],114==t)return te(63&i[s++]);{let e=g[t];if(e)return e.read?(s++,e.read(D())):e.noBuffer?(s++,e()):e(i.subarray(s,++s));throw new Error("Unknown extension "+t)}case 213:return t=i[s],114==t?(s++,te(63&i[s++],i[s++])):Z(2);case 214:return Z(4);case 215:return Z(8);case 216:return Z(16);case 217:return t=i[s++],b>=s?d.slice(s-f,(s+=t)-f):L(t);case 218:return t=p.getUint16(s),b>=(s+=2)?d.slice(s-f,(s+=t)-f):J(t);case 219:return t=p.getUint32(s),b>=(s+=4)?d.slice(s-f,(s+=t)-f):_(t);case 220:return t=p.getUint16(s),s+=2,Y(t);case 221:return t=p.getUint32(s),s+=4,Y(t);case 222:return t=p.getUint16(s),s+=2,U(t);case 223:return t=p.getUint32(s),s+=4,U(t);default:if(e>=224)return e-256;if(void 0===e){let e=new Error("Unexpected end of MessagePack data");throw e.incomplete=!0,e}throw new Error("Unknown MessagePack token "+e)}}}const C=/^[a-zA-Z_$][a-zA-Z\d_$]*$/;function R(e,t){function n(){if(n.count++>j){let n=e.read=new Function("r","return function(){return "+(m.freezeData?"Object.freeze":"")+"({"+e.map(e=>"__proto__"===e?"__proto_:r()":C.test(e)?e+":r()":"["+JSON.stringify(e)+"]:r()").join(",")+"})}")(D);return 0===e.highByte&&(e.read=P(t,e.read)),n()}let r={};for(let t=0,n=e.length;t<n;t++){let n=e[t];"__proto__"===n&&(n="__proto_"),r[n]=D()}return m.freezeData?Object.freeze(r):r}return n.count=0,0===e.highByte?P(t,n):n}const P=(e,t)=>function(){let n=i[s++];if(0===n)return t();let r=e<32?-(e+(n<<5)):e+(n<<5),a=l[r]||M()[r];if(!a)throw new Error("Record id is not defined for "+r);return a.read||(a.read=R(a,e)),a.read()};function M(){let e=se(()=>(i=null,m.getStructures()));return l=m._mergeStructures(e,l)}var N=G,L=G,J=G,_=G;let F=!1;function V(e){function t(t){return function(n){let r=h[y++];if(null==r){if(c)return G(n);let l=i.byteOffset,d=e(s-t+l,a+l,i.buffer);if("string"==typeof d)r=d,h=o;else if(y=1,b=1,r=(h=d)[0],void 0===r)throw new Error("Unexpected end of buffer")}let l=r.length;return l<=n?(s+=n,r):(d=r,f=s,b=s+l,s+=n,r.slice(0,n))}}F=!0,N=t(1),L=t(2),J=t(3),_=t(5)}function G(e){let t;if(e<16&&(t=z(e)))return t;if(e>64&&r)return r.decode(i.subarray(s,s+=e));const n=s+e,a=[];for(t="";s<n;){const e=i[s++];if(128&e)if(192==(224&e)){const t=63&i[s++];a.push((31&e)<<6|t)}else if(224==(240&e)){const t=63&i[s++],n=63&i[s++];a.push((31&e)<<12|t<<6|n)}else if(240==(248&e)){let t=(7&e)<<18|(63&i[s++])<<12|(63&i[s++])<<6|63&i[s++];t>65535&&(t-=65536,a.push(t>>>10&1023|55296),t=56320|1023&t),a.push(t)}else a.push(e);else a.push(e);a.length>=4096&&(t+=B.apply(String,a),a.length=0)}return a.length>0&&(t+=B.apply(String,a)),t}function q(e,t,n){let r=i;i=e,s=t;try{return G(n)}finally{i=r}}function Y(e){let t=new Array(e);for(let n=0;n<e;n++)t[n]=D();return m.freezeData?Object.freeze(t):t}function U(e){if(m.mapsAsObjects){let t={};for(let n=0;n<e;n++){let e=X();"__proto__"===e&&(e="__proto_"),t[e]=D()}return t}{let t=new Map;for(let n=0;n<e;n++)t.set(D(),D());return t}}var B=String.fromCharCode;function W(e){let t=s,n=new Array(e);for(let r=0;r<e;r++){const e=i[s++];if((128&e)>0)return void(s=t);n[r]=e}return B.apply(String,n)}function z(e){if(e<4){if(e<2){if(0===e)return"";{let e=i[s++];return(128&e)>1?void(s-=1):B(e)}}{let t=i[s++],n=i[s++];if((128&t)>0||(128&n)>0)return void(s-=2);if(e<3)return B(t,n);let r=i[s++];return(128&r)>0?void(s-=3):B(t,n,r)}}{let t=i[s++],n=i[s++],r=i[s++],a=i[s++];if((128&t)>0||(128&n)>0||(128&r)>0||(128&a)>0)return void(s-=4);if(e<6){if(4===e)return B(t,n,r,a);{let e=i[s++];return(128&e)>0?void(s-=5):B(t,n,r,a,e)}}if(e<8){let o=i[s++],l=i[s++];if((128&o)>0||(128&l)>0)return void(s-=6);if(e<7)return B(t,n,r,a,o,l);let d=i[s++];return(128&d)>0?void(s-=7):B(t,n,r,a,o,l,d)}{let o=i[s++],l=i[s++],d=i[s++],c=i[s++];if((128&o)>0||(128&l)>0||(128&d)>0||(128&c)>0)return void(s-=8);if(e<10){if(8===e)return B(t,n,r,a,o,l,d,c);{let e=i[s++];return(128&e)>0?void(s-=9):B(t,n,r,a,o,l,d,c,e)}}if(e<12){let u=i[s++],p=i[s++];if((128&u)>0||(128&p)>0)return void(s-=10);if(e<11)return B(t,n,r,a,o,l,d,c,u,p);let h=i[s++];return(128&h)>0?void(s-=11):B(t,n,r,a,o,l,d,c,u,p,h)}{let u=i[s++],p=i[s++],h=i[s++],y=i[s++];if((128&u)>0||(128&p)>0||(128&h)>0||(128&y)>0)return void(s-=12);if(e<14){if(12===e)return B(t,n,r,a,o,l,d,c,u,p,h,y);{let e=i[s++];return(128&e)>0?void(s-=13):B(t,n,r,a,o,l,d,c,u,p,h,y,e)}}{let m=i[s++],f=i[s++];if((128&m)>0||(128&f)>0)return void(s-=14);if(e<15)return B(t,n,r,a,o,l,d,c,u,p,h,y,m,f);let b=i[s++];return(128&b)>0?void(s-=15):B(t,n,r,a,o,l,d,c,u,p,h,y,m,f,b)}}}}}function Q(){let e,t=i[s++];if(t<192)e=t-160;else switch(t){case 217:e=i[s++];break;case 218:e=p.getUint16(s),s+=2;break;case 219:e=p.getUint32(s),s+=4;break;default:throw new Error("Expected string")}return G(e)}function $(e){return m.copyBuffers?Uint8Array.prototype.slice.call(i,s,s+=e):i.subarray(s,s+=e)}function Z(e){let t=i[s++];if(g[t]){let n;return g[t](i.subarray(s,n=s+=e),e=>{s=e;try{return D()}finally{s=n}})}throw new Error("Unknown extension type "+t)}var H=new Array(4096);function X(){let e=i[s++];if(!(e>=160&&e<192))return s--,ee(D());if(e-=160,b>=s)return d.slice(s-f,(s+=e)-f);if(!(0==b&&a<180))return N(e);let t,n=4095&(e<<5^(e>1?p.getUint16(s):e>0?i[s]:0)),r=H[n],o=s,l=s+e-3,c=0;if(r&&r.bytes==e){for(;o<l;){if(t=p.getUint32(o),t!=r[c++]){o=1879048192;break}o+=4}for(l+=3;o<l;)if(t=i[o++],t!=r[c++]){o=1879048192;break}if(o===l)return s=o,r.string;l-=3,o=s}for(r=[],H[n]=r,r.bytes=e;o<l;)t=p.getUint32(o),r.push(t),o+=4;for(l+=3;o<l;)t=i[o++],r.push(t);let u=e<16?z(e):W(e);return r.string=null!=u?u:N(e)}function ee(e){if("string"==typeof e)return e;if("number"==typeof e||"boolean"==typeof e||"bigint"==typeof e)return e.toString();if(null==e)return e+"";if(m.allowArraysInMapKeys&&Array.isArray(e)&&e.flat().every(e=>["string","number","boolean","bigint"].includes(typeof e)))return e.flat().toString();throw new Error("Invalid property type for record: "+typeof e)}const te=(e,t)=>{let n=D().map(ee),r=e;void 0!==t&&(e=e<32?-((t<<5)+e):(t<<5)+e,n.highByte=t);let i=l[e];return i&&(i.isShared||k)&&((l.restoreStructures||(l.restoreStructures=[]))[e]=i),l[e]=n,n.read=R(n,r),n.read()};g[0]=()=>{},g[0].noBuffer=!0,g[66]=e=>{let t=e.length,n=BigInt(128&e[0]?e[0]-256:e[0]);for(let r=1;r<t;r++)n<<=BigInt(8),n+=BigInt(e[r]);return n};let ne={Error,TypeError,ReferenceError};g[101]=()=>{let e=D();return(ne[e[0]]||Error)(e[1],{cause:e[2]})},g[105]=e=>{if(!1===m.structuredClone)throw new Error("Structured clone extension is disabled");let t=p.getUint32(s-4);u||(u=new Map);let n,r=i[s];n=r>=144&&r<160||220==r||221==r?[]:r>=128&&r<144||222==r||223==r?new Map:(r>=199&&r<=201||r>=212&&r<=216)&&115===i[s+1]?new Set:{};let a={target:n};u.set(t,a);let o=D();if(!a.used)return a.target=o;if(Object.assign(n,o),n instanceof Map)for(let[e,t]of o.entries())n.set(e,t);if(n instanceof Set)for(let e of Array.from(o))n.add(e);return n},g[112]=e=>{if(!1===m.structuredClone)throw new Error("Structured clone extension is disabled");let t=p.getUint32(s-4),n=u.get(t);return n.used=!0,n.target},g[115]=()=>new Set(D());const re=["Int8","Uint8","Uint8Clamped","Int16","Uint16","Int32","Uint32","Float32","Float64","BigInt64","BigUint64"].map(e=>e+"Array");let ie="object"==typeof globalThis?globalThis:window;g[116]=e=>{let t=e[0],n=Uint8Array.prototype.slice.call(e,1).buffer,r=re[t];if(!r){if(16===t)return n;if(17===t)return new DataView(n);throw new Error("Could not find typed array for code "+t)}return new ie[r](n)},g[120]=()=>{let e=D();return new RegExp(e[0],e[1])};const ae=[];function se(e){w&&w();let t=a,n=s,r=y,o=f,g=b,v=d,K=h,E=u,S=c,I=new Uint8Array(i.slice(0,a)),j=l,x=l.slice(0,l.length),T=m,A=k,O=e();return a=t,s=n,y=r,f=o,b=g,d=v,h=K,u=E,c=S,i=I,k=A,(l=j).splice(0,l.length,...x),m=T,p=new DataView(i.buffer,i.byteOffset,i.byteLength),O}function oe(){i=null,u=null,l=null}function le(e){e.unpack?g[e.type]=e.unpack:g[e.type]=e}g[98]=e=>{let t=(e[0]<<24)+(e[1]<<16)+(e[2]<<8)+e[3],n=s;return s+=t-e.length,c=ae,(c=[Q(),Q()]).position0=0,c.position1=0,c.postBundlePosition=s,s=n,D()},g[255]=e=>4==e.length?new Date(1e3*(16777216*e[0]+(e[1]<<16)+(e[2]<<8)+e[3])):8==e.length?new Date(((e[0]<<22)+(e[1]<<14)+(e[2]<<6)+(e[3]>>2))/1e6+1e3*(4294967296*(3&e[3])+16777216*e[4]+(e[5]<<16)+(e[6]<<8)+e[7])):12==e.length?new Date(((e[0]<<24)+(e[1]<<16)+(e[2]<<8)+e[3])/1e6+1e3*((128&e[4]?-281474976710656:0)+1099511627776*e[6]+4294967296*e[7]+16777216*e[8]+(e[9]<<16)+(e[10]<<8)+e[11])):new Date("invalid");const de=new Array(147);for(let e=0;e<256;e++)de[e]=+("1e"+Math.floor(45.15-.30103*e));const ce=x;var ue=new x({useRecords:!1});const pe=ue.unpack,he=ue.unpackMultiple,ye=ue.unpack,me={NEVER:0,ALWAYS:1,DECIMAL_ROUND:3,DECIMAL_FIT:4};let fe=new Float32Array(1),be=new Uint8Array(fe.buffer,0,4);function ge(e){fe[0]=e;let t=de[(127&be[3])<<1|be[2]>>7];return(t*e+(e>0?.5:-.5)|0)/t}function ve(e,t,n){S=e,I=t,w=n}},(e,t,n)=>{"use strict";n.r(t),n.d(t,{decodeIter:()=>h,encodeIter:()=>y,packIter:()=>c,unpackIter:()=>p});var r=n(88),i=n(90),a=n(91),s=n(85),o=n(86);function l(e){var t,n,r,i=2;for("undefined"!=typeof Symbol&&(n=Symbol.asyncIterator,r=Symbol.iterator);i--;){if(n&&null!=(t=e[n]))return t.call(e);if(r&&null!=(t=e[r]))return new d(t.call(e));n="@@asyncIterator",r="@@iterator"}throw new TypeError("Object is not async iterable")}function d(e){function t(e){if(Object(e)!==e)return Promise.reject(new TypeError(e+" is not an object."));var t=e.done;return Promise.resolve(e.value).then(function(e){return{value:e,done:t}})}return d=function(e){this.s=e,this.n=e.next},d.prototype={s:null,n:null,next:function(){return t(this.n.apply(this.s,arguments))},return:function(e){var n=this.s.return;return void 0===n?Promise.resolve({value:e,done:!0}):t(n.apply(this.s,arguments))},throw:function(e){var n=this.s.return;return void 0===n?Promise.reject(e):t(n.apply(this.s,arguments))}},new d(e)}function c(e,t={}){if(e&&"object"==typeof e){if("function"==typeof e[Symbol.iterator])return function*(e,t){const n=new s.Packr(t);for(const t of e)yield n.pack(t)}(e,t);if("function"==typeof e.then||"function"==typeof e[Symbol.asyncIterator])return function(e,t){return u.apply(this,arguments)}(e,t);throw new Error("first argument must be an Iterable, Async Iterable, Iterator, Async Iterator, or a Promise")}throw new Error("first argument must be an Iterable, Async Iterable, or a Promise for an Async Iterable")}function u(){return(u=(0,a.default)(function*(e,t){const n=new s.Packr(t);var r,a=!1,o=!1;try{for(var d,c=l(e);a=!(d=yield(0,i.default)(c.next())).done;a=!1){const e=d.value;yield n.pack(e)}}catch(e){o=!0,r=e}finally{try{a&&null!=c.return&&(yield(0,i.default)(c.return()))}finally{if(o)throw r}}})).apply(this,arguments)}function p(e,t={}){if(!e||"object"!=typeof e)throw new Error("first argument must be an Iterable, Async Iterable, Iterator, Async Iterator, or a promise");const n=new o.Unpackr(t);let s;const d=e=>{let t;s&&(e=Buffer.concat([s,e]),s=void 0);try{t=n.unpackMultiple(e)}catch(n){if(!n.incomplete)throw n;s=e.slice(n.lastPosition),t=n.values}return t};return"function"==typeof e[Symbol.iterator]?function*(){for(const t of e)yield*d(t)}():"function"==typeof e[Symbol.asyncIterator]?(c=(0,a.default)(function*(){var t,n=!1,a=!1;try{for(var s,o=l(e);n=!(s=yield(0,i.default)(o.next())).done;n=!1){const e=s.value;yield*(0,r.default)(l(d(e)),i.default)}}catch(e){a=!0,t=e}finally{try{n&&null!=o.return&&(yield(0,i.default)(o.return()))}finally{if(a)throw t}}}),function(){return c.apply(this,arguments)})():void 0;var c}const h=p,y=c},(e,t,n)=>{"use strict";n.r(t),n.d(t,{default:()=>i});var r=n(89);function i(e){var t={},n=!1;function i(t,i){return n=!0,i=new Promise(function(n){n(e[t](i))}),{done:!1,value:new r.default(i,1)}}return t["undefined"!=typeof Symbol&&Symbol.iterator||"@@iterator"]=function(){return this},t.next=function(e){return n?(n=!1,e):i("next",e)},"function"==typeof e.throw&&(t.throw=function(e){if(n)throw n=!1,e;return i("throw",e)}),"function"==typeof e.return&&(t.return=function(e){return n?(n=!1,e):i("return",e)}),t}},(e,t,n)=>{"use strict";function r(e,t){this.v=e,this.k=t}n.r(t),n.d(t,{default:()=>r})},(e,t,n)=>{"use strict";n.r(t),n.d(t,{default:()=>i});var r=n(89);function i(e){return new r.default(e,0)}},(e,t,n)=>{"use strict";n.r(t),n.d(t,{default:()=>i});var r=n(92);function i(e){return function(){return new r.default(e.apply(this,arguments))}}},(e,t,n)=>{"use strict";n.r(t),n.d(t,{default:()=>i});var r=n(89);function i(e){var t,n;function i(t,n){try{var s=e[t](n),o=s.value,l=o instanceof r.default;Promise.resolve(l?o.v:o).then(function(n){if(l){var r="return"===t?"return":"next";if(!o.k||n.done)return i(r,n);n=e[r](n).value}a(s.done?"return":"normal",n)},function(e){i("throw",e)})}catch(e){a("throw",e)}}function a(e,r){switch(e){case"return":t.resolve({value:r,done:!0});break;case"throw":t.reject(r);break;default:t.resolve({value:r,done:!1})}(t=t.next)?i(t.key,t.arg):n=null}this._invoke=function(e,r){return new Promise(function(a,s){var o={key:e,arg:r,resolve:a,reject:s,next:null};n?n=n.next=o:(t=n=o,i(e,r))})},"function"!=typeof e.return&&(this.return=void 0)}i.prototype["function"==typeof Symbol&&Symbol.asyncIterator||"@@asyncIterator"]=function(){return this},i.prototype.next=function(e){return this._invoke("next",e)},i.prototype.throw=function(e){return this._invoke("throw",e)},i.prototype.return=function(e){return this._invoke("return",e)}},(e,t,n)=>{"use strict";n.r(t),n.d(t,{version:()=>r});const r="5.56.1"},(e,t,n)=>{"use strict";const r=n(95),i=n(96),a=n(98),s=n(100),o=n(101),l=n(102),d=n(103),c=n(104),u=n(105),p=n(106),h=n(107),y=n(108),m=n(109),f=n(110),b=n(111),g=n(112),v=n(113),K=n(114),E=n(115),S=n(116),I=n(117),w=n(118),k=n(119),j=n(120),x=n(121),T=n(122),A=n(123),O=n(124),D=n(125),C=n(127),R=n(128),P=n(129),M=n(130),N=n(131),L=n(132),J=n(133),_=n(134),F=n(135),V=n(136),G=n(137),q=n(138);e.exports={parse:o,valid:l,clean:d,inc:c,diff:u,major:p,minor:h,patch:y,prerelease:m,compare:f,rcompare:b,compareLoose:g,compareBuild:v,sort:K,rsort:E,gt:S,lt:I,eq:w,neq:k,gte:j,lte:x,cmp:T,coerce:A,Comparator:O,Range:D,satisfies:C,toComparators:R,maxSatisfying:P,minSatisfying:M,minVersion:N,validRange:L,outside:J,gtr:_,ltr:F,intersects:V,simplifyRange:G,subset:q,SemVer:a,re:r.re,src:r.src,tokens:r.t,SEMVER_SPEC_VERSION:i.SEMVER_SPEC_VERSION,RELEASE_TYPES:i.RELEASE_TYPES,compareIdentifiers:s.compareIdentifiers,rcompareIdentifiers:s.rcompareIdentifiers}},(e,t,n)=>{"use strict";const{MAX_SAFE_COMPONENT_LENGTH:r,MAX_SAFE_BUILD_LENGTH:i,MAX_LENGTH:a}=n(96),s=n(97),o=(t=e.exports={}).re=[],l=t.safeRe=[],d=t.src=[],c=t.safeSrc=[],u=t.t={};let p=0;const h="[a-zA-Z0-9-]",y=[["\\s",1],["\\d",a],[h,i]],m=(e,t,n)=>{const r=(e=>{for(const[t,n]of y)e=e.split(`${t}*`).join(`${t}{0,${n}}`).split(`${t}+`).join(`${t}{1,${n}}`);return e})(t),i=p++;s(e,i,t),u[e]=i,d[i]=t,c[i]=r,o[i]=new RegExp(t,n?"g":void 0),l[i]=new RegExp(r,n?"g":void 0)};m("NUMERICIDENTIFIER","0|[1-9]\\d*"),m("NUMERICIDENTIFIERLOOSE","\\d+"),m("NONNUMERICIDENTIFIER",`\\d*[a-zA-Z-]${h}*`),m("MAINVERSION",`(${d[u.NUMERICIDENTIFIER]})\\.(${d[u.NUMERICIDENTIFIER]})\\.(${d[u.NUMERICIDENTIFIER]})`),m("MAINVERSIONLOOSE",`(${d[u.NUMERICIDENTIFIERLOOSE]})\\.(${d[u.NUMERICIDENTIFIERLOOSE]})\\.(${d[u.NUMERICIDENTIFIERLOOSE]})`),m("PRERELEASEIDENTIFIER",`(?:${d[u.NONNUMERICIDENTIFIER]}|${d[u.NUMERICIDENTIFIER]})`),m("PRERELEASEIDENTIFIERLOOSE",`(?:${d[u.NONNUMERICIDENTIFIER]}|${d[u.NUMERICIDENTIFIERLOOSE]})`),m("PRERELEASE",`(?:-(${d[u.PRERELEASEIDENTIFIER]}(?:\\.${d[u.PRERELEASEIDENTIFIER]})*))`),m("PRERELEASELOOSE",`(?:-?(${d[u.PRERELEASEIDENTIFIERLOOSE]}(?:\\.${d[u.PRERELEASEIDENTIFIERLOOSE]})*))`),m("BUILDIDENTIFIER",`${h}+`),m("BUILD",`(?:\\+(${d[u.BUILDIDENTIFIER]}(?:\\.${d[u.BUILDIDENTIFIER]})*))`),m("FULLPLAIN",`v?${d[u.MAINVERSION]}${d[u.PRERELEASE]}?${d[u.BUILD]}?`),m("FULL",`^${d[u.FULLPLAIN]}$`),m("LOOSEPLAIN",`[v=\\s]*${d[u.MAINVERSIONLOOSE]}${d[u.PRERELEASELOOSE]}?${d[u.BUILD]}?`),m("LOOSE",`^${d[u.LOOSEPLAIN]}$`),m("GTLT","((?:<|>)?=?)"),m("XRANGEIDENTIFIERLOOSE",`${d[u.NUMERICIDENTIFIERLOOSE]}|x|X|\\*`),m("XRANGEIDENTIFIER",`${d[u.NUMERICIDENTIFIER]}|x|X|\\*`),m("XRANGEPLAIN",`[v=\\s]*(${d[u.XRANGEIDENTIFIER]})(?:\\.(${d[u.XRANGEIDENTIFIER]})(?:\\.(${d[u.XRANGEIDENTIFIER]})(?:${d[u.PRERELEASE]})?${d[u.BUILD]}?)?)?`),m("XRANGEPLAINLOOSE",`[v=\\s]*(${d[u.XRANGEIDENTIFIERLOOSE]})(?:\\.(${d[u.XRANGEIDENTIFIERLOOSE]})(?:\\.(${d[u.XRANGEIDENTIFIERLOOSE]})(?:${d[u.PRERELEASELOOSE]})?${d[u.BUILD]}?)?)?`),m("XRANGE",`^${d[u.GTLT]}\\s*${d[u.XRANGEPLAIN]}$`),m("XRANGELOOSE",`^${d[u.GTLT]}\\s*${d[u.XRANGEPLAINLOOSE]}$`),m("COERCEPLAIN",`(^|[^\\d])(\\d{1,${r}})(?:\\.(\\d{1,${r}}))?(?:\\.(\\d{1,${r}}))?`),m("COERCE",`${d[u.COERCEPLAIN]}(?:$|[^\\d])`),m("COERCEFULL",d[u.COERCEPLAIN]+`(?:${d[u.PRERELEASE]})?`+`(?:${d[u.BUILD]})?(?:$|[^\\d])`),m("COERCERTL",d[u.COERCE],!0),m("COERCERTLFULL",d[u.COERCEFULL],!0),m("LONETILDE","(?:~>?)"),m("TILDETRIM",`(\\s*)${d[u.LONETILDE]}\\s+`,!0),t.tildeTrimReplace="$1~",m("TILDE",`^${d[u.LONETILDE]}${d[u.XRANGEPLAIN]}$`),m("TILDELOOSE",`^${d[u.LONETILDE]}${d[u.XRANGEPLAINLOOSE]}$`),m("LONECARET","(?:\\^)"),m("CARETTRIM",`(\\s*)${d[u.LONECARET]}\\s+`,!0),t.caretTrimReplace="$1^",m("CARET",`^${d[u.LONECARET]}${d[u.XRANGEPLAIN]}$`),m("CARETLOOSE",`^${d[u.LONECARET]}${d[u.XRANGEPLAINLOOSE]}$`),m("COMPARATORLOOSE",`^${d[u.GTLT]}\\s*(${d[u.LOOSEPLAIN]})$|^$`),m("COMPARATOR",`^${d[u.GTLT]}\\s*(${d[u.FULLPLAIN]})$|^$`),m("COMPARATORTRIM",`(\\s*)${d[u.GTLT]}\\s*(${d[u.LOOSEPLAIN]}|${d[u.XRANGEPLAIN]})`,!0),t.comparatorTrimReplace="$1$2$3",m("HYPHENRANGE",`^\\s*(${d[u.XRANGEPLAIN]})\\s+-\\s+(${d[u.XRANGEPLAIN]})\\s*$`),m("HYPHENRANGELOOSE",`^\\s*(${d[u.XRANGEPLAINLOOSE]})\\s+-\\s+(${d[u.XRANGEPLAINLOOSE]})\\s*$`),m("STAR","(<|>)?=?\\s*\\*"),m("GTE0","^\\s*>=\\s*0\\.0\\.0\\s*$"),m("GTE0PRE","^\\s*>=\\s*0\\.0\\.0-0\\s*$")},e=>{"use strict";const t=Number.MAX_SAFE_INTEGER||9007199254740991;e.exports={MAX_LENGTH:256,MAX_SAFE_COMPONENT_LENGTH:16,MAX_SAFE_BUILD_LENGTH:250,MAX_SAFE_INTEGER:t,RELEASE_TYPES:["major","premajor","minor","preminor","patch","prepatch","prerelease"],SEMVER_SPEC_VERSION:"2.0.0",FLAG_INCLUDE_PRERELEASE:1,FLAG_LOOSE:2}},e=>{"use strict";const t="object"==typeof process&&process.env&&process.env.NODE_DEBUG&&/\bsemver\b/i.test(process.env.NODE_DEBUG)?(...e)=>console.error("SEMVER",...e):()=>{};e.exports=t},(e,t,n)=>{"use strict";const r=n(97),{MAX_LENGTH:i,MAX_SAFE_INTEGER:a}=n(96),{safeRe:s,t:o}=n(95),l=n(99),{compareIdentifiers:d}=n(100);class c{constructor(e,t){if(t=l(t),e instanceof c){if(e.loose===!!t.loose&&e.includePrerelease===!!t.includePrerelease)return e;e=e.version}else if("string"!=typeof e)throw new TypeError(`Invalid version. Must be a string. Got type "${typeof e}".`);if(e.length>i)throw new TypeError(`version is longer than ${i} characters`);r("SemVer",e,t),this.options=t,this.loose=!!t.loose,this.includePrerelease=!!t.includePrerelease;const n=e.trim().match(t.loose?s[o.LOOSE]:s[o.FULL]);if(!n)throw new TypeError(`Invalid Version: ${e}`);if(this.raw=e,this.major=+n[1],this.minor=+n[2],this.patch=+n[3],this.major>a||this.major<0)throw new TypeError("Invalid major version");if(this.minor>a||this.minor<0)throw new TypeError("Invalid minor version");if(this.patch>a||this.patch<0)throw new TypeError("Invalid patch version");n[4]?this.prerelease=n[4].split(".").map(e=>{if(/^[0-9]+$/.test(e)){const t=+e;if(t>=0&&t<a)return t}return e}):this.prerelease=[],this.build=n[5]?n[5].split("."):[],this.format()}format(){return this.version=`${this.major}.${this.minor}.${this.patch}`,this.prerelease.length&&(this.version+=`-${this.prerelease.join(".")}`),this.version}toString(){return this.version}compare(e){if(r("SemVer.compare",this.version,this.options,e),!(e instanceof c)){if("string"==typeof e&&e===this.version)return 0;e=new c(e,this.options)}return e.version===this.version?0:this.compareMain(e)||this.comparePre(e)}compareMain(e){return e instanceof c||(e=new c(e,this.options)),d(this.major,e.major)||d(this.minor,e.minor)||d(this.patch,e.patch)}comparePre(e){if(e instanceof c||(e=new c(e,this.options)),this.prerelease.length&&!e.prerelease.length)return-1;if(!this.prerelease.length&&e.prerelease.length)return 1;if(!this.prerelease.length&&!e.prerelease.length)return 0;let t=0;do{const n=this.prerelease[t],i=e.prerelease[t];if(r("prerelease compare",t,n,i),void 0===n&&void 0===i)return 0;if(void 0===i)return 1;if(void 0===n)return-1;if(n!==i)return d(n,i)}while(++t)}compareBuild(e){e instanceof c||(e=new c(e,this.options));let t=0;do{const n=this.build[t],i=e.build[t];if(r("build compare",t,n,i),void 0===n&&void 0===i)return 0;if(void 0===i)return 1;if(void 0===n)return-1;if(n!==i)return d(n,i)}while(++t)}inc(e,t,n){if(e.startsWith("pre")){if(!t&&!1===n)throw new Error("invalid increment argument: identifier is empty");if(t){const e=`-${t}`.match(this.options.loose?s[o.PRERELEASELOOSE]:s[o.PRERELEASE]);if(!e||e[1]!==t)throw new Error(`invalid identifier: ${t}`)}}switch(e){case"premajor":this.prerelease.length=0,this.patch=0,this.minor=0,this.major++,this.inc("pre",t,n);break;case"preminor":this.prerelease.length=0,this.patch=0,this.minor++,this.inc("pre",t,n);break;case"prepatch":this.prerelease.length=0,this.inc("patch",t,n),this.inc("pre",t,n);break;case"prerelease":0===this.prerelease.length&&this.inc("patch",t,n),this.inc("pre",t,n);break;case"release":if(0===this.prerelease.length)throw new Error(`version ${this.raw} is not a prerelease`);this.prerelease.length=0;break;case"major":0===this.minor&&0===this.patch&&0!==this.prerelease.length||this.major++,this.minor=0,this.patch=0,this.prerelease=[];break;case"minor":0===this.patch&&0!==this.prerelease.length||this.minor++,this.patch=0,this.prerelease=[];break;case"patch":0===this.prerelease.length&&this.patch++,this.prerelease=[];break;case"pre":{const e=Number(n)?1:0;if(0===this.prerelease.length)this.prerelease=[e];else{let r=this.prerelease.length;for(;--r>=0;)"number"==typeof this.prerelease[r]&&(this.prerelease[r]++,r=-2);if(-1===r){if(t===this.prerelease.join(".")&&!1===n)throw new Error("invalid increment argument: identifier already exists");this.prerelease.push(e)}}if(t){let r=[t,e];!1===n&&(r=[t]),0===d(this.prerelease[0],t)?isNaN(this.prerelease[1])&&(this.prerelease=r):this.prerelease=r}break}default:throw new Error(`invalid increment argument: ${e}`)}return this.raw=this.format(),this.build.length&&(this.raw+=`+${this.build.join(".")}`),this}}e.exports=c},e=>{"use strict";const t=Object.freeze({loose:!0}),n=Object.freeze({});e.exports=e=>e?"object"!=typeof e?t:e:n},e=>{"use strict";const t=/^[0-9]+$/,n=(e,n)=>{const r=t.test(e),i=t.test(n);return r&&i&&(e=+e,n=+n),e===n?0:r&&!i?-1:i&&!r?1:e<n?-1:1};e.exports={compareIdentifiers:n,rcompareIdentifiers:(e,t)=>n(t,e)}},(e,t,n)=>{"use strict";const r=n(98);e.exports=(e,t,n=!1)=>{if(e instanceof r)return e;try{return new r(e,t)}catch(e){if(!n)return null;throw e}}},(e,t,n)=>{"use strict";const r=n(101);e.exports=(e,t)=>{const n=r(e,t);return n?n.version:null}},(e,t,n)=>{"use strict";const r=n(101);e.exports=(e,t)=>{const n=r(e.trim().replace(/^[=v]+/,""),t);return n?n.version:null}},(e,t,n)=>{"use strict";const r=n(98);e.exports=(e,t,n,i,a)=>{"string"==typeof n&&(a=i,i=n,n=void 0);try{return new r(e instanceof r?e.version:e,n).inc(t,i,a).version}catch(e){return null}}},(e,t,n)=>{"use strict";const r=n(101);e.exports=(e,t)=>{const n=r(e,null,!0),i=r(t,null,!0),a=n.compare(i);if(0===a)return null;const s=a>0,o=s?n:i,l=s?i:n,d=!!o.prerelease.length;if(!!l.prerelease.length&&!d){if(!l.patch&&!l.minor)return"major";if(0===l.compareMain(o))return l.minor&&!l.patch?"minor":"patch"}const c=d?"pre":"";return n.major!==i.major?c+"major":n.minor!==i.minor?c+"minor":n.patch!==i.patch?c+"patch":"prerelease"}},(e,t,n)=>{"use strict";const r=n(98);e.exports=(e,t)=>new r(e,t).major},(e,t,n)=>{"use strict";const r=n(98);e.exports=(e,t)=>new r(e,t).minor},(e,t,n)=>{"use strict";const r=n(98);e.exports=(e,t)=>new r(e,t).patch},(e,t,n)=>{"use strict";const r=n(101);e.exports=(e,t)=>{const n=r(e,t);return n&&n.prerelease.length?n.prerelease:null}},(e,t,n)=>{"use strict";const r=n(98);e.exports=(e,t,n)=>new r(e,n).compare(new r(t,n))},(e,t,n)=>{"use strict";const r=n(110);e.exports=(e,t,n)=>r(t,e,n)},(e,t,n)=>{"use strict";const r=n(110);e.exports=(e,t)=>r(e,t,!0)},(e,t,n)=>{"use strict";const r=n(98);e.exports=(e,t,n)=>{const i=new r(e,n),a=new r(t,n);return i.compare(a)||i.compareBuild(a)}},(e,t,n)=>{"use strict";const r=n(113);e.exports=(e,t)=>e.sort((e,n)=>r(e,n,t))},(e,t,n)=>{"use strict";const r=n(113);e.exports=(e,t)=>e.sort((e,n)=>r(n,e,t))},(e,t,n)=>{"use strict";const r=n(110);e.exports=(e,t,n)=>r(e,t,n)>0},(e,t,n)=>{"use strict";const r=n(110);e.exports=(e,t,n)=>r(e,t,n)<0},(e,t,n)=>{"use strict";const r=n(110);e.exports=(e,t,n)=>0===r(e,t,n)},(e,t,n)=>{"use strict";const r=n(110);e.exports=(e,t,n)=>0!==r(e,t,n)},(e,t,n)=>{"use strict";const r=n(110);e.exports=(e,t,n)=>r(e,t,n)>=0},(e,t,n)=>{"use strict";const r=n(110);e.exports=(e,t,n)=>r(e,t,n)<=0},(e,t,n)=>{"use strict";const r=n(118),i=n(119),a=n(116),s=n(120),o=n(117),l=n(121);e.exports=(e,t,n,d)=>{switch(t){case"===":return"object"==typeof e&&(e=e.version),"object"==typeof n&&(n=n.version),e===n;case"!==":return"object"==typeof e&&(e=e.version),"object"==typeof n&&(n=n.version),e!==n;case"":case"=":case"==":return r(e,n,d);case"!=":return i(e,n,d);case">":return a(e,n,d);case">=":return s(e,n,d);case"<":return o(e,n,d);case"<=":return l(e,n,d);default:throw new TypeError(`Invalid operator: ${t}`)}}},(e,t,n)=>{"use strict";const r=n(98),i=n(101),{safeRe:a,t:s}=n(95);e.exports=(e,t)=>{if(e instanceof r)return e;if("number"==typeof e&&(e=String(e)),"string"!=typeof e)return null;let n=null;if((t=t||{}).rtl){const r=t.includePrerelease?a[s.COERCERTLFULL]:a[s.COERCERTL];let i;for(;(i=r.exec(e))&&(!n||n.index+n[0].length!==e.length);)n&&i.index+i[0].length===n.index+n[0].length||(n=i),r.lastIndex=i.index+i[1].length+i[2].length;r.lastIndex=-1}else n=e.match(t.includePrerelease?a[s.COERCEFULL]:a[s.COERCE]);if(null===n)return null;const o=n[2],l=n[3]||"0",d=n[4]||"0",c=t.includePrerelease&&n[5]?`-${n[5]}`:"",u=t.includePrerelease&&n[6]?`+${n[6]}`:"";return i(`${o}.${l}.${d}${c}${u}`,t)}},(e,t,n)=>{"use strict";const r=Symbol("SemVer ANY");class i{static get ANY(){return r}constructor(e,t){if(t=a(t),e instanceof i){if(e.loose===!!t.loose)return e;e=e.value}e=e.trim().split(/\s+/).join(" "),d("comparator",e,t),this.options=t,this.loose=!!t.loose,this.parse(e),this.semver===r?this.value="":this.value=this.operator+this.semver.version,d("comp",this)}parse(e){const t=this.options.loose?s[o.COMPARATORLOOSE]:s[o.COMPARATOR],n=e.match(t);if(!n)throw new TypeError(`Invalid comparator: ${e}`);this.operator=void 0!==n[1]?n[1]:"","="===this.operator&&(this.operator=""),n[2]?this.semver=new c(n[2],this.options.loose):this.semver=r}toString(){return this.value}test(e){if(d("Comparator.test",e,this.options.loose),this.semver===r||e===r)return!0;if("string"==typeof e)try{e=new c(e,this.options)}catch(e){return!1}return l(e,this.operator,this.semver,this.options)}intersects(e,t){if(!(e instanceof i))throw new TypeError("a Comparator is required");return""===this.operator?""===this.value||new u(e.value,t).test(this.value):""===e.operator?""===e.value||new u(this.value,t).test(e.semver):(!(t=a(t)).includePrerelease||"<0.0.0-0"!==this.value&&"<0.0.0-0"!==e.value)&&(!(!t.includePrerelease&&(this.value.startsWith("<0.0.0")||e.value.startsWith("<0.0.0")))&&(!(!this.operator.startsWith(">")||!e.operator.startsWith(">"))||(!(!this.operator.startsWith("<")||!e.operator.startsWith("<"))||(!(this.semver.version!==e.semver.version||!this.operator.includes("=")||!e.operator.includes("="))||(!!(l(this.semver,"<",e.semver,t)&&this.operator.startsWith(">")&&e.operator.startsWith("<"))||!!(l(this.semver,">",e.semver,t)&&this.operator.startsWith("<")&&e.operator.startsWith(">")))))))}}e.exports=i;const a=n(99),{safeRe:s,t:o}=n(95),l=n(122),d=n(97),c=n(98),u=n(125)},(e,t,n)=>{"use strict";const r=/\s+/g;class i{constructor(e,t){if(t=s(t),e instanceof i)return e.loose===!!t.loose&&e.includePrerelease===!!t.includePrerelease?e:new i(e.raw,t);if(e instanceof o)return this.raw=e.value,this.set=[[e]],this.formatted=void 0,this;if(this.options=t,this.loose=!!t.loose,this.includePrerelease=!!t.includePrerelease,this.raw=e.trim().replace(r," "),this.set=this.raw.split("||").map(e=>this.parseRange(e.trim())).filter(e=>e.length),!this.set.length)throw new TypeError(`Invalid SemVer Range: ${this.raw}`);if(this.set.length>1){const e=this.set[0];if(this.set=this.set.filter(e=>!b(e[0])),0===this.set.length)this.set=[e];else if(this.set.length>1)for(const e of this.set)if(1===e.length&&g(e[0])){this.set=[e];break}}this.formatted=void 0}get range(){if(void 0===this.formatted){this.formatted="";for(let e=0;e<this.set.length;e++){e>0&&(this.formatted+="||");const t=this.set[e];for(let e=0;e<t.length;e++)e>0&&(this.formatted+=" "),this.formatted+=t[e].toString().trim()}}return this.formatted}format(){return this.range}toString(){return this.range}parseRange(e){const t=((this.options.includePrerelease&&m)|(this.options.loose&&f))+":"+e,n=a.get(t);if(n)return n;const r=this.options.loose,i=r?c[u.HYPHENRANGELOOSE]:c[u.HYPHENRANGE];e=e.replace(i,O(this.options.includePrerelease)),l("hyphen replace",e),e=e.replace(c[u.COMPARATORTRIM],p),l("comparator trim",e),e=e.replace(c[u.TILDETRIM],h),l("tilde trim",e),e=e.replace(c[u.CARETTRIM],y),l("caret trim",e);let s=e.split(" ").map(e=>K(e,this.options)).join(" ").split(/\s+/).map(e=>A(e,this.options));r&&(s=s.filter(e=>(l("loose invalid filter",e,this.options),!!e.match(c[u.COMPARATORLOOSE])))),l("range list",s);const d=new Map,g=s.map(e=>new o(e,this.options));for(const e of g){if(b(e))return[e];d.set(e.value,e)}d.size>1&&d.has("")&&d.delete("");const v=[...d.values()];return a.set(t,v),v}intersects(e,t){if(!(e instanceof i))throw new TypeError("a Range is required");return this.set.some(n=>v(n,t)&&e.set.some(e=>v(e,t)&&n.every(n=>e.every(e=>n.intersects(e,t)))))}test(e){if(!e)return!1;if("string"==typeof e)try{e=new d(e,this.options)}catch(e){return!1}for(let t=0;t<this.set.length;t++)if(D(this.set[t],e,this.options))return!0;return!1}}e.exports=i;const a=new(n(126)),s=n(99),o=n(124),l=n(97),d=n(98),{safeRe:c,t:u,comparatorTrimReplace:p,tildeTrimReplace:h,caretTrimReplace:y}=n(95),{FLAG_INCLUDE_PRERELEASE:m,FLAG_LOOSE:f}=n(96),b=e=>"<0.0.0-0"===e.value,g=e=>""===e.value,v=(e,t)=>{let n=!0;const r=e.slice();let i=r.pop();for(;n&&r.length;)n=r.every(e=>i.intersects(e,t)),i=r.pop();return n},K=(e,t)=>(l("comp",e,t),e=w(e,t),l("caret",e),e=S(e,t),l("tildes",e),e=j(e,t),l("xrange",e),e=T(e,t),l("stars",e),e),E=e=>!e||"x"===e.toLowerCase()||"*"===e,S=(e,t)=>e.trim().split(/\s+/).map(e=>I(e,t)).join(" "),I=(e,t)=>{const n=t.loose?c[u.TILDELOOSE]:c[u.TILDE];return e.replace(n,(t,n,r,i,a)=>{let s;return l("tilde",e,t,n,r,i,a),E(n)?s="":E(r)?s=`>=${n}.0.0 <${+n+1}.0.0-0`:E(i)?s=`>=${n}.${r}.0 <${n}.${+r+1}.0-0`:a?(l("replaceTilde pr",a),s=`>=${n}.${r}.${i}-${a} <${n}.${+r+1}.0-0`):s=`>=${n}.${r}.${i} <${n}.${+r+1}.0-0`,l("tilde return",s),s})},w=(e,t)=>e.trim().split(/\s+/).map(e=>k(e,t)).join(" "),k=(e,t)=>{l("caret",e,t);const n=t.loose?c[u.CARETLOOSE]:c[u.CARET],r=t.includePrerelease?"-0":"";return e.replace(n,(t,n,i,a,s)=>{let o;return l("caret",e,t,n,i,a,s),E(n)?o="":E(i)?o=`>=${n}.0.0${r} <${+n+1}.0.0-0`:E(a)?o="0"===n?`>=${n}.${i}.0${r} <${n}.${+i+1}.0-0`:`>=${n}.${i}.0${r} <${+n+1}.0.0-0`:s?(l("replaceCaret pr",s),o="0"===n?"0"===i?`>=${n}.${i}.${a}-${s} <${n}.${i}.${+a+1}-0`:`>=${n}.${i}.${a}-${s} <${n}.${+i+1}.0-0`:`>=${n}.${i}.${a}-${s} <${+n+1}.0.0-0`):(l("no pr"),o="0"===n?"0"===i?`>=${n}.${i}.${a}${r} <${n}.${i}.${+a+1}-0`:`>=${n}.${i}.${a}${r} <${n}.${+i+1}.0-0`:`>=${n}.${i}.${a} <${+n+1}.0.0-0`),l("caret return",o),o})},j=(e,t)=>(l("replaceXRanges",e,t),e.split(/\s+/).map(e=>x(e,t)).join(" ")),x=(e,t)=>{e=e.trim();const n=t.loose?c[u.XRANGELOOSE]:c[u.XRANGE];return e.replace(n,(n,r,i,a,s,o)=>{l("xRange",e,n,r,i,a,s,o);const d=E(i),c=d||E(a),u=c||E(s),p=u;return"="===r&&p&&(r=""),o=t.includePrerelease?"-0":"",d?n=">"===r||"<"===r?"<0.0.0-0":"*":r&&p?(c&&(a=0),s=0,">"===r?(r=">=",c?(i=+i+1,a=0,s=0):(a=+a+1,s=0)):"<="===r&&(r="<",c?i=+i+1:a=+a+1),"<"===r&&(o="-0"),n=`${r+i}.${a}.${s}${o}`):c?n=`>=${i}.0.0${o} <${+i+1}.0.0-0`:u&&(n=`>=${i}.${a}.0${o} <${i}.${+a+1}.0-0`),l("xRange return",n),n})},T=(e,t)=>(l("replaceStars",e,t),e.trim().replace(c[u.STAR],"")),A=(e,t)=>(l("replaceGTE0",e,t),e.trim().replace(c[t.includePrerelease?u.GTE0PRE:u.GTE0],"")),O=e=>(t,n,r,i,a,s,o,l,d,c,u,p)=>`${n=E(r)?"":E(i)?`>=${r}.0.0${e?"-0":""}`:E(a)?`>=${r}.${i}.0${e?"-0":""}`:s?`>=${n}`:`>=${n}${e?"-0":""}`} ${l=E(d)?"":E(c)?`<${+d+1}.0.0-0`:E(u)?`<${d}.${+c+1}.0-0`:p?`<=${d}.${c}.${u}-${p}`:e?`<${d}.${c}.${+u+1}-0`:`<=${l}`}`.trim(),D=(e,t,n)=>{for(let n=0;n<e.length;n++)if(!e[n].test(t))return!1;if(t.prerelease.length&&!n.includePrerelease){for(let n=0;n<e.length;n++)if(l(e[n].semver),e[n].semver!==o.ANY&&e[n].semver.prerelease.length>0){const r=e[n].semver;if(r.major===t.major&&r.minor===t.minor&&r.patch===t.patch)return!0}return!1}return!0}},e=>{"use strict";e.exports=class{constructor(){this.max=1e3,this.map=new Map}get(e){const t=this.map.get(e);return void 0===t?void 0:(this.map.delete(e),this.map.set(e,t),t)}delete(e){return this.map.delete(e)}set(e,t){if(!this.delete(e)&&void 0!==t){if(this.map.size>=this.max){const e=this.map.keys().next().value;this.delete(e)}this.map.set(e,t)}return this}}},(e,t,n)=>{"use strict";const r=n(125);e.exports=(e,t,n)=>{try{t=new r(t,n)}catch(e){return!1}return t.test(e)}},(e,t,n)=>{"use strict";const r=n(125);e.exports=(e,t)=>new r(e,t).set.map(e=>e.map(e=>e.value).join(" ").trim().split(" "))},(e,t,n)=>{"use strict";const r=n(98),i=n(125);e.exports=(e,t,n)=>{let a=null,s=null,o=null;try{o=new i(t,n)}catch(e){return null}return e.forEach(e=>{o.test(e)&&(a&&-1!==s.compare(e)||(a=e,s=new r(a,n)))}),a}},(e,t,n)=>{"use strict";const r=n(98),i=n(125);e.exports=(e,t,n)=>{let a=null,s=null,o=null;try{o=new i(t,n)}catch(e){return null}return e.forEach(e=>{o.test(e)&&(a&&1!==s.compare(e)||(a=e,s=new r(a,n)))}),a}},(e,t,n)=>{"use strict";const r=n(98),i=n(125),a=n(116);e.exports=(e,t)=>{e=new i(e,t);let n=new r("0.0.0");if(e.test(n))return n;if(n=new r("0.0.0-0"),e.test(n))return n;n=null;for(let t=0;t<e.set.length;++t){const i=e.set[t];let s=null;i.forEach(e=>{const t=new r(e.semver.version);switch(e.operator){case">":0===t.prerelease.length?t.patch++:t.prerelease.push(0),t.raw=t.format();case"":case">=":s&&!a(t,s)||(s=t);break;case"<":case"<=":break;default:throw new Error(`Unexpected operation: ${e.operator}`)}}),!s||n&&!a(n,s)||(n=s)}return n&&e.test(n)?n:null}},(e,t,n)=>{"use strict";const r=n(125);e.exports=(e,t)=>{try{return new r(e,t).range||"*"}catch(e){return null}}},(e,t,n)=>{"use strict";const r=n(98),i=n(124),{ANY:a}=i,s=n(125),o=n(127),l=n(116),d=n(117),c=n(121),u=n(120);e.exports=(e,t,n,p)=>{let h,y,m,f,b;switch(e=new r(e,p),t=new s(t,p),n){case">":h=l,y=c,m=d,f=">",b=">=";break;case"<":h=d,y=u,m=l,f="<",b="<=";break;default:throw new TypeError('Must provide a hilo val of "<" or ">"')}if(o(e,t,p))return!1;for(let n=0;n<t.set.length;++n){const r=t.set[n];let s=null,o=null;if(r.forEach(e=>{e.semver===a&&(e=new i(">=0.0.0")),s=s||e,o=o||e,h(e.semver,s.semver,p)?s=e:m(e.semver,o.semver,p)&&(o=e)}),s.operator===f||s.operator===b)return!1;if((!o.operator||o.operator===f)&&y(e,o.semver))return!1;if(o.operator===b&&m(e,o.semver))return!1}return!0}},(e,t,n)=>{"use strict";const r=n(133);e.exports=(e,t,n)=>r(e,t,">",n)},(e,t,n)=>{"use strict";const r=n(133);e.exports=(e,t,n)=>r(e,t,"<",n)},(e,t,n)=>{"use strict";const r=n(125);e.exports=(e,t,n)=>(e=new r(e,n),t=new r(t,n),e.intersects(t,n))},(e,t,n)=>{"use strict";const r=n(127),i=n(110);e.exports=(e,t,n)=>{const a=[];let s=null,o=null;const l=e.sort((e,t)=>i(e,t,n));for(const e of l){r(e,t,n)?(o=e,s||(s=e)):(o&&a.push([s,o]),o=null,s=null)}s&&a.push([s,null]);const d=[];for(const[e,t]of a)e===t?d.push(e):t||e!==l[0]?t?e===l[0]?d.push(`<=${t}`):d.push(`${e} - ${t}`):d.push(`>=${e}`):d.push("*");const c=d.join(" || "),u="string"==typeof t.raw?t.raw:String(t);return c.length<u.length?c:t}},(e,t,n)=>{"use strict";const r=n(125),i=n(124),{ANY:a}=i,s=n(127),o=n(110),l=[new i(">=0.0.0-0")],d=[new i(">=0.0.0")],c=(e,t,n)=>{if(e===t)return!0;if(1===e.length&&e[0].semver===a){if(1===t.length&&t[0].semver===a)return!0;e=n.includePrerelease?l:d}if(1===t.length&&t[0].semver===a){if(n.includePrerelease)return!0;t=d}const r=new Set;let i,c,h,y,m,f,b;for(const t of e)">"===t.operator||">="===t.operator?i=u(i,t,n):"<"===t.operator||"<="===t.operator?c=p(c,t,n):r.add(t.semver);if(r.size>1)return null;if(i&&c){if(h=o(i.semver,c.semver,n),h>0)return null;if(0===h&&(">="!==i.operator||"<="!==c.operator))return null}for(const e of r){if(i&&!s(e,String(i),n))return null;if(c&&!s(e,String(c),n))return null;for(const r of t)if(!s(e,String(r),n))return!1;return!0}let g=!(!c||n.includePrerelease||!c.semver.prerelease.length)&&c.semver,v=!(!i||n.includePrerelease||!i.semver.prerelease.length)&&i.semver;g&&1===g.prerelease.length&&"<"===c.operator&&0===g.prerelease[0]&&(g=!1);for(const e of t){if(b=b||">"===e.operator||">="===e.operator,f=f||"<"===e.operator||"<="===e.operator,i)if(v&&e.semver.prerelease&&e.semver.prerelease.length&&e.semver.major===v.major&&e.semver.minor===v.minor&&e.semver.patch===v.patch&&(v=!1),">"===e.operator||">="===e.operator){if(y=u(i,e,n),y===e&&y!==i)return!1}else if(">="===i.operator&&!s(i.semver,String(e),n))return!1;if(c)if(g&&e.semver.prerelease&&e.semver.prerelease.length&&e.semver.major===g.major&&e.semver.minor===g.minor&&e.semver.patch===g.patch&&(g=!1),"<"===e.operator||"<="===e.operator){if(m=p(c,e,n),m===e&&m!==c)return!1}else if("<="===c.operator&&!s(c.semver,String(e),n))return!1;if(!e.operator&&(c||i)&&0!==h)return!1}return!(i&&f&&!c&&0!==h)&&(!(c&&b&&!i&&0!==h)&&(!v&&!g))},u=(e,t,n)=>{if(!e)return t;const r=o(e.semver,t.semver,n);return r>0?e:r<0||">"===t.operator&&">="===e.operator?t:e},p=(e,t,n)=>{if(!e)return t;const r=o(e.semver,t.semver,n);return r<0?e:r>0||"<"===t.operator&&"<="===e.operator?t:e};e.exports=(e,t,n={})=>{if(e===t)return!0;e=new r(e,n),t=new r(t,n);let i=!1;e:for(const r of e.set){for(const e of t.set){const t=c(r,e,n);if(i=i||null!==t,t)continue e}if(i)return!1}return!0}},e=>{function t(e){return Promise.resolve().then(()=>{var t=new Error("Cannot find module '"+e+"'");throw t.code="MODULE_NOT_FOUND",t})}t.keys=()=>[],t.resolve=t,t.id=139,e.exports=t},(e,t,n)=>{"use strict";n.r(t),n.d(t,{DELAYED_ERROR:()=>r.DELAYED_ERROR,DelayedError:()=>r.DelayedError,RATE_LIMIT_ERROR:()=>i.RATE_LIMIT_ERROR,RateLimitError:()=>i.RateLimitError,UNRECOVERABLE_ERROR:()=>a.UNRECOVERABLE_ERROR,UnrecoverableError:()=>a.UnrecoverableError,WAITING_CHILDREN_ERROR:()=>s.WAITING_CHILDREN_ERROR,WAITING_ERROR:()=>o.WAITING_ERROR,WaitingChildrenError:()=>s.WaitingChildrenError,WaitingError:()=>o.WaitingError});var r=n(141),i=n(142),a=n(143),s=n(144),o=n(145)},(e,t,n)=>{"use strict";n.r(t),n.d(t,{DELAYED_ERROR:()=>r,DelayedError:()=>i});const r="bullmq:movedToDelayed";class i extends Error{constructor(e=r){super(e),this.name=this.constructor.name,Object.setPrototypeOf(this,new.target.prototype)}}},(e,t,n)=>{"use strict";n.r(t),n.d(t,{RATE_LIMIT_ERROR:()=>r,RateLimitError:()=>i});const r="bullmq:rateLimitExceeded";class i extends Error{constructor(e=r){super(e),this.name=this.constructor.name,Object.setPrototypeOf(this,new.target.prototype)}}},(e,t,n)=>{"use strict";n.r(t),n.d(t,{UNRECOVERABLE_ERROR:()=>r,UnrecoverableError:()=>i});const r="bullmq:unrecoverable";class i extends Error{constructor(e=r){super(e),this.name=this.constructor.name,Object.setPrototypeOf(this,new.target.prototype)}}},(e,t,n)=>{"use strict";n.r(t),n.d(t,{WAITING_CHILDREN_ERROR:()=>r,WaitingChildrenError:()=>i});const r="bullmq:movedToWaitingChildren";class i extends Error{constructor(e=r){super(e),this.name=this.constructor.name,Object.setPrototypeOf(this,new.target.prototype)}}},(e,t,n)=>{"use strict";n.r(t),n.d(t,{WAITING_ERROR:()=>r,WaitingError:()=>i});const r="bullmq:movedToWait";class i extends Error{constructor(e=r){super(e),this.name=this.constructor.name,Object.setPrototypeOf(this,new.target.prototype)}}},(e,t,n)=>{"use strict";n.r(t),n.d(t,{FlowProducer:()=>c});var r=n(14),i=n(200),a=n(18),s=n(147),o=n(149),l=n(150),d=n(8);class c extends r.EventEmitter{constructor(e={connection:{}},t=l.RedisConnection){super(),this.opts=e,this.opts=Object.assign({prefix:"bull"},e),this.connection=new t(e.connection,{shared:(0,a.isRedisInstance)(e.connection),blocking:!1,skipVersionCheck:e.skipVersionCheck,skipWaitingForReady:e.skipWaitingForReady}),this.connection.on("error",e=>this.emit("error",e)),this.connection.on("close",()=>{this.closing||this.emit("ioredis:close")}),this.queueKeys=new o.QueueKeys(e.prefix),(null==e?void 0:e.telemetry)&&(this.telemetry=e.telemetry)}emit(e,...t){return super.emit(e,...t)}off(e,t){return super.off(e,t),this}on(e,t){return super.on(e,t),this}once(e,t){return super.once(e,t),this}get client(){return this.connection.client}get Job(){return s.Job}waitUntilReady(){return this.client}async add(e,t){var n;if(this.closing)return;const r=(await this.connection.client).multi(),i=null===(n=null==e?void 0:e.opts)||void 0===n?void 0:n.parent,s=(0,a.getParentKey)(i),o=s?`${s}:dependencies`:void 0;return(0,a.trace)(this.telemetry,d.SpanKind.PRODUCER,e.queueName,"addFlow",e.queueName,async n=>{null==n||n.setAttributes({[d.TelemetryAttributes.FlowName]:e.name});const a=await this.addNode({multi:r,node:e,queuesOpts:null==t?void 0:t.queuesOptions,parent:{parentOpts:i,parentDependenciesKey:o}});return await r.exec(),a})}async getFlow(e){if(this.closing)return;const t=await this.connection.client,n=Object.assign({depth:10,maxChildren:20,prefix:this.opts.prefix},e);return this.getNode(t,n)}async addBulk(e){if(this.closing)return;const t=(await this.connection.client).multi();return(0,a.trace)(this.telemetry,d.SpanKind.PRODUCER,"","addBulkFlows","",async n=>{null==n||n.setAttributes({[d.TelemetryAttributes.BulkCount]:e.length,[d.TelemetryAttributes.BulkNames]:e.map(e=>e.name).join(",")});const r=await this.addNodes(t,e);return await t.exec(),r})}async addNode({multi:e,node:t,parent:n,queuesOpts:r}){var s,l;const c=t.prefix||this.opts.prefix,u=this.queueFromNode(t,new o.QueueKeys(c),c),p=r&&r[t.queueName],h=null!==(s=null==p?void 0:p.defaultJobOptions)&&void 0!==s?s:{},y=(null===(l=t.opts)||void 0===l?void 0:l.jobId)||(0,i.default)();return(0,a.trace)(this.telemetry,d.SpanKind.PRODUCER,t.queueName,"addNode",t.queueName,async(i,s)=>{var l,c;null==i||i.setAttributes({[d.TelemetryAttributes.JobName]:t.name,[d.TelemetryAttributes.JobId]:y});const p=t.opts;let m=null==p?void 0:p.telemetry;if(s&&p){const e=null===(l=p.telemetry)||void 0===l?void 0:l.omitContext,t=(null===(c=p.telemetry)||void 0===c?void 0:c.metadata)||!e&&s;(t||e)&&(m={metadata:t,omitContext:e})}const f=new this.Job(u,t.name,t.data,Object.assign(Object.assign(Object.assign({},h),p),{parent:null==n?void 0:n.parentOpts,telemetry:m}),y),b=(0,a.getParentKey)(null==n?void 0:n.parentOpts);if(t.children&&t.children.length>0){const i=y,a=new o.QueueKeys(t.prefix||this.opts.prefix),s=a.toKey(t.queueName,"waiting-children");await f.addJob(e,{parentDependenciesKey:null==n?void 0:n.parentDependenciesKey,waitChildrenKey:s,parentKey:b});const l=`${a.toKey(t.queueName,i)}:dependencies`;return{job:f,children:await this.addChildren({multi:e,nodes:t.children,parent:{parentOpts:{id:i,queue:a.getQueueQualifiedName(t.queueName)},parentDependenciesKey:l},queuesOpts:r})}}return await f.addJob(e,{parentDependenciesKey:null==n?void 0:n.parentDependenciesKey,parentKey:b}),{job:f}})}addNodes(e,t){return Promise.all(t.map(t=>{var n;const r=null===(n=null==t?void 0:t.opts)||void 0===n?void 0:n.parent,i=(0,a.getParentKey)(r),s=i?`${i}:dependencies`:void 0;return this.addNode({multi:e,node:t,parent:{parentOpts:r,parentDependenciesKey:s}})}))}async getNode(e,t){const n=this.queueFromNode(t,new o.QueueKeys(t.prefix),t.prefix),r=await this.Job.fromId(n,t.id);if(r){const{processed:n={},unprocessed:i=[],failed:a=[],ignored:s={}}=await r.getDependencies({failed:{count:t.maxChildren},processed:{count:t.maxChildren},unprocessed:{count:t.maxChildren},ignored:{count:t.maxChildren}}),o=Object.keys(n),l=Object.keys(s),d=o.length+i.length+l.length+a.length,c=t.depth-1;if(d>0&&c){return{job:r,children:await this.getChildren(e,[...o,...i,...a,...l],c,t.maxChildren)}}return{job:r}}}addChildren({multi:e,nodes:t,parent:n,queuesOpts:r}){return Promise.all(t.map(t=>this.addNode({multi:e,node:t,parent:n,queuesOpts:r})))}getChildren(e,t,n,r){return Promise.all([...t.map(t=>{const[i,a,s]=t.split(":");return this.getNode(e,{id:s,queueName:a,prefix:i,depth:n,maxChildren:r})})])}queueFromNode(e,t,n){return{client:this.connection.client,name:e.queueName,keys:t.getKeys(e.queueName),toKey:n=>t.toKey(e.queueName,n),opts:{prefix:n,connection:{}},qualifiedName:t.getQueueQualifiedName(e.queueName),closing:this.closing,waitUntilReady:async()=>this.connection.client,removeListener:this.removeListener.bind(this),emit:this.emit.bind(this),on:this.on.bind(this),redisVersion:this.connection.redisVersion,trace:async()=>{}}}async close(){this.closing||(this.closing=this.connection.close()),await this.closing}disconnect(){return this.connection.disconnect()}}},(e,t,n)=>{"use strict";n.r(t),n.d(t,{Job:()=>c,PRIORITY_LIMIT:()=>d});var r=n(148);Object(function(){var e=new Error("Cannot find module 'util'");throw e.code="MODULE_NOT_FOUND",e}());var i=n(18),a=n(4),s=n(143),o=n(8);const l=Object(function(){var e=new Error("Cannot find module 'util'");throw e.code="MODULE_NOT_FOUND",e}())("bull"),d=2**21;class c{constructor(e,t,n,s={},o){this.queue=e,this.name=t,this.data=n,this.opts=s,this.id=o,this.progress=0,this.returnvalue=null,this.stacktrace=null,this.delay=0,this.priority=0,this.attemptsStarted=0,this.attemptsMade=0,this.stalledCounter=0;const l=this.opts,{repeatJobKey:d}=l,c=(0,r.__rest)(l,["repeatJobKey"]);this.opts=Object.assign({attempts:0},c),this.delay=this.opts.delay,this.priority=this.opts.priority||0,this.repeatJobKey=d,this.timestamp=s.timestamp?s.timestamp:Date.now(),this.opts.backoff=a.Backoffs.normalize(s.backoff),this.parentKey=(0,i.getParentKey)(s.parent),s.parent&&(this.parent={id:s.parent.id,queueKey:s.parent.queue},s.failParentOnFailure&&(this.parent.fpof=!0),s.removeDependencyOnFailure&&(this.parent.rdof=!0),s.ignoreDependencyOnFailure&&(this.parent.idof=!0),s.continueParentOnFailure&&(this.parent.cpof=!0)),this.debounceId=s.debounce?s.debounce.id:void 0,this.deduplicationId=s.deduplication?s.deduplication.id:this.debounceId,this.toKey=e.toKey.bind(e),this.createScripts(),this.queueQualifiedName=e.qualifiedName}static async create(e,t,n,r){const i=await e.client,a=new this(e,t,n,r,r&&r.jobId);return a.id=await a.addJob(i,{parentKey:a.parentKey,parentDependenciesKey:a.parentKey?`${a.parentKey}:dependencies`:""}),a}static async createBulk(e,t){const n=await e.client,r=t.map(t=>{var n;return new this(e,t.name,t.data,t.opts,null===(n=t.opts)||void 0===n?void 0:n.jobId)}),i=n.pipeline();for(const e of r)e.addJob(i,{parentKey:e.parentKey,parentDependenciesKey:e.parentKey?`${e.parentKey}:dependencies`:""});const a=await i.exec();for(let e=0;e<a.length;++e){const[t,n]=a[e];if(t)throw t;r[e].id=n}return r}static fromJSON(e,t,n){const r=JSON.parse(t.data||"{}"),a=c.optsFromJSON(t.opts),s=new this(e,t.name,r,a,t.id||n);return s.progress=JSON.parse(t.progress||"0"),s.delay=parseInt(t.delay),s.priority=parseInt(t.priority),s.timestamp=parseInt(t.timestamp),t.finishedOn&&(s.finishedOn=parseInt(t.finishedOn)),t.processedOn&&(s.processedOn=parseInt(t.processedOn)),t.rjk&&(s.repeatJobKey=t.rjk),t.deid&&(s.debounceId=t.deid,s.deduplicationId=t.deid),t.failedReason&&(s.failedReason=t.failedReason),s.attemptsStarted=parseInt(t.ats||"0"),s.attemptsMade=parseInt(t.attemptsMade||t.atm||"0"),s.stalledCounter=parseInt(t.stc||"0"),t.defa&&(s.deferredFailure=t.defa),s.stacktrace=function(e){const t=(0,i.tryCatch)(JSON.parse,JSON,[e]);return t!==i.errorObject&&t instanceof Array?t:[]}(t.stacktrace),"string"==typeof t.returnvalue&&(s.returnvalue=u(t.returnvalue)),t.parentKey&&(s.parentKey=t.parentKey),t.parent&&(s.parent=JSON.parse(t.parent)),t.pb&&(s.processedBy=t.pb),t.nrjid&&(s.nextRepeatableJobId=t.nrjid),s}createScripts(){this.scripts=(0,i.createScripts)(this.queue)}static optsFromJSON(e,t=i.optsDecodeMap){const n=JSON.parse(e||"{}"),r=Object.entries(n),a={};for(const e of r){const[n,r]=e;t[n]?a[t[n]]=r:"tm"===n?a.telemetry=Object.assign(Object.assign({},a.telemetry),{metadata:r}):"omc"===n?a.telemetry=Object.assign(Object.assign({},a.telemetry),{omitContext:r}):a[n]=r}return a}static async fromId(e,t){if(t){const n=await e.client,r=await n.hgetall(e.toKey(t));return(0,i.isEmpty)(r)?void 0:this.fromJSON(e,r,t)}}static addJobLog(e,t,n,r){return e.scripts.addLog(t,n,r)}toJSON(){const{queue:e,scripts:t}=this;return(0,r.__rest)(this,["queue","scripts"])}asJSON(){return(0,i.removeUndefinedFields)({id:this.id,name:this.name,data:JSON.stringify(void 0===this.data?{}:this.data),opts:c.optsAsJSON(this.opts),parent:this.parent?Object.assign({},this.parent):void 0,parentKey:this.parentKey,progress:this.progress,attemptsMade:this.attemptsMade,attemptsStarted:this.attemptsStarted,stalledCounter:this.stalledCounter,finishedOn:this.finishedOn,processedOn:this.processedOn,timestamp:this.timestamp,failedReason:JSON.stringify(this.failedReason),stacktrace:JSON.stringify(this.stacktrace),debounceId:this.debounceId,deduplicationId:this.deduplicationId,repeatJobKey:this.repeatJobKey,returnvalue:JSON.stringify(this.returnvalue),nrjid:this.nextRepeatableJobId})}static optsAsJSON(e={},t=i.optsEncodeMap){const n=Object.entries(e),r={};for(const[e,i]of n)if(void 0!==i)if(e in t){r[t[e]]=i}else"telemetry"===e?(r.tm=i.metadata,r.omc=i.omitContext):r[e]=i;return r}asJSONSandbox(){return Object.assign(Object.assign({},this.asJSON()),{queueName:this.queueName,prefix:this.prefix})}updateData(e){return this.data=e,this.scripts.updateData(this,e)}async updateProgress(e){this.progress=e,await this.scripts.updateProgress(this.id,e),this.queue.emit("progress",this,e)}async log(e){return c.addJobLog(this.queue,this.id,e,this.opts.keepLogs)}async removeChildDependency(){return!!await this.scripts.removeChildDependency(this.id,this.parentKey)&&(this.parent=void 0,this.parentKey=void 0,!0)}async clearLogs(e){const t=await this.queue.client,n=this.toKey(this.id)+":logs";e?await t.ltrim(n,-e,-1):await t.del(n)}async remove({removeChildren:e=!0}={}){await this.queue.waitUntilReady();const t=this.queue,n=this;if(!await this.scripts.remove(n.id,e))throw new Error(`Job ${this.id} could not be removed because it is locked by another worker`);t.emit("removed",n)}async removeUnprocessedChildren(){const e=this.id;await this.scripts.removeUnprocessedChildren(e)}extendLock(e,t){return this.scripts.extendLock(this.id,e,t)}async moveToCompleted(e,t,n=!0){return this.queue.trace(o.SpanKind.INTERNAL,"complete",this.queue.name,async(r,a)=>{var s,o;let l;!(null===(o=null===(s=this.opts)||void 0===s?void 0:s.telemetry)||void 0===o?void 0:o.omitContext)&&a&&(l=a),await this.queue.waitUntilReady(),this.returnvalue=e||void 0;const d=(0,i.tryCatch)(JSON.stringify,JSON,[e]);if(d===i.errorObject)throw i.errorObject.value;const c=this.scripts.moveToCompletedArgs(this,d,this.opts.removeOnComplete,t,n),u=await this.scripts.moveToFinished(this.id,c);return this.finishedOn=c[this.scripts.moveToFinishedKeys.length+1],this.attemptsMade+=1,u})}moveToWait(e){return this.scripts.moveJobFromActiveToWait(this.id,e)}async shouldRetryJob(e){if(this.attemptsMade+1<this.opts.attempts&&!this.discarded&&!(e instanceof s.UnrecoverableError||"UnrecoverableError"==e.name)){const t=this.queue.opts,n=await a.Backoffs.calculate(this.opts.backoff,this.attemptsMade+1,e,this,t.settings&&t.settings.backoffStrategy);return[-1!=n,-1==n?0:n]}return[!1,0]}async moveToFailed(e,t,n=!1){this.failedReason=null==e?void 0:e.message;const[r,i]=await this.shouldRetryJob(e);return this.queue.trace(o.SpanKind.INTERNAL,this.getSpanOperation(r,i),this.queue.name,async(a,s)=>{var o,l;let d,c;!(null===(l=null===(o=this.opts)||void 0===o?void 0:o.telemetry)||void 0===l?void 0:l.omitContext)&&s&&(d=s),this.updateStacktrace(e);const u={failedReason:this.failedReason,stacktrace:JSON.stringify(this.stacktrace),tm:d};let p;if(r)c=i?await this.scripts.moveToDelayed(this.id,Date.now(),i,t,{fieldsToUpdate:u}):await this.scripts.retryJob(this.id,this.opts.lifo,t,{fieldsToUpdate:u});else{const e=this.scripts.moveToFailedArgs(this,this.failedReason,this.opts.removeOnFail,t,n,u);c=await this.scripts.moveToFinished(this.id,e),p=e[this.scripts.moveToFinishedKeys.length+1]}return p&&"number"==typeof p&&(this.finishedOn=p),i&&"number"==typeof i&&(this.delay=i),this.attemptsMade+=1,c})}getSpanOperation(e,t){return e?t?"delay":"retry":"fail"}isCompleted(){return this.isInZSet("completed")}isFailed(){return this.isInZSet("failed")}isDelayed(){return this.isInZSet("delayed")}isWaitingChildren(){return this.isInZSet("waiting-children")}isActive(){return this.isInList("active")}async isWaiting(){return await this.isInList("wait")||await this.isInList("paused")}get queueName(){return this.queue.name}get prefix(){return this.queue.opts.prefix}getState(){return this.scripts.getState(this.id)}async changeDelay(e){await this.scripts.changeDelay(this.id,e),this.delay=e}async changePriority(e){await this.scripts.changePriority(this.id,e.priority,e.lifo),this.priority=e.priority||0}async getChildrenValues(){const e=await this.queue.client,t=await e.hgetall(this.toKey(`${this.id}:processed`));if(t)return(0,i.parseObjectValues)(t)}async getIgnoredChildrenFailures(){return(await this.queue.client).hgetall(this.toKey(`${this.id}:failed`))}async getFailedChildrenValues(){return(await this.queue.client).hgetall(this.toKey(`${this.id}:failed`))}async getDependencies(e={}){const t=(await this.queue.client).multi();if(e.processed||e.unprocessed||e.ignored||e.failed){const n={cursor:0,count:20},r=[];if(e.processed){r.push("processed");const i=Object.assign(Object.assign({},n),e.processed);t.hscan(this.toKey(`${this.id}:processed`),i.cursor,"COUNT",i.count)}if(e.unprocessed){r.push("unprocessed");const i=Object.assign(Object.assign({},n),e.unprocessed);t.sscan(this.toKey(`${this.id}:dependencies`),i.cursor,"COUNT",i.count)}if(e.ignored){r.push("ignored");const i=Object.assign(Object.assign({},n),e.ignored);t.hscan(this.toKey(`${this.id}:failed`),i.cursor,"COUNT",i.count)}let i;if(e.failed){r.push("failed");const a=Object.assign(Object.assign({},n),e.failed);i=a.cursor+a.count,t.zrange(this.toKey(`${this.id}:unsuccessful`),a.cursor,a.count-1)}const a=await t.exec();let s,o,l,d,c,u,p;return r.forEach((e,t)=>{switch(e){case"processed":{s=a[t][1][0];const e=a[t][1][1],n={};for(let t=0;t<e.length;++t)t%2&&(n[e[t-1]]=JSON.parse(e[t]));o=n;break}case"failed":c=a[t][1];break;case"ignored":{u=a[t][1][0];const e=a[t][1][1],n={};for(let t=0;t<e.length;++t)t%2&&(n[e[t-1]]=e[t]);p=n;break}case"unprocessed":l=a[t][1][0],d=a[t][1][1]}}),Object.assign(Object.assign(Object.assign(Object.assign({},s?{processed:o,nextProcessedCursor:Number(s)}:{}),u?{ignored:p,nextIgnoredCursor:Number(u)}:{}),i?{failed:c,nextFailedCursor:i}:{}),l?{unprocessed:d,nextUnprocessedCursor:Number(l)}:{})}{t.hgetall(this.toKey(`${this.id}:processed`)),t.smembers(this.toKey(`${this.id}:dependencies`)),t.hgetall(this.toKey(`${this.id}:failed`)),t.zrange(this.toKey(`${this.id}:unsuccessful`),0,-1);const[[e,n],[r,a],[s,o],[l,d]]=await t.exec();return{processed:(0,i.parseObjectValues)(n),unprocessed:a,failed:d,ignored:o}}}async getDependenciesCount(e={}){const t=[];Object.entries(e).forEach(([e,n])=>{n&&t.push(e)});const n=t.length?t:["processed","unprocessed","ignored","failed"],r=await this.scripts.getDependencyCounts(this.id,n),i={};return r.forEach((e,t)=>{i[`${n[t]}`]=e||0}),i}async waitUntilFinished(e,t){await this.queue.waitUntilReady();const n=this.id;return new Promise(async(r,i)=>{let a;function s(e){c(),r(e.returnvalue)}function o(e){c(),i(new Error(e.failedReason||e))}t&&(a=setTimeout(()=>o(`Job wait ${this.name} timed out before finishing, no finish notification arrived after ${t}ms (id=${n})`),t));const l=`completed:${n}`,d=`failed:${n}`;e.on(l,s),e.on(d,o),this.queue.on("closing",o);const c=()=>{clearInterval(a),e.removeListener(l,s),e.removeListener(d,o),this.queue.removeListener("closing",o)};await e.waitUntilReady();const[p,h]=await this.scripts.isFinished(n,!0);0!=p&&(-1==p||2==p?o({failedReason:h}):s({returnvalue:u(h)}))})}async moveToDelayed(e,t){const n=Date.now(),r=e-n,i=r>0?r:0,a=await this.scripts.moveToDelayed(this.id,n,i,t,{skipAttempt:!0});return this.delay=i,a}async moveToWaitingChildren(e,t={}){return await this.scripts.moveToWaitingChildren(this.id,e,t)}async promote(){const e=this.id;await this.scripts.promote(e),this.delay=0}retry(e="failed"){return this.failedReason=null,this.finishedOn=null,this.processedOn=null,this.returnvalue=null,this.scripts.reprocessJob(this,e)}discard(){this.discarded=!0}async isInZSet(e){const t=await this.queue.client;return null!==await t.zscore(this.queue.toKey(e),this.id)}async isInList(e){return this.scripts.isJobInList(this.queue.toKey(e),this.id)}addJob(e,t){const n=this.asJSON();return this.validateOptions(n),this.scripts.addJob(e,n,n.opts,this.id,t)}validateOptions(e){var t;if(this.opts.sizeLimit&&(0,i.lengthInUtf8Bytes)(e.data)>this.opts.sizeLimit)throw new Error(`The size of job ${this.name} exceeds the limit ${this.opts.sizeLimit} bytes`);if(this.opts.delay&&this.opts.repeat&&!(null===(t=this.opts.repeat)||void 0===t?void 0:t.count))throw new Error("Delay and repeat options could not be used together");const n=["removeDependencyOnFailure","failParentOnFailure","continueParentOnFailure","ignoreDependencyOnFailure"].filter(e=>this.opts[e]);if(n.length>1){const e=n.join(", ");throw new Error(`The following options cannot be used together: ${e}`)}if(`${parseInt(this.id,10)}`===this.id)throw new Error("Custom Ids cannot be integers");if(this.opts.priority){if(Math.trunc(this.opts.priority)!==this.opts.priority)throw new Error("Priority should not be float");if(this.opts.priority>d)throw new Error(`Priority should be between 0 and ${d}`)}if("object"==typeof this.opts.backoff&&"number"==typeof this.opts.backoff.jitter&&(this.opts.backoff.jitter<0||this.opts.backoff.jitter>1))throw new Error("Jitter should be between 0 and 1")}updateStacktrace(e){this.stacktrace=this.stacktrace||[],(null==e?void 0:e.stack)&&(this.stacktrace.push(e.stack),0===this.opts.stackTraceLimit?this.stacktrace=[]:this.opts.stackTraceLimit&&(this.stacktrace=this.stacktrace.slice(-this.opts.stackTraceLimit)))}}function u(e){const t=(0,i.tryCatch)(JSON.parse,JSON,[e]);if(t!==i.errorObject)return t;l("corrupted returnvalue: "+e,t)}},(e,t,n)=>{"use strict";n.r(t),n.d(t,{__addDisposableResource:()=>M,__assign:()=>a,__asyncDelegator:()=>k,__asyncGenerator:()=>w,__asyncValues:()=>j,__await:()=>I,__awaiter:()=>y,__classPrivateFieldGet:()=>C,__classPrivateFieldIn:()=>P,__classPrivateFieldSet:()=>R,__createBinding:()=>f,__decorate:()=>o,__disposeResources:()=>L,__esDecorate:()=>d,__exportStar:()=>b,__extends:()=>i,__generator:()=>m,__importDefault:()=>D,__importStar:()=>O,__makeTemplateObject:()=>x,__metadata:()=>h,__param:()=>l,__propKey:()=>u,__read:()=>v,__rest:()=>s,__rewriteRelativeImportExtension:()=>J,__runInitializers:()=>c,__setFunctionName:()=>p,__spread:()=>K,__spreadArray:()=>S,__spreadArrays:()=>E,__values:()=>g,default:()=>_});var r=function(e,t){return r=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(e,t){e.__proto__=t}||function(e,t){for(var n in t)Object.prototype.hasOwnProperty.call(t,n)&&(e[n]=t[n])},r(e,t)};function i(e,t){if("function"!=typeof t&&null!==t)throw new TypeError("Class extends value "+String(t)+" is not a constructor or null");function n(){this.constructor=e}r(e,t),e.prototype=null===t?Object.create(t):(n.prototype=t.prototype,new n)}var a=function(){return a=Object.assign||function(e){for(var t,n=1,r=arguments.length;n<r;n++)for(var i in t=arguments[n])Object.prototype.hasOwnProperty.call(t,i)&&(e[i]=t[i]);return e},a.apply(this,arguments)};function s(e,t){var n={};for(var r in e)Object.prototype.hasOwnProperty.call(e,r)&&t.indexOf(r)<0&&(n[r]=e[r]);if(null!=e&&"function"==typeof Object.getOwnPropertySymbols){var i=0;for(r=Object.getOwnPropertySymbols(e);i<r.length;i++)t.indexOf(r[i])<0&&Object.prototype.propertyIsEnumerable.call(e,r[i])&&(n[r[i]]=e[r[i]])}return n}function o(e,t,n,r){var i,a=arguments.length,s=a<3?t:null===r?r=Object.getOwnPropertyDescriptor(t,n):r;if("object"==typeof Reflect&&"function"==typeof Reflect.decorate)s=Reflect.decorate(e,t,n,r);else for(var o=e.length-1;o>=0;o--)(i=e[o])&&(s=(a<3?i(s):a>3?i(t,n,s):i(t,n))||s);return a>3&&s&&Object.defineProperty(t,n,s),s}function l(e,t){return function(n,r){t(n,r,e)}}function d(e,t,n,r,i,a){function s(e){if(void 0!==e&&"function"!=typeof e)throw new TypeError("Function expected");return e}for(var o,l=r.kind,d="getter"===l?"get":"setter"===l?"set":"value",c=!t&&e?r.static?e:e.prototype:null,u=t||(c?Object.getOwnPropertyDescriptor(c,r.name):{}),p=!1,h=n.length-1;h>=0;h--){var y={};for(var m in r)y[m]="access"===m?{}:r[m];for(var m in r.access)y.access[m]=r.access[m];y.addInitializer=function(e){if(p)throw new TypeError("Cannot add initializers after decoration has completed");a.push(s(e||null))};var f=(0,n[h])("accessor"===l?{get:u.get,set:u.set}:u[d],y);if("accessor"===l){if(void 0===f)continue;if(null===f||"object"!=typeof f)throw new TypeError("Object expected");(o=s(f.get))&&(u.get=o),(o=s(f.set))&&(u.set=o),(o=s(f.init))&&i.unshift(o)}else(o=s(f))&&("field"===l?i.unshift(o):u[d]=o)}c&&Object.defineProperty(c,r.name,u),p=!0}function c(e,t,n){for(var r=arguments.length>2,i=0;i<t.length;i++)n=r?t[i].call(e,n):t[i].call(e);return r?n:void 0}function u(e){return"symbol"==typeof e?e:"".concat(e)}function p(e,t,n){return"symbol"==typeof t&&(t=t.description?"[".concat(t.description,"]"):""),Object.defineProperty(e,"name",{configurable:!0,value:n?"".concat(n," ",t):t})}function h(e,t){if("object"==typeof Reflect&&"function"==typeof Reflect.metadata)return Reflect.metadata(e,t)}function y(e,t,n,r){return new(n||(n=Promise))(function(i,a){function s(e){try{l(r.next(e))}catch(e){a(e)}}function o(e){try{l(r.throw(e))}catch(e){a(e)}}function l(e){var t;e.done?i(e.value):(t=e.value,t instanceof n?t:new n(function(e){e(t)})).then(s,o)}l((r=r.apply(e,t||[])).next())})}function m(e,t){var n,r,i,a={label:0,sent:function(){if(1&i[0])throw i[1];return i[1]},trys:[],ops:[]},s=Object.create(("function"==typeof Iterator?Iterator:Object).prototype);return s.next=o(0),s.throw=o(1),s.return=o(2),"function"==typeof Symbol&&(s[Symbol.iterator]=function(){return this}),s;function o(o){return function(l){return function(o){if(n)throw new TypeError("Generator is already executing.");for(;s&&(s=0,o[0]&&(a=0)),a;)try{if(n=1,r&&(i=2&o[0]?r.return:o[0]?r.throw||((i=r.return)&&i.call(r),0):r.next)&&!(i=i.call(r,o[1])).done)return i;switch(r=0,i&&(o=[2&o[0],i.value]),o[0]){case 0:case 1:i=o;break;case 4:return a.label++,{value:o[1],done:!1};case 5:a.label++,r=o[1],o=[0];continue;case 7:o=a.ops.pop(),a.trys.pop();continue;default:if(!(i=a.trys,(i=i.length>0&&i[i.length-1])||6!==o[0]&&2!==o[0])){a=0;continue}if(3===o[0]&&(!i||o[1]>i[0]&&o[1]<i[3])){a.label=o[1];break}if(6===o[0]&&a.label<i[1]){a.label=i[1],i=o;break}if(i&&a.label<i[2]){a.label=i[2],a.ops.push(o);break}i[2]&&a.ops.pop(),a.trys.pop();continue}o=t.call(e,a)}catch(e){o=[6,e],r=0}finally{n=i=0}if(5&o[0])throw o[1];return{value:o[0]?o[1]:void 0,done:!0}}([o,l])}}}var f=Object.create?function(e,t,n,r){void 0===r&&(r=n);var i=Object.getOwnPropertyDescriptor(t,n);i&&!("get"in i?!t.__esModule:i.writable||i.configurable)||(i={enumerable:!0,get:function(){return t[n]}}),Object.defineProperty(e,r,i)}:function(e,t,n,r){void 0===r&&(r=n),e[r]=t[n]};function b(e,t){for(var n in e)"default"===n||Object.prototype.hasOwnProperty.call(t,n)||f(t,e,n)}function g(e){var t="function"==typeof Symbol&&Symbol.iterator,n=t&&e[t],r=0;if(n)return n.call(e);if(e&&"number"==typeof e.length)return{next:function(){return e&&r>=e.length&&(e=void 0),{value:e&&e[r++],done:!e}}};throw new TypeError(t?"Object is not iterable.":"Symbol.iterator is not defined.")}function v(e,t){var n="function"==typeof Symbol&&e[Symbol.iterator];if(!n)return e;var r,i,a=n.call(e),s=[];try{for(;(void 0===t||t-- >0)&&!(r=a.next()).done;)s.push(r.value)}catch(e){i={error:e}}finally{try{r&&!r.done&&(n=a.return)&&n.call(a)}finally{if(i)throw i.error}}return s}function K(){for(var e=[],t=0;t<arguments.length;t++)e=e.concat(v(arguments[t]));return e}function E(){for(var e=0,t=0,n=arguments.length;t<n;t++)e+=arguments[t].length;var r=Array(e),i=0;for(t=0;t<n;t++)for(var a=arguments[t],s=0,o=a.length;s<o;s++,i++)r[i]=a[s];return r}function S(e,t,n){if(n||2===arguments.length)for(var r,i=0,a=t.length;i<a;i++)!r&&i in t||(r||(r=Array.prototype.slice.call(t,0,i)),r[i]=t[i]);return e.concat(r||Array.prototype.slice.call(t))}function I(e){return this instanceof I?(this.v=e,this):new I(e)}function w(e,t,n){if(!Symbol.asyncIterator)throw new TypeError("Symbol.asyncIterator is not defined.");var r,i=n.apply(e,t||[]),a=[];return r=Object.create(("function"==typeof AsyncIterator?AsyncIterator:Object).prototype),s("next"),s("throw"),s("return",function(e){return function(t){return Promise.resolve(t).then(e,d)}}),r[Symbol.asyncIterator]=function(){return this},r;function s(e,t){i[e]&&(r[e]=function(t){return new Promise(function(n,r){a.push([e,t,n,r])>1||o(e,t)})},t&&(r[e]=t(r[e])))}function o(e,t){try{(n=i[e](t)).value instanceof I?Promise.resolve(n.value.v).then(l,d):c(a[0][2],n)}catch(e){c(a[0][3],e)}var n}function l(e){o("next",e)}function d(e){o("throw",e)}function c(e,t){e(t),a.shift(),a.length&&o(a[0][0],a[0][1])}}function k(e){var t,n;return t={},r("next"),r("throw",function(e){throw e}),r("return"),t[Symbol.iterator]=function(){return this},t;function r(r,i){t[r]=e[r]?function(t){return(n=!n)?{value:I(e[r](t)),done:!1}:i?i(t):t}:i}}function j(e){if(!Symbol.asyncIterator)throw new TypeError("Symbol.asyncIterator is not defined.");var t,n=e[Symbol.asyncIterator];return n?n.call(e):(e=g(e),t={},r("next"),r("throw"),r("return"),t[Symbol.asyncIterator]=function(){return this},t);function r(n){t[n]=e[n]&&function(t){return new Promise(function(r,i){(function(e,t,n,r){Promise.resolve(r).then(function(t){e({value:t,done:n})},t)})(r,i,(t=e[n](t)).done,t.value)})}}}function x(e,t){return Object.defineProperty?Object.defineProperty(e,"raw",{value:t}):e.raw=t,e}var T=Object.create?function(e,t){Object.defineProperty(e,"default",{enumerable:!0,value:t})}:function(e,t){e.default=t},A=function(e){return A=Object.getOwnPropertyNames||function(e){var t=[];for(var n in e)Object.prototype.hasOwnProperty.call(e,n)&&(t[t.length]=n);return t},A(e)};function O(e){if(e&&e.__esModule)return e;var t={};if(null!=e)for(var n=A(e),r=0;r<n.length;r++)"default"!==n[r]&&f(t,e,n[r]);return T(t,e),t}function D(e){return e&&e.__esModule?e:{default:e}}function C(e,t,n,r){if("a"===n&&!r)throw new TypeError("Private accessor was defined without a getter");if("function"==typeof t?e!==t||!r:!t.has(e))throw new TypeError("Cannot read private member from an object whose class did not declare it");return"m"===n?r:"a"===n?r.call(e):r?r.value:t.get(e)}function R(e,t,n,r,i){if("m"===r)throw new TypeError("Private method is not writable");if("a"===r&&!i)throw new TypeError("Private accessor was defined without a setter");if("function"==typeof t?e!==t||!i:!t.has(e))throw new TypeError("Cannot write private member to an object whose class did not declare it");return"a"===r?i.call(e,n):i?i.value=n:t.set(e,n),n}function P(e,t){if(null===t||"object"!=typeof t&&"function"!=typeof t)throw new TypeError("Cannot use 'in' operator on non-object");return"function"==typeof e?t===e:e.has(t)}function M(e,t,n){if(null!=t){if("object"!=typeof t&&"function"!=typeof t)throw new TypeError("Object expected.");var r,i;if(n){if(!Symbol.asyncDispose)throw new TypeError("Symbol.asyncDispose is not defined.");r=t[Symbol.asyncDispose]}if(void 0===r){if(!Symbol.dispose)throw new TypeError("Symbol.dispose is not defined.");r=t[Symbol.dispose],n&&(i=r)}if("function"!=typeof r)throw new TypeError("Object not disposable.");i&&(r=function(){try{i.call(this)}catch(e){return Promise.reject(e)}}),e.stack.push({value:t,dispose:r,async:n})}else n&&e.stack.push({async:!0});return t}var N="function"==typeof SuppressedError?SuppressedError:function(e,t,n){var r=new Error(n);return r.name="SuppressedError",r.error=e,r.suppressed=t,r};function L(e){function t(t){e.error=e.hasError?new N(t,e.error,"An error was suppressed during disposal."):t,e.hasError=!0}var n,r=0;return function i(){for(;n=e.stack.pop();)try{if(!n.async&&1===r)return r=0,e.stack.push(n),Promise.resolve().then(i);if(n.dispose){var a=n.dispose.call(n.value);if(n.async)return r|=2,Promise.resolve(a).then(i,function(e){return t(e),i()})}else r|=1}catch(e){t(e)}if(1===r)return e.hasError?Promise.reject(e.error):Promise.resolve();if(e.hasError)throw e.error}()}function J(e,t){return"string"==typeof e&&/^\.\.?\//.test(e)?e.replace(/\.(tsx)$|((?:\.d)?)((?:\.[^./]+?)?)\.([cm]?)ts$/i,function(e,n,r,i,a){return n?t?".jsx":".js":!r||i&&a?r+i+"."+a.toLowerCase()+"js":e}):e}const _={__extends:i,__assign:a,__rest:s,__decorate:o,__param:l,__esDecorate:d,__runInitializers:c,__propKey:u,__setFunctionName:p,__metadata:h,__awaiter:y,__generator:m,__createBinding:f,__exportStar:b,__values:g,__read:v,__spread:K,__spreadArrays:E,__spreadArray:S,__await:I,__asyncGenerator:w,__asyncDelegator:k,__asyncValues:j,__makeTemplateObject:x,__importStar:O,__importDefault:D,__classPrivateFieldGet:C,__classPrivateFieldSet:R,__classPrivateFieldIn:P,__addDisposableResource:M,__disposeResources:L,__rewriteRelativeImportExtension:J}},(e,t,n)=>{"use strict";n.r(t),n.d(t,{QueueKeys:()=>r});class r{constructor(e="bull"){this.prefix=e}getKeys(e){const t={};return["","active","wait","waiting-children","paused","id","delayed","prioritized","stalled-check","completed","failed","stalled","repeat","limiter","meta","events","pc","marker","de"].forEach(n=>{t[n]=this.toKey(e,n)}),t}toKey(e,t){return`${this.getQueueQualifiedName(e)}:${t}`}getQueueQualifiedName(e){return`${this.prefix}:${e}`}}},(e,t,n)=>{"use strict";n.r(t),n.d(t,{RedisConnection:()=>p});var r=n(148),i=n(14),a=n(19),s=n.n(a),o=n(35),l=n(18),d=n(93),c=n(151);const u=["BullMQ: WARNING! Your redis options maxRetriesPerRequest must be null","and will be overridden by BullMQ."].join(" ");class p extends i.EventEmitter{constructor(e,t){if(super(),this.extraOptions=t,this.capabilities={canDoubleTimeout:!1,canBlockFor1Ms:!0},this.status="initializing",this.packageVersion=d.version,this.extraOptions=Object.assign({shared:!1,blocking:!0,skipVersionCheck:!1,skipWaitingForReady:!1},t),(0,l.isRedisInstance)(e)){if(this._client=e,this._client.options.keyPrefix)throw new Error("BullMQ: ioredis does not support ioredis prefixes, use the prefix option instead.");(0,l.isRedisCluster)(this._client)?this.opts=this._client.options.redisOptions:this.opts=this._client.options,this.checkBlockingOptions("BullMQ: Your redis options maxRetriesPerRequest must be null.",this.opts,!0)}else this.checkBlockingOptions(u,e),this.opts=Object.assign({port:6379,host:"127.0.0.1",retryStrategy:function(e){return Math.max(Math.min(Math.exp(e),2e4),1e3)}},e),this.extraOptions.blocking&&(this.opts.maxRetriesPerRequest=null);this.skipVersionCheck=(null==t?void 0:t.skipVersionCheck)||!(!this.opts||!this.opts.skipVersionCheck),this.handleClientError=e=>{this.emit("error",e)},this.handleClientClose=()=>{this.emit("close")},this.handleClientReady=()=>{this.emit("ready")},this.initializing=this.init(),this.initializing.catch(e=>this.emit("error",e))}checkBlockingOptions(e,t,n=!1){if(this.extraOptions.blocking&&t&&t.maxRetriesPerRequest){if(n)throw new Error(e);console.error(e)}}static async waitUntilReady(e){if("ready"===e.status)return;if("wait"===e.status)return e.connect();if("end"===e.status)throw new Error(o.CONNECTION_CLOSED_ERROR_MSG);let t,n,r;try{await new Promise((i,a)=>{let s;r=e=>{s=e},t=()=>{i()},n=()=>{"end"!==e.status?a(s||new Error(o.CONNECTION_CLOSED_ERROR_MSG)):s?a(s):i()},(0,l.increaseMaxListeners)(e,3),e.once("ready",t),e.on("end",n),e.once("error",r)})}finally{e.removeListener("end",n),e.removeListener("error",r),e.removeListener("ready",t),(0,l.decreaseMaxListeners)(e,3)}}get client(){return this.initializing}loadCommands(e,t){const n=t||c;for(const t in n){const r=`${n[t].name}:${e}`;this._client[r]||this._client.defineCommand(r,{numberOfKeys:n[t].keys,lua:n[t].content})}}async init(){if(!this._client){const e=this.opts,{url:t}=e,n=(0,r.__rest)(e,["url"]);this._client=t?new(s())(t,n):new(s())(n)}if((0,l.increaseMaxListeners)(this._client,3),this._client.on("error",this.handleClientError),this._client.on("close",this.handleClientClose),this._client.on("ready",this.handleClientReady),this.extraOptions.skipWaitingForReady||await p.waitUntilReady(this._client),this.loadCommands(this.packageVersion),"end"!==this._client.status){if(this.version=await this.getRedisVersion(),!0!==this.skipVersionCheck&&!this.closing){if((0,l.isRedisVersionLowerThan)(this.version,p.minimumVersion))throw new Error(`Redis version needs to be greater or equal than ${p.minimumVersion} Current: ${this.version}`);(0,l.isRedisVersionLowerThan)(this.version,p.recommendedMinimumVersion)&&console.warn(`It is highly recommended to use a minimum Redis version of ${p.recommendedMinimumVersion}\n             Current: ${this.version}`)}this.capabilities={canDoubleTimeout:!(0,l.isRedisVersionLowerThan)(this.version,"6.0.0"),canBlockFor1Ms:!(0,l.isRedisVersionLowerThan)(this.version,"7.0.8")},this.status="ready"}return this._client}async disconnect(e=!0){const t=await this.client;if("end"!==t.status){let n,r;if(!e)return t.disconnect();const i=new Promise((e,i)=>{(0,l.increaseMaxListeners)(t,2),t.once("end",e),t.once("error",i),n=e,r=i});t.disconnect();try{await i}finally{(0,l.decreaseMaxListeners)(t,2),t.removeListener("end",n),t.removeListener("error",r)}}}async reconnect(){return(await this.client).connect()}async close(e=!1){if(!this.closing){const t=this.status;this.status="closing",this.closing=!0;try{"ready"===t&&await this.initializing,this.extraOptions.shared||("initializing"==t||e?this._client.disconnect():await this._client.quit(),this._client.status="end")}catch(e){if((0,l.isNotConnectionError)(e))throw e}finally{this._client.off("error",this.handleClientError),this._client.off("close",this.handleClientClose),this._client.off("ready",this.handleClientReady),(0,l.decreaseMaxListeners)(this._client,3),this.removeAllListeners(),this.status="closed"}}}async getRedisVersion(){const e="redis_version:",t="maxmemory_policy:",n=(await this._client.info()).split(/\r?\n/);let r;for(let i=0;i<n.length;i++){if(0===n[i].indexOf(t)){const e=n[i].substr(17);"noeviction"!==e&&console.warn(`IMPORTANT! Eviction policy is ${e}. It should be "noeviction"`)}0===n[i].indexOf(e)&&(r=n[i].substr(14))}return r}get redisVersion(){return this.version}}p.minimumVersion="5.0.0",p.recommendedMinimumVersion="6.2.0"},(e,t,n)=>{"use strict";n.r(t),n.d(t,{addDelayedJob:()=>r.addDelayedJob,addJobScheduler:()=>i.addJobScheduler,addLog:()=>a.addLog,addParentJob:()=>s.addParentJob,addPrioritizedJob:()=>o.addPrioritizedJob,addRepeatableJob:()=>l.addRepeatableJob,addStandardJob:()=>d.addStandardJob,changeDelay:()=>c.changeDelay,changePriority:()=>u.changePriority,cleanJobsInSet:()=>p.cleanJobsInSet,drain:()=>h.drain,extendLock:()=>y.extendLock,extendLocks:()=>m.extendLocks,getCounts:()=>f.getCounts,getCountsPerPriority:()=>b.getCountsPerPriority,getDependencyCounts:()=>g.getDependencyCounts,getJobScheduler:()=>v.getJobScheduler,getRanges:()=>K.getRanges,getRateLimitTtl:()=>E.getRateLimitTtl,getState:()=>S.getState,getStateV2:()=>I.getStateV2,isFinished:()=>w.isFinished,isJobInList:()=>k.isJobInList,isMaxed:()=>j.isMaxed,moveJobFromActiveToWait:()=>x.moveJobFromActiveToWait,moveJobsToWait:()=>T.moveJobsToWait,moveStalledJobsToWait:()=>A.moveStalledJobsToWait,moveToActive:()=>O.moveToActive,moveToDelayed:()=>D.moveToDelayed,moveToFinished:()=>C.moveToFinished,moveToWaitingChildren:()=>R.moveToWaitingChildren,obliterate:()=>P.obliterate,paginate:()=>M.paginate,pause:()=>N.pause,promote:()=>L.promote,releaseLock:()=>J.releaseLock,removeChildDependency:()=>_.removeChildDependency,removeJob:()=>F.removeJob,removeJobScheduler:()=>V.removeJobScheduler,removeRepeatable:()=>G.removeRepeatable,removeUnprocessedChildren:()=>q.removeUnprocessedChildren,reprocessJob:()=>Y.reprocessJob,retryJob:()=>U.retryJob,saveStacktrace:()=>B.saveStacktrace,updateData:()=>W.updateData,updateJobScheduler:()=>z.updateJobScheduler,updateProgress:()=>Q.updateProgress,updateRepeatableJobMillis:()=>$.updateRepeatableJobMillis});var r=n(152),i=n(153),a=n(154),s=n(155),o=n(156),l=n(157),d=n(158),c=n(159),u=n(160),p=n(161),h=n(162),y=n(163),m=n(164),f=n(165),b=n(166),g=n(167),v=n(168),K=n(169),E=n(170),S=n(171),I=n(172),w=n(173),k=n(174),j=n(175),x=n(176),T=n(177),A=n(178),O=n(179),D=n(180),C=n(181),R=n(182),P=n(183),M=n(184),N=n(185),L=n(186),J=n(187),_=n(188),F=n(189),V=n(190),G=n(191),q=n(192),Y=n(193),U=n(194),B=n(195),W=n(196),z=n(197),Q=n(198),$=n(199)},(e,t,n)=>{"use strict";n.r(t),n.d(t,{addDelayedJob:()=>r});const r={name:"addDelayedJob",content:'--[[\n  Adds a delayed job to the queue by doing the following:\n    - Increases the job counter if needed.\n    - Creates a new job key with the job data.\n    - computes timestamp.\n    - adds to delayed zset.\n    - Emits a global event \'delayed\' if the job is delayed.\n    Input:\n      KEYS[1] \'marker\',\n      KEYS[2] \'meta\'\n      KEYS[3] \'id\'\n      KEYS[4] \'delayed\'\n      KEYS[5] \'completed\'\n      KEYS[6] events stream key\n      ARGV[1] msgpacked arguments array\n            [1]  key prefix,\n            [2]  custom id (use custom instead of one generated automatically)\n            [3]  name\n            [4]  timestamp\n            [5]  parentKey?\n          x [6]  waitChildrenKey key.\n            [7]  parent dependencies key.\n            [8]  parent? {id, queueKey}\n            [9]  repeat job key\n            [10] deduplication key\n      ARGV[2] Json stringified job data\n      ARGV[3] msgpacked options\n      Output:\n        jobId  - OK\n        -5     - Missing parent key\n]]\nlocal metaKey = KEYS[2]\nlocal idKey = KEYS[3]\nlocal delayedKey = KEYS[4]\nlocal completedKey = KEYS[5]\nlocal eventsKey = KEYS[6]\nlocal jobId\nlocal jobIdKey\nlocal rcall = redis.call\nlocal args = cmsgpack.unpack(ARGV[1])\nlocal data = ARGV[2]\nlocal parentKey = args[5]\nlocal parent = args[8]\nlocal repeatJobKey = args[9]\nlocal deduplicationKey = args[10]\nlocal parentData\n-- Includes\n--[[\n  Adds a delayed job to the queue by doing the following:\n    - Creates a new job key with the job data.\n    - adds to delayed zset.\n    - Emits a global event \'delayed\' if the job is delayed.\n]]\n-- Includes\n--[[\n  Add delay marker if needed.\n]]\n-- Includes\n--[[\n  Function to return the next delayed job timestamp.\n]]\nlocal function getNextDelayedTimestamp(delayedKey)\n  local result = rcall("ZRANGE", delayedKey, 0, 0, "WITHSCORES")\n  if #result then\n    local nextTimestamp = tonumber(result[2])\n    if nextTimestamp ~= nil then\n      return nextTimestamp / 0x1000\n    end\n  end\nend\nlocal function addDelayMarkerIfNeeded(markerKey, delayedKey)\n  local nextTimestamp = getNextDelayedTimestamp(delayedKey)\n  if nextTimestamp ~= nil then\n    -- Replace the score of the marker with the newest known\n    -- next timestamp.\n    rcall("ZADD", markerKey, nextTimestamp, "1")\n  end\nend\n--[[\n  Bake in the job id first 12 bits into the timestamp\n  to guarantee correct execution order of delayed jobs\n  (up to 4096 jobs per given timestamp or 4096 jobs apart per timestamp)\n  WARNING: Jobs that are so far apart that they wrap around will cause FIFO to fail\n]]\nlocal function getDelayedScore(delayedKey, timestamp, delay)\n  local delayedTimestamp = (delay > 0 and (tonumber(timestamp) + delay)) or tonumber(timestamp)\n  local minScore = delayedTimestamp * 0x1000\n  local maxScore = (delayedTimestamp + 1 ) * 0x1000 - 1\n  local result = rcall("ZREVRANGEBYSCORE", delayedKey, maxScore,\n    minScore, "WITHSCORES","LIMIT", 0, 1)\n  if #result then\n    local currentMaxScore = tonumber(result[2])\n    if currentMaxScore ~= nil then\n      if currentMaxScore >= maxScore then\n        return maxScore, delayedTimestamp\n      else\n        return currentMaxScore + 1, delayedTimestamp\n      end\n    end\n  end\n  return minScore, delayedTimestamp\nend\nlocal function addDelayedJob(jobId, delayedKey, eventsKey, timestamp,\n  maxEvents, markerKey, delay)\n  local score, delayedTimestamp = getDelayedScore(delayedKey, timestamp, tonumber(delay))\n  rcall("ZADD", delayedKey, score, jobId)\n  rcall("XADD", eventsKey, "MAXLEN", "~", maxEvents, "*", "event", "delayed",\n    "jobId", jobId, "delay", delayedTimestamp)\n  -- mark that a delayed job is available\n  addDelayMarkerIfNeeded(markerKey, delayedKey)\nend\n--[[\n  Function to debounce a job.\n]]\n-- Includes\n--[[\n  Function to remove job keys.\n]]\nlocal function removeJobKeys(jobKey)\n  return rcall("DEL", jobKey, jobKey .. \':logs\', jobKey .. \':dependencies\',\n    jobKey .. \':processed\', jobKey .. \':failed\', jobKey .. \':unsuccessful\')\nend\nlocal function deduplicateJob(deduplicationOpts, jobId, delayedKey, deduplicationKey, eventsKey, maxEvents,\n    prefix)\n    local deduplicationId = deduplicationOpts and deduplicationOpts[\'id\']\n    if deduplicationId then\n        local ttl = deduplicationOpts[\'ttl\']\n        if deduplicationOpts[\'replace\'] and ttl and ttl > 0 then\n            local currentDebounceJobId = rcall(\'GET\', deduplicationKey)\n            if currentDebounceJobId then\n                if rcall("ZREM", delayedKey, currentDebounceJobId) > 0 then\n                    removeJobKeys(prefix .. currentDebounceJobId)\n                    rcall("XADD", eventsKey, "*", "event", "removed", "jobId", currentDebounceJobId,\n                        "prev", "delayed")\n                    if deduplicationOpts[\'extend\'] then\n                        rcall(\'SET\', deduplicationKey, jobId, \'PX\', ttl)\n                    else\n                        rcall(\'SET\', deduplicationKey, jobId, \'KEEPTTL\')\n                    end\n                    rcall("XADD", eventsKey, "MAXLEN", "~", maxEvents, "*", "event", "deduplicated", "jobId",\n                        jobId, "deduplicationId", deduplicationId, "deduplicatedJobId", currentDebounceJobId)\n                    return\n                else\n                    return currentDebounceJobId\n                end\n            else\n                rcall(\'SET\', deduplicationKey, jobId, \'PX\', ttl)\n                return\n            end\n        else\n            local ttl = deduplicationOpts[\'ttl\']\n            local deduplicationKeyExists\n            if ttl then\n                if deduplicationOpts[\'extend\'] then\n                    local currentDebounceJobId = rcall(\'GET\', deduplicationKey)\n                    if currentDebounceJobId then\n                        rcall(\'SET\', deduplicationKey, currentDebounceJobId, \'PX\', ttl)\n                        rcall("XADD", eventsKey, "MAXLEN", "~", maxEvents, "*", "event", "debounced",\n                            "jobId", currentDebounceJobId, "debounceId", deduplicationId)\n                        rcall("XADD", eventsKey, "MAXLEN", "~", maxEvents, "*", "event", "deduplicated", "jobId",\n                            currentDebounceJobId, "deduplicationId", deduplicationId, "deduplicatedJobId", jobId)\n                        return currentDebounceJobId\n                    else\n                        rcall(\'SET\', deduplicationKey, jobId, \'PX\', ttl)\n                        return\n                    end\n                else\n                    deduplicationKeyExists = not rcall(\'SET\', deduplicationKey, jobId, \'PX\', ttl, \'NX\')\n                end\n            else\n                deduplicationKeyExists = not rcall(\'SET\', deduplicationKey, jobId, \'NX\')\n            end\n            if deduplicationKeyExists then\n                local currentDebounceJobId = rcall(\'GET\', deduplicationKey)\n                rcall("XADD", eventsKey, "MAXLEN", "~", maxEvents, "*", "event", "debounced", "jobId",\n                    currentDebounceJobId, "debounceId", deduplicationId)\n                rcall("XADD", eventsKey, "MAXLEN", "~", maxEvents, "*", "event", "deduplicated", "jobId",\n                    currentDebounceJobId, "deduplicationId", deduplicationId, "deduplicatedJobId", jobId)\n                return currentDebounceJobId\n            end\n        end\n    end\nend\n--[[\n  Function to get max events value or set by default 10000.\n]]\nlocal function getOrSetMaxEvents(metaKey)\n  local maxEvents = rcall("HGET", metaKey, "opts.maxLenEvents")\n  if not maxEvents then\n    maxEvents = 10000\n    rcall("HSET", metaKey, "opts.maxLenEvents", maxEvents)\n  end\n  return maxEvents\nend\n--[[\n  Function to handle the case when job is duplicated.\n]]\n-- Includes\n--[[\n    This function is used to update the parent\'s dependencies if the job\n    is already completed and about to be ignored. The parent must get its\n    dependencies updated to avoid the parent job being stuck forever in \n    the waiting-children state.\n]]\n-- Includes\n--[[\n  Validate and move or add dependencies to parent.\n]]\n-- Includes\n--[[\n  Validate and move parent to a wait status (waiting, delayed or prioritized)\n  if no pending dependencies.\n]]\n-- Includes\n--[[\n  Validate and move parent to a wait status (waiting, delayed or prioritized) if needed.\n]]\n-- Includes\n--[[\n  Move parent to a wait status (wait, prioritized or delayed)\n]]\n-- Includes\n--[[\n  Function to add job in target list and add marker if needed.\n]]\n-- Includes\n--[[\n  Add marker if needed when a job is available.\n]]\nlocal function addBaseMarkerIfNeeded(markerKey, isPausedOrMaxed)\n  if not isPausedOrMaxed then\n    rcall("ZADD", markerKey, 0, "0")\n  end  \nend\nlocal function addJobInTargetList(targetKey, markerKey, pushCmd, isPausedOrMaxed, jobId)\n  rcall(pushCmd, targetKey, jobId)\n  addBaseMarkerIfNeeded(markerKey, isPausedOrMaxed)\nend\n--[[\n  Function to add job considering priority.\n]]\n-- Includes\n--[[\n  Function to get priority score.\n]]\nlocal function getPriorityScore(priority, priorityCounterKey)\n  local prioCounter = rcall("INCR", priorityCounterKey)\n  return priority * 0x100000000 + prioCounter % 0x100000000\nend\nlocal function addJobWithPriority(markerKey, prioritizedKey, priority, jobId, priorityCounterKey,\n  isPausedOrMaxed)\n  local score = getPriorityScore(priority, priorityCounterKey)\n  rcall("ZADD", prioritizedKey, score, jobId)\n  addBaseMarkerIfNeeded(markerKey, isPausedOrMaxed)\nend\n--[[\n  Function to check if queue is paused or maxed\n  (since an empty list and !EXISTS are not really the same).\n]]\nlocal function isQueuePausedOrMaxed(queueMetaKey, activeKey)\n  local queueAttributes = rcall("HMGET", queueMetaKey, "paused", "concurrency")\n  if queueAttributes[1] then\n    return true\n  else\n    if queueAttributes[2] then\n      local activeCount = rcall("LLEN", activeKey)\n      return activeCount >= tonumber(queueAttributes[2])\n    end\n  end\n  return false\nend\n--[[\n  Function to check for the meta.paused key to decide if we are paused or not\n  (since an empty list and !EXISTS are not really the same).\n]]\nlocal function getTargetQueueList(queueMetaKey, activeKey, waitKey, pausedKey)\n  local queueAttributes = rcall("HMGET", queueMetaKey, "paused", "concurrency")\n  if queueAttributes[1] then\n    return pausedKey, true\n  else\n    if queueAttributes[2] then\n      local activeCount = rcall("LLEN", activeKey)\n      if activeCount >= tonumber(queueAttributes[2]) then\n        return waitKey, true\n      else\n        return waitKey, false\n      end\n    end\n  end\n  return waitKey, false\nend\nlocal function moveParentToWait(parentQueueKey, parentKey, parentId, timestamp)\n    local parentWaitKey = parentQueueKey .. ":wait"\n    local parentPausedKey = parentQueueKey .. ":paused"\n    local parentActiveKey = parentQueueKey .. ":active"\n    local parentMetaKey = parentQueueKey .. ":meta"\n    local parentMarkerKey = parentQueueKey .. ":marker"\n    local jobAttributes = rcall("HMGET", parentKey, "priority", "delay")\n    local priority = tonumber(jobAttributes[1]) or 0\n    local delay = tonumber(jobAttributes[2]) or 0\n    if delay > 0 then\n        local delayedTimestamp = tonumber(timestamp) + delay\n        local score = delayedTimestamp * 0x1000\n        local parentDelayedKey = parentQueueKey .. ":delayed"\n        rcall("ZADD", parentDelayedKey, score, parentId)\n        rcall("XADD", parentQueueKey .. ":events", "*", "event", "delayed", "jobId", parentId, "delay",\n            delayedTimestamp)\n        addDelayMarkerIfNeeded(parentMarkerKey, parentDelayedKey)\n    else\n        if priority == 0 then\n            local parentTarget, isParentPausedOrMaxed = getTargetQueueList(parentMetaKey, parentActiveKey,\n                parentWaitKey, parentPausedKey)\n            addJobInTargetList(parentTarget, parentMarkerKey, "RPUSH", isParentPausedOrMaxed, parentId)\n        else\n            local isPausedOrMaxed = isQueuePausedOrMaxed(parentMetaKey, parentActiveKey)\n            addJobWithPriority(parentMarkerKey, parentQueueKey .. ":prioritized", priority, parentId,\n                parentQueueKey .. ":pc", isPausedOrMaxed)\n        end\n        rcall("XADD", parentQueueKey .. ":events", "*", "event", "waiting", "jobId", parentId, "prev",\n            "waiting-children")\n    end\nend\nlocal function moveParentToWaitIfNeeded(parentQueueKey, parentKey, parentId, timestamp)\n  if rcall("EXISTS", parentKey) == 1 then\n    local parentWaitingChildrenKey = parentQueueKey .. ":waiting-children"\n    if rcall("ZSCORE", parentWaitingChildrenKey, parentId) then    \n      rcall("ZREM", parentWaitingChildrenKey, parentId)\n      moveParentToWait(parentQueueKey, parentKey, parentId, timestamp)\n    end\n  end\nend\nlocal function moveParentToWaitIfNoPendingDependencies(parentQueueKey, parentDependenciesKey, parentKey,\n  parentId, timestamp)\n  local doNotHavePendingDependencies = rcall("SCARD", parentDependenciesKey) == 0\n  if doNotHavePendingDependencies then\n    moveParentToWaitIfNeeded(parentQueueKey, parentKey, parentId, timestamp)\n  end\nend\nlocal function updateParentDepsIfNeeded(parentKey, parentQueueKey, parentDependenciesKey,\n  parentId, jobIdKey, returnvalue, timestamp )\n  local processedSet = parentKey .. ":processed"\n  rcall("HSET", processedSet, jobIdKey, returnvalue)\n  moveParentToWaitIfNoPendingDependencies(parentQueueKey, parentDependenciesKey, parentKey, parentId, timestamp)\nend\nlocal function updateExistingJobsParent(parentKey, parent, parentData,\n                                        parentDependenciesKey, completedKey,\n                                        jobIdKey, jobId, timestamp)\n    if parentKey ~= nil then\n        if rcall("ZSCORE", completedKey, jobId) then\n            local returnvalue = rcall("HGET", jobIdKey, "returnvalue")\n            updateParentDepsIfNeeded(parentKey, parent[\'queueKey\'],\n                                     parentDependenciesKey, parent[\'id\'],\n                                     jobIdKey, returnvalue, timestamp)\n        else\n            if parentDependenciesKey ~= nil then\n                rcall("SADD", parentDependenciesKey, jobIdKey)\n            end\n        end\n        rcall("HMSET", jobIdKey, "parentKey", parentKey, "parent", parentData)\n    end\nend\nlocal function handleDuplicatedJob(jobKey, jobId, currentParentKey, currentParent,\n  parentData, parentDependenciesKey, completedKey, eventsKey, maxEvents, timestamp)\n  local existedParentKey = rcall("HGET", jobKey, "parentKey")\n  if not existedParentKey or existedParentKey == currentParentKey then\n    updateExistingJobsParent(currentParentKey, currentParent, parentData,\n      parentDependenciesKey, completedKey, jobKey,\n      jobId, timestamp)\n  else\n    if currentParentKey ~= nil and currentParentKey ~= existedParentKey\n      and (rcall("EXISTS", existedParentKey) == 1) then\n      return -7\n    end\n  end\n  rcall("XADD", eventsKey, "MAXLEN", "~", maxEvents, "*", "event",\n    "duplicated", "jobId", jobId)\n  return jobId .. "" -- convert to string\nend\n--[[\n  Function to store a job\n]]\nlocal function storeJob(eventsKey, jobIdKey, jobId, name, data, opts, timestamp,\n                        parentKey, parentData, repeatJobKey)\n    local jsonOpts = cjson.encode(opts)\n    local delay = opts[\'delay\'] or 0\n    local priority = opts[\'priority\'] or 0\n    local debounceId = opts[\'de\'] and opts[\'de\'][\'id\']\n    local optionalValues = {}\n    if parentKey ~= nil then\n        table.insert(optionalValues, "parentKey")\n        table.insert(optionalValues, parentKey)\n        table.insert(optionalValues, "parent")\n        table.insert(optionalValues, parentData)\n    end\n    if repeatJobKey then\n        table.insert(optionalValues, "rjk")\n        table.insert(optionalValues, repeatJobKey)\n    end\n    if debounceId then\n        table.insert(optionalValues, "deid")\n        table.insert(optionalValues, debounceId)\n    end\n    rcall("HMSET", jobIdKey, "name", name, "data", data, "opts", jsonOpts,\n          "timestamp", timestamp, "delay", delay, "priority", priority,\n          unpack(optionalValues))\n    rcall("XADD", eventsKey, "*", "event", "added", "jobId", jobId, "name", name)\n    return delay, priority\nend\nif parentKey ~= nil then\n    if rcall("EXISTS", parentKey) ~= 1 then return -5 end\n    parentData = cjson.encode(parent)\nend\nlocal jobCounter = rcall("INCR", idKey)\nlocal maxEvents = getOrSetMaxEvents(metaKey)\nlocal opts = cmsgpack.unpack(ARGV[3])\nlocal parentDependenciesKey = args[7]\nlocal timestamp = args[4]\nif args[2] == "" then\n    jobId = jobCounter\n    jobIdKey = args[1] .. jobId\nelse\n    jobId = args[2]\n    jobIdKey = args[1] .. jobId\n    if rcall("EXISTS", jobIdKey) == 1 then\n        return handleDuplicatedJob(jobIdKey, jobId, parentKey, parent,\n            parentData, parentDependenciesKey, completedKey, eventsKey,\n            maxEvents, timestamp)\n    end\nend\nlocal deduplicationJobId = deduplicateJob(opts[\'de\'], jobId, delayedKey, deduplicationKey,\n  eventsKey, maxEvents, args[1])\nif deduplicationJobId then\n  return deduplicationJobId\nend\nlocal delay, priority = storeJob(eventsKey, jobIdKey, jobId, args[3], ARGV[2],\n    opts, timestamp, parentKey, parentData, repeatJobKey)\naddDelayedJob(jobId, delayedKey, eventsKey, timestamp, maxEvents, KEYS[1], delay)\n-- Check if this job is a child of another job, if so add it to the parents dependencies\nif parentDependenciesKey ~= nil then\n    rcall("SADD", parentDependenciesKey, jobIdKey)\nend\nreturn jobId .. "" -- convert to string\n',keys:6}},(e,t,n)=>{"use strict";n.r(t),n.d(t,{addJobScheduler:()=>r});const r={name:"addJobScheduler",content:'--[[\n  Adds a job scheduler, i.e. a job factory that creates jobs based on a given schedule (repeat options).\n    Input:\n      KEYS[1]  \'repeat\' key\n      KEYS[2]  \'delayed\' key\n      KEYS[3]  \'wait\' key\n      KEYS[4]  \'paused\' key\n      KEYS[5]  \'meta\' key\n      KEYS[6]  \'prioritized\' key\n      KEYS[7]  \'marker\' key\n      KEYS[8]  \'id\' key\n      KEYS[9]  \'events\' key\n      KEYS[10] \'pc\' priority counter\n      KEYS[11] \'active\' key\n      ARGV[1] next milliseconds\n      ARGV[2] msgpacked options\n            [1]  name\n            [2]  tz?\n            [3]  patten?\n            [4]  endDate?\n            [5]  every?\n      ARGV[3] jobs scheduler id\n      ARGV[4] Json stringified template data\n      ARGV[5] mspacked template opts\n      ARGV[6] msgpacked delayed opts\n      ARGV[7] timestamp\n      ARGV[8] prefix key\n      ARGV[9] producer key\n      Output:\n        repeatableKey  - OK\n]]\nlocal rcall = redis.call\nlocal repeatKey = KEYS[1]\nlocal delayedKey = KEYS[2]\nlocal waitKey = KEYS[3]\nlocal pausedKey = KEYS[4]\nlocal metaKey = KEYS[5]\nlocal prioritizedKey = KEYS[6]\nlocal eventsKey = KEYS[9]\nlocal nextMillis = ARGV[1]\nlocal jobSchedulerId = ARGV[3]\nlocal templateOpts = cmsgpack.unpack(ARGV[5])\nlocal prefixKey = ARGV[8]\n-- Includes\n--[[\n  Add delay marker if needed.\n]]\n-- Includes\n--[[\n  Adds a delayed job to the queue by doing the following:\n    - Creates a new job key with the job data.\n    - adds to delayed zset.\n    - Emits a global event \'delayed\' if the job is delayed.\n]]\n-- Includes\n--[[\n  Add delay marker if needed.\n]]\n-- Includes\n--[[\n  Function to return the next delayed job timestamp.\n]]\nlocal function getNextDelayedTimestamp(delayedKey)\n  local result = rcall("ZRANGE", delayedKey, 0, 0, "WITHSCORES")\n  if #result then\n    local nextTimestamp = tonumber(result[2])\n    if nextTimestamp ~= nil then\n      return nextTimestamp / 0x1000\n    end\n  end\nend\nlocal function addDelayMarkerIfNeeded(markerKey, delayedKey)\n  local nextTimestamp = getNextDelayedTimestamp(delayedKey)\n  if nextTimestamp ~= nil then\n    -- Replace the score of the marker with the newest known\n    -- next timestamp.\n    rcall("ZADD", markerKey, nextTimestamp, "1")\n  end\nend\n--[[\n  Bake in the job id first 12 bits into the timestamp\n  to guarantee correct execution order of delayed jobs\n  (up to 4096 jobs per given timestamp or 4096 jobs apart per timestamp)\n  WARNING: Jobs that are so far apart that they wrap around will cause FIFO to fail\n]]\nlocal function getDelayedScore(delayedKey, timestamp, delay)\n  local delayedTimestamp = (delay > 0 and (tonumber(timestamp) + delay)) or tonumber(timestamp)\n  local minScore = delayedTimestamp * 0x1000\n  local maxScore = (delayedTimestamp + 1 ) * 0x1000 - 1\n  local result = rcall("ZREVRANGEBYSCORE", delayedKey, maxScore,\n    minScore, "WITHSCORES","LIMIT", 0, 1)\n  if #result then\n    local currentMaxScore = tonumber(result[2])\n    if currentMaxScore ~= nil then\n      if currentMaxScore >= maxScore then\n        return maxScore, delayedTimestamp\n      else\n        return currentMaxScore + 1, delayedTimestamp\n      end\n    end\n  end\n  return minScore, delayedTimestamp\nend\nlocal function addDelayedJob(jobId, delayedKey, eventsKey, timestamp,\n  maxEvents, markerKey, delay)\n  local score, delayedTimestamp = getDelayedScore(delayedKey, timestamp, tonumber(delay))\n  rcall("ZADD", delayedKey, score, jobId)\n  rcall("XADD", eventsKey, "MAXLEN", "~", maxEvents, "*", "event", "delayed",\n    "jobId", jobId, "delay", delayedTimestamp)\n  -- mark that a delayed job is available\n  addDelayMarkerIfNeeded(markerKey, delayedKey)\nend\n--[[\n  Function to add job considering priority.\n]]\n-- Includes\n--[[\n  Add marker if needed when a job is available.\n]]\nlocal function addBaseMarkerIfNeeded(markerKey, isPausedOrMaxed)\n  if not isPausedOrMaxed then\n    rcall("ZADD", markerKey, 0, "0")\n  end  \nend\n--[[\n  Function to get priority score.\n]]\nlocal function getPriorityScore(priority, priorityCounterKey)\n  local prioCounter = rcall("INCR", priorityCounterKey)\n  return priority * 0x100000000 + prioCounter % 0x100000000\nend\nlocal function addJobWithPriority(markerKey, prioritizedKey, priority, jobId, priorityCounterKey,\n  isPausedOrMaxed)\n  local score = getPriorityScore(priority, priorityCounterKey)\n  rcall("ZADD", prioritizedKey, score, jobId)\n  addBaseMarkerIfNeeded(markerKey, isPausedOrMaxed)\nend\n--[[\n  Function to check for the meta.paused key to decide if we are paused or not\n  (since an empty list and !EXISTS are not really the same).\n]]\nlocal function isQueuePaused(queueMetaKey)\n  return rcall("HEXISTS", queueMetaKey, "paused") == 1\nend\n--[[\n  Function to store a job\n]]\nlocal function storeJob(eventsKey, jobIdKey, jobId, name, data, opts, timestamp,\n                        parentKey, parentData, repeatJobKey)\n    local jsonOpts = cjson.encode(opts)\n    local delay = opts[\'delay\'] or 0\n    local priority = opts[\'priority\'] or 0\n    local debounceId = opts[\'de\'] and opts[\'de\'][\'id\']\n    local optionalValues = {}\n    if parentKey ~= nil then\n        table.insert(optionalValues, "parentKey")\n        table.insert(optionalValues, parentKey)\n        table.insert(optionalValues, "parent")\n        table.insert(optionalValues, parentData)\n    end\n    if repeatJobKey then\n        table.insert(optionalValues, "rjk")\n        table.insert(optionalValues, repeatJobKey)\n    end\n    if debounceId then\n        table.insert(optionalValues, "deid")\n        table.insert(optionalValues, debounceId)\n    end\n    rcall("HMSET", jobIdKey, "name", name, "data", data, "opts", jsonOpts,\n          "timestamp", timestamp, "delay", delay, "priority", priority,\n          unpack(optionalValues))\n    rcall("XADD", eventsKey, "*", "event", "added", "jobId", jobId, "name", name)\n    return delay, priority\nend\n--[[\n  Function to check for the meta.paused key to decide if we are paused or not\n  (since an empty list and !EXISTS are not really the same).\n]]\nlocal function getTargetQueueList(queueMetaKey, activeKey, waitKey, pausedKey)\n  local queueAttributes = rcall("HMGET", queueMetaKey, "paused", "concurrency")\n  if queueAttributes[1] then\n    return pausedKey, true\n  else\n    if queueAttributes[2] then\n      local activeCount = rcall("LLEN", activeKey)\n      if activeCount >= tonumber(queueAttributes[2]) then\n        return waitKey, true\n      else\n        return waitKey, false\n      end\n    end\n  end\n  return waitKey, false\nend\n--[[\n  Function to add job in target list and add marker if needed.\n]]\n-- Includes\nlocal function addJobInTargetList(targetKey, markerKey, pushCmd, isPausedOrMaxed, jobId)\n  rcall(pushCmd, targetKey, jobId)\n  addBaseMarkerIfNeeded(markerKey, isPausedOrMaxed)\nend\nlocal function addJobFromScheduler(jobKey, jobId, rawOpts, waitKey, pausedKey, activeKey, metaKey, \n  prioritizedKey, priorityCounter, delayedKey, markerKey, eventsKey, name, maxEvents, timestamp,\n  data, jobSchedulerId)\n  local opts = cmsgpack.unpack(rawOpts)\n  local delay, priority = storeJob(eventsKey, jobKey, jobId, name, data,\n    opts, timestamp, nil, nil, jobSchedulerId)\n  if delay ~= 0 then\n    addDelayedJob(jobId, delayedKey, eventsKey, timestamp, maxEvents, markerKey, delay)\n  else\n    local target, isPausedOrMaxed = getTargetQueueList(metaKey, activeKey, waitKey, pausedKey)\n    -- Standard or priority add\n    if priority == 0 then\n      local pushCmd = opts[\'lifo\'] and \'RPUSH\' or \'LPUSH\'\n      addJobInTargetList(target, markerKey, pushCmd, isPausedOrMaxed, jobId)\n    else\n      -- Priority add\n      addJobWithPriority(markerKey, prioritizedKey, priority, jobId, priorityCounter, isPausedOrMaxed)\n    end\n    -- Emit waiting event\n    rcall("XADD", eventsKey, "MAXLEN", "~", maxEvents,  "*", "event", "waiting", "jobId", jobId)\n  end\nend\n--[[\n  Function to get max events value or set by default 10000.\n]]\nlocal function getOrSetMaxEvents(metaKey)\n  local maxEvents = rcall("HGET", metaKey, "opts.maxLenEvents")\n  if not maxEvents then\n    maxEvents = 10000\n    rcall("HSET", metaKey, "opts.maxLenEvents", maxEvents)\n  end\n  return maxEvents\nend\n--[[\n  Function to remove job.\n]]\n-- Includes\n--[[\n  Function to remove deduplication key if needed\n  when a job is being removed.\n]]\nlocal function removeDeduplicationKeyIfNeededOnRemoval(prefixKey,\n  jobKey, jobId)\n  local deduplicationId = rcall("HGET", jobKey, "deid")\n  if deduplicationId then\n    local deduplicationKey = prefixKey .. "de:" .. deduplicationId\n    local currentJobId = rcall(\'GET\', deduplicationKey)\n    if currentJobId and currentJobId == jobId then\n      return rcall("DEL", deduplicationKey)\n    end\n  end\nend\n--[[\n  Function to remove job keys.\n]]\nlocal function removeJobKeys(jobKey)\n  return rcall("DEL", jobKey, jobKey .. \':logs\', jobKey .. \':dependencies\',\n    jobKey .. \':processed\', jobKey .. \':failed\', jobKey .. \':unsuccessful\')\nend\n--[[\n  Check if this job has a parent. If so we will just remove it from\n  the parent child list, but if it is the last child we should move the parent to "wait/paused"\n  which requires code from "moveToFinished"\n]]\n-- Includes\n--[[\n  Functions to destructure job key.\n  Just a bit of warning, these functions may be a bit slow and affect performance significantly.\n]]\nlocal getJobIdFromKey = function (jobKey)\n  return string.match(jobKey, ".*:(.*)")\nend\nlocal getJobKeyPrefix = function (jobKey, jobId)\n  return string.sub(jobKey, 0, #jobKey - #jobId)\nend\nlocal function _moveParentToWait(parentPrefix, parentId, emitEvent)\n  local parentTarget, isPausedOrMaxed = getTargetQueueList(parentPrefix .. "meta", parentPrefix .. "active",\n    parentPrefix .. "wait", parentPrefix .. "paused")\n  addJobInTargetList(parentTarget, parentPrefix .. "marker", "RPUSH", isPausedOrMaxed, parentId)\n  if emitEvent then\n    local parentEventStream = parentPrefix .. "events"\n    rcall("XADD", parentEventStream, "*", "event", "waiting", "jobId", parentId, "prev", "waiting-children")\n  end\nend\nlocal function removeParentDependencyKey(jobKey, hard, parentKey, baseKey, debounceId)\n  if parentKey then\n    local parentDependenciesKey = parentKey .. ":dependencies"\n    local result = rcall("SREM", parentDependenciesKey, jobKey)\n    if result > 0 then\n      local pendingDependencies = rcall("SCARD", parentDependenciesKey)\n      if pendingDependencies == 0 then\n        local parentId = getJobIdFromKey(parentKey)\n        local parentPrefix = getJobKeyPrefix(parentKey, parentId)\n        local numRemovedElements = rcall("ZREM", parentPrefix .. "waiting-children", parentId)\n        if numRemovedElements == 1 then\n          if hard then -- remove parent in same queue\n            if parentPrefix == baseKey then\n              removeParentDependencyKey(parentKey, hard, nil, baseKey, nil)\n              removeJobKeys(parentKey)\n              if debounceId then\n                rcall("DEL", parentPrefix .. "de:" .. debounceId)\n              end\n            else\n              _moveParentToWait(parentPrefix, parentId)\n            end\n          else\n            _moveParentToWait(parentPrefix, parentId, true)\n          end\n        end\n      end\n      return true\n    end\n  else\n    local parentAttributes = rcall("HMGET", jobKey, "parentKey", "deid")\n    local missedParentKey = parentAttributes[1]\n    if( (type(missedParentKey) == "string") and missedParentKey ~= ""\n      and (rcall("EXISTS", missedParentKey) == 1)) then\n      local parentDependenciesKey = missedParentKey .. ":dependencies"\n      local result = rcall("SREM", parentDependenciesKey, jobKey)\n      if result > 0 then\n        local pendingDependencies = rcall("SCARD", parentDependenciesKey)\n        if pendingDependencies == 0 then\n          local parentId = getJobIdFromKey(missedParentKey)\n          local parentPrefix = getJobKeyPrefix(missedParentKey, parentId)\n          local numRemovedElements = rcall("ZREM", parentPrefix .. "waiting-children", parentId)\n          if numRemovedElements == 1 then\n            if hard then\n              if parentPrefix == baseKey then\n                removeParentDependencyKey(missedParentKey, hard, nil, baseKey, nil)\n                removeJobKeys(missedParentKey)\n                if parentAttributes[2] then\n                  rcall("DEL", parentPrefix .. "de:" .. parentAttributes[2])\n                end\n              else\n                _moveParentToWait(parentPrefix, parentId)\n              end\n            else\n              _moveParentToWait(parentPrefix, parentId, true)\n            end\n          end\n        end\n        return true\n      end\n    end\n  end\n  return false\nend\nlocal function removeJob(jobId, hard, baseKey, shouldRemoveDeduplicationKey)\n  local jobKey = baseKey .. jobId\n  removeParentDependencyKey(jobKey, hard, nil, baseKey)\n  if shouldRemoveDeduplicationKey then\n    removeDeduplicationKeyIfNeededOnRemoval(baseKey, jobKey, jobId)\n  end\n  removeJobKeys(jobKey)\nend\n--[[\n  Function to store a job scheduler\n]]\nlocal function storeJobScheduler(schedulerId, schedulerKey, repeatKey, nextMillis, opts,\n  templateData, templateOpts)\n  rcall("ZADD", repeatKey, nextMillis, schedulerId)\n  local optionalValues = {}\n  if opts[\'tz\'] then\n    table.insert(optionalValues, "tz")\n    table.insert(optionalValues, opts[\'tz\'])\n  end\n  if opts[\'limit\'] then\n    table.insert(optionalValues, "limit")\n    table.insert(optionalValues, opts[\'limit\'])\n  end\n  if opts[\'pattern\'] then\n    table.insert(optionalValues, "pattern")\n    table.insert(optionalValues, opts[\'pattern\'])\n  end\n  if opts[\'endDate\'] then\n    table.insert(optionalValues, "endDate")\n    table.insert(optionalValues, opts[\'endDate\'])\n  end\n  if opts[\'every\'] then\n    table.insert(optionalValues, "every")\n    table.insert(optionalValues, opts[\'every\'])\n  end\n  if opts[\'offset\'] then\n    table.insert(optionalValues, "offset")\n    table.insert(optionalValues, opts[\'offset\'])\n  end\n  local jsonTemplateOpts = cjson.encode(templateOpts)\n  if jsonTemplateOpts and jsonTemplateOpts ~= \'{}\' then\n    table.insert(optionalValues, "opts")\n    table.insert(optionalValues, jsonTemplateOpts)\n  end\n  if templateData and templateData ~= \'{}\' then\n    table.insert(optionalValues, "data")\n    table.insert(optionalValues, templateData)\n  end\n  rcall("DEL", schedulerKey) -- remove all attributes and then re-insert new ones\n  rcall("HMSET", schedulerKey, "name", opts[\'name\'], "ic", 1, unpack(optionalValues))\nend\n-- If we are overriding a repeatable job we must delete the delayed job for\n-- the next iteration.\nlocal schedulerKey = repeatKey .. ":" .. jobSchedulerId\nlocal nextDelayedJobKey = schedulerKey .. ":" .. nextMillis\nlocal nextDelayedJobId = "repeat:" .. jobSchedulerId .. ":" .. nextMillis\nlocal maxEvents = getOrSetMaxEvents(metaKey)\nlocal function removeJobFromScheduler(prefixKey, delayedKey, prioritizedKey, waitKey, pausedKey, jobId,\n    metaKey, eventsKey)\n    if rcall("ZSCORE", delayedKey, jobId) then\n        removeJob(jobId, true, prefixKey, true --[[remove debounce key]] )\n        rcall("ZREM", delayedKey, jobId)\n        return true\n    elseif rcall("ZSCORE", prioritizedKey, jobId) then\n        removeJob(jobId, true, prefixKey, true --[[remove debounce key]] )\n        rcall("ZREM", prioritizedKey, jobId)\n        return true\n    else\n        local pausedOrWaitKey = waitKey\n        if isQueuePaused(metaKey) then\n            pausedOrWaitKey = pausedKey\n        end\n        if rcall("LREM", pausedOrWaitKey, 1, jobId) > 0 then\n            removeJob(jobId, true, prefixKey, true --[[remove debounce key]] )\n            return true\n        end\n    end\n    return false\nend\nif rcall("EXISTS", nextDelayedJobKey) == 1 then\n    if not removeJobFromScheduler(prefixKey, delayedKey, prioritizedKey, waitKey, pausedKey,\n        nextDelayedJobId, metaKey, eventsKey) then\n        rcall("XADD", eventsKey, "MAXLEN", "~", maxEvents, "*", "event",\n            "duplicated", "jobId", nextDelayedJobId)\n        return nextDelayedJobId .. "" -- convert to string\n    end\nend\nlocal prevMillis = rcall("ZSCORE", repeatKey, jobSchedulerId)\nif prevMillis then    \n    local currentJobId = "repeat:" .. jobSchedulerId .. ":" .. prevMillis\n    local currentDelayedJobKey = schedulerKey .. ":" .. prevMillis\n    if currentJobId ~= nextDelayedJobId and rcall("EXISTS", currentDelayedJobKey) == 1 then\n        removeJobFromScheduler(prefixKey, delayedKey, prioritizedKey, waitKey, pausedKey,\n            currentJobId, metaKey, eventsKey)\n    end\nend\nlocal schedulerOpts = cmsgpack.unpack(ARGV[2])\nstoreJobScheduler(jobSchedulerId, schedulerKey, repeatKey, nextMillis, schedulerOpts, ARGV[4], templateOpts)\nrcall("INCR", KEYS[8])\naddJobFromScheduler(nextDelayedJobKey, nextDelayedJobId, ARGV[6], waitKey, pausedKey,\n    KEYS[11], metaKey, prioritizedKey, KEYS[10], delayedKey, KEYS[7], eventsKey,\n    schedulerOpts[\'name\'], maxEvents, ARGV[7], ARGV[4], jobSchedulerId)\nif ARGV[9] ~= "" then\n    rcall("HSET", ARGV[9], "nrjid", nextDelayedJobId)\nend\nreturn nextDelayedJobId .. "" -- convert to string\n',keys:11}},(e,t,n)=>{"use strict";n.r(t),n.d(t,{addLog:()=>r});const r={name:"addLog",content:'--[[\n  Add job log\n  Input:\n    KEYS[1] job id key\n    KEYS[2] job logs key\n    ARGV[1] id\n    ARGV[2] log\n    ARGV[3] keepLogs\n  Output:\n    -1 - Missing job.\n]]\nlocal rcall = redis.call\nif rcall("EXISTS", KEYS[1]) == 1 then -- // Make sure job exists\n  local logCount = rcall("RPUSH", KEYS[2], ARGV[2])\n  if ARGV[3] ~= \'\' then\n    local keepLogs = tonumber(ARGV[3])\n    rcall("LTRIM", KEYS[2], -keepLogs, -1)\n    return math.min(keepLogs, logCount)\n  end\n  return logCount\nelse\n  return -1\nend\n',keys:2}},(e,t,n)=>{"use strict";n.r(t),n.d(t,{addParentJob:()=>r});const r={name:"addParentJob",content:'--[[\n  Adds a parent job to the queue by doing the following:\n    - Increases the job counter if needed.\n    - Creates a new job key with the job data.\n    - adds the job to the waiting-children zset\n    Input:\n      KEYS[1] \'meta\'\n      KEYS[2] \'id\'\n      KEYS[3] \'delayed\'\n      KEYS[4] \'completed\'\n      KEYS[5] events stream key\n      ARGV[1] msgpacked arguments array\n            [1]  key prefix,\n            [2]  custom id (will not generate one automatically)\n            [3]  name\n            [4]  timestamp\n            [5]  parentKey?\n            [6]  waitChildrenKey key.\n            [7]  parent dependencies key.\n            [8]  parent? {id, queueKey}\n            [9]  repeat job key\n            [10] deduplication key\n      ARGV[2] Json stringified job data\n      ARGV[3] msgpacked options\n      Output:\n        jobId  - OK\n        -5     - Missing parent key\n]]\nlocal metaKey = KEYS[1]\nlocal idKey = KEYS[2]\nlocal completedKey = KEYS[4]\nlocal eventsKey = KEYS[5]\nlocal jobId\nlocal jobIdKey\nlocal rcall = redis.call\nlocal args = cmsgpack.unpack(ARGV[1])\nlocal data = ARGV[2]\nlocal opts = cmsgpack.unpack(ARGV[3])\nlocal parentKey = args[5]\nlocal parent = args[8]\nlocal repeatJobKey = args[9]\nlocal deduplicationKey = args[10]\nlocal parentData\n-- Includes\n--[[\n  Function to debounce a job.\n]]\n-- Includes\n--[[\n  Function to remove job keys.\n]]\nlocal function removeJobKeys(jobKey)\n  return rcall("DEL", jobKey, jobKey .. \':logs\', jobKey .. \':dependencies\',\n    jobKey .. \':processed\', jobKey .. \':failed\', jobKey .. \':unsuccessful\')\nend\nlocal function deduplicateJob(deduplicationOpts, jobId, delayedKey, deduplicationKey, eventsKey, maxEvents,\n    prefix)\n    local deduplicationId = deduplicationOpts and deduplicationOpts[\'id\']\n    if deduplicationId then\n        local ttl = deduplicationOpts[\'ttl\']\n        if deduplicationOpts[\'replace\'] and ttl and ttl > 0 then\n            local currentDebounceJobId = rcall(\'GET\', deduplicationKey)\n            if currentDebounceJobId then\n                if rcall("ZREM", delayedKey, currentDebounceJobId) > 0 then\n                    removeJobKeys(prefix .. currentDebounceJobId)\n                    rcall("XADD", eventsKey, "*", "event", "removed", "jobId", currentDebounceJobId,\n                        "prev", "delayed")\n                    if deduplicationOpts[\'extend\'] then\n                        rcall(\'SET\', deduplicationKey, jobId, \'PX\', ttl)\n                    else\n                        rcall(\'SET\', deduplicationKey, jobId, \'KEEPTTL\')\n                    end\n                    rcall("XADD", eventsKey, "MAXLEN", "~", maxEvents, "*", "event", "deduplicated", "jobId",\n                        jobId, "deduplicationId", deduplicationId, "deduplicatedJobId", currentDebounceJobId)\n                    return\n                else\n                    return currentDebounceJobId\n                end\n            else\n                rcall(\'SET\', deduplicationKey, jobId, \'PX\', ttl)\n                return\n            end\n        else\n            local ttl = deduplicationOpts[\'ttl\']\n            local deduplicationKeyExists\n            if ttl then\n                if deduplicationOpts[\'extend\'] then\n                    local currentDebounceJobId = rcall(\'GET\', deduplicationKey)\n                    if currentDebounceJobId then\n                        rcall(\'SET\', deduplicationKey, currentDebounceJobId, \'PX\', ttl)\n                        rcall("XADD", eventsKey, "MAXLEN", "~", maxEvents, "*", "event", "debounced",\n                            "jobId", currentDebounceJobId, "debounceId", deduplicationId)\n                        rcall("XADD", eventsKey, "MAXLEN", "~", maxEvents, "*", "event", "deduplicated", "jobId",\n                            currentDebounceJobId, "deduplicationId", deduplicationId, "deduplicatedJobId", jobId)\n                        return currentDebounceJobId\n                    else\n                        rcall(\'SET\', deduplicationKey, jobId, \'PX\', ttl)\n                        return\n                    end\n                else\n                    deduplicationKeyExists = not rcall(\'SET\', deduplicationKey, jobId, \'PX\', ttl, \'NX\')\n                end\n            else\n                deduplicationKeyExists = not rcall(\'SET\', deduplicationKey, jobId, \'NX\')\n            end\n            if deduplicationKeyExists then\n                local currentDebounceJobId = rcall(\'GET\', deduplicationKey)\n                rcall("XADD", eventsKey, "MAXLEN", "~", maxEvents, "*", "event", "debounced", "jobId",\n                    currentDebounceJobId, "debounceId", deduplicationId)\n                rcall("XADD", eventsKey, "MAXLEN", "~", maxEvents, "*", "event", "deduplicated", "jobId",\n                    currentDebounceJobId, "deduplicationId", deduplicationId, "deduplicatedJobId", jobId)\n                return currentDebounceJobId\n            end\n        end\n    end\nend\n--[[\n  Function to get max events value or set by default 10000.\n]]\nlocal function getOrSetMaxEvents(metaKey)\n  local maxEvents = rcall("HGET", metaKey, "opts.maxLenEvents")\n  if not maxEvents then\n    maxEvents = 10000\n    rcall("HSET", metaKey, "opts.maxLenEvents", maxEvents)\n  end\n  return maxEvents\nend\n--[[\n  Function to handle the case when job is duplicated.\n]]\n-- Includes\n--[[\n    This function is used to update the parent\'s dependencies if the job\n    is already completed and about to be ignored. The parent must get its\n    dependencies updated to avoid the parent job being stuck forever in \n    the waiting-children state.\n]]\n-- Includes\n--[[\n  Validate and move or add dependencies to parent.\n]]\n-- Includes\n--[[\n  Validate and move parent to a wait status (waiting, delayed or prioritized)\n  if no pending dependencies.\n]]\n-- Includes\n--[[\n  Validate and move parent to a wait status (waiting, delayed or prioritized) if needed.\n]]\n-- Includes\n--[[\n  Move parent to a wait status (wait, prioritized or delayed)\n]]\n-- Includes\n--[[\n  Add delay marker if needed.\n]]\n-- Includes\n--[[\n  Function to return the next delayed job timestamp.\n]]\nlocal function getNextDelayedTimestamp(delayedKey)\n  local result = rcall("ZRANGE", delayedKey, 0, 0, "WITHSCORES")\n  if #result then\n    local nextTimestamp = tonumber(result[2])\n    if nextTimestamp ~= nil then\n      return nextTimestamp / 0x1000\n    end\n  end\nend\nlocal function addDelayMarkerIfNeeded(markerKey, delayedKey)\n  local nextTimestamp = getNextDelayedTimestamp(delayedKey)\n  if nextTimestamp ~= nil then\n    -- Replace the score of the marker with the newest known\n    -- next timestamp.\n    rcall("ZADD", markerKey, nextTimestamp, "1")\n  end\nend\n--[[\n  Function to add job in target list and add marker if needed.\n]]\n-- Includes\n--[[\n  Add marker if needed when a job is available.\n]]\nlocal function addBaseMarkerIfNeeded(markerKey, isPausedOrMaxed)\n  if not isPausedOrMaxed then\n    rcall("ZADD", markerKey, 0, "0")\n  end  \nend\nlocal function addJobInTargetList(targetKey, markerKey, pushCmd, isPausedOrMaxed, jobId)\n  rcall(pushCmd, targetKey, jobId)\n  addBaseMarkerIfNeeded(markerKey, isPausedOrMaxed)\nend\n--[[\n  Function to add job considering priority.\n]]\n-- Includes\n--[[\n  Function to get priority score.\n]]\nlocal function getPriorityScore(priority, priorityCounterKey)\n  local prioCounter = rcall("INCR", priorityCounterKey)\n  return priority * 0x100000000 + prioCounter % 0x100000000\nend\nlocal function addJobWithPriority(markerKey, prioritizedKey, priority, jobId, priorityCounterKey,\n  isPausedOrMaxed)\n  local score = getPriorityScore(priority, priorityCounterKey)\n  rcall("ZADD", prioritizedKey, score, jobId)\n  addBaseMarkerIfNeeded(markerKey, isPausedOrMaxed)\nend\n--[[\n  Function to check if queue is paused or maxed\n  (since an empty list and !EXISTS are not really the same).\n]]\nlocal function isQueuePausedOrMaxed(queueMetaKey, activeKey)\n  local queueAttributes = rcall("HMGET", queueMetaKey, "paused", "concurrency")\n  if queueAttributes[1] then\n    return true\n  else\n    if queueAttributes[2] then\n      local activeCount = rcall("LLEN", activeKey)\n      return activeCount >= tonumber(queueAttributes[2])\n    end\n  end\n  return false\nend\n--[[\n  Function to check for the meta.paused key to decide if we are paused or not\n  (since an empty list and !EXISTS are not really the same).\n]]\nlocal function getTargetQueueList(queueMetaKey, activeKey, waitKey, pausedKey)\n  local queueAttributes = rcall("HMGET", queueMetaKey, "paused", "concurrency")\n  if queueAttributes[1] then\n    return pausedKey, true\n  else\n    if queueAttributes[2] then\n      local activeCount = rcall("LLEN", activeKey)\n      if activeCount >= tonumber(queueAttributes[2]) then\n        return waitKey, true\n      else\n        return waitKey, false\n      end\n    end\n  end\n  return waitKey, false\nend\nlocal function moveParentToWait(parentQueueKey, parentKey, parentId, timestamp)\n    local parentWaitKey = parentQueueKey .. ":wait"\n    local parentPausedKey = parentQueueKey .. ":paused"\n    local parentActiveKey = parentQueueKey .. ":active"\n    local parentMetaKey = parentQueueKey .. ":meta"\n    local parentMarkerKey = parentQueueKey .. ":marker"\n    local jobAttributes = rcall("HMGET", parentKey, "priority", "delay")\n    local priority = tonumber(jobAttributes[1]) or 0\n    local delay = tonumber(jobAttributes[2]) or 0\n    if delay > 0 then\n        local delayedTimestamp = tonumber(timestamp) + delay\n        local score = delayedTimestamp * 0x1000\n        local parentDelayedKey = parentQueueKey .. ":delayed"\n        rcall("ZADD", parentDelayedKey, score, parentId)\n        rcall("XADD", parentQueueKey .. ":events", "*", "event", "delayed", "jobId", parentId, "delay",\n            delayedTimestamp)\n        addDelayMarkerIfNeeded(parentMarkerKey, parentDelayedKey)\n    else\n        if priority == 0 then\n            local parentTarget, isParentPausedOrMaxed = getTargetQueueList(parentMetaKey, parentActiveKey,\n                parentWaitKey, parentPausedKey)\n            addJobInTargetList(parentTarget, parentMarkerKey, "RPUSH", isParentPausedOrMaxed, parentId)\n        else\n            local isPausedOrMaxed = isQueuePausedOrMaxed(parentMetaKey, parentActiveKey)\n            addJobWithPriority(parentMarkerKey, parentQueueKey .. ":prioritized", priority, parentId,\n                parentQueueKey .. ":pc", isPausedOrMaxed)\n        end\n        rcall("XADD", parentQueueKey .. ":events", "*", "event", "waiting", "jobId", parentId, "prev",\n            "waiting-children")\n    end\nend\nlocal function moveParentToWaitIfNeeded(parentQueueKey, parentKey, parentId, timestamp)\n  if rcall("EXISTS", parentKey) == 1 then\n    local parentWaitingChildrenKey = parentQueueKey .. ":waiting-children"\n    if rcall("ZSCORE", parentWaitingChildrenKey, parentId) then    \n      rcall("ZREM", parentWaitingChildrenKey, parentId)\n      moveParentToWait(parentQueueKey, parentKey, parentId, timestamp)\n    end\n  end\nend\nlocal function moveParentToWaitIfNoPendingDependencies(parentQueueKey, parentDependenciesKey, parentKey,\n  parentId, timestamp)\n  local doNotHavePendingDependencies = rcall("SCARD", parentDependenciesKey) == 0\n  if doNotHavePendingDependencies then\n    moveParentToWaitIfNeeded(parentQueueKey, parentKey, parentId, timestamp)\n  end\nend\nlocal function updateParentDepsIfNeeded(parentKey, parentQueueKey, parentDependenciesKey,\n  parentId, jobIdKey, returnvalue, timestamp )\n  local processedSet = parentKey .. ":processed"\n  rcall("HSET", processedSet, jobIdKey, returnvalue)\n  moveParentToWaitIfNoPendingDependencies(parentQueueKey, parentDependenciesKey, parentKey, parentId, timestamp)\nend\nlocal function updateExistingJobsParent(parentKey, parent, parentData,\n                                        parentDependenciesKey, completedKey,\n                                        jobIdKey, jobId, timestamp)\n    if parentKey ~= nil then\n        if rcall("ZSCORE", completedKey, jobId) then\n            local returnvalue = rcall("HGET", jobIdKey, "returnvalue")\n            updateParentDepsIfNeeded(parentKey, parent[\'queueKey\'],\n                                     parentDependenciesKey, parent[\'id\'],\n                                     jobIdKey, returnvalue, timestamp)\n        else\n            if parentDependenciesKey ~= nil then\n                rcall("SADD", parentDependenciesKey, jobIdKey)\n            end\n        end\n        rcall("HMSET", jobIdKey, "parentKey", parentKey, "parent", parentData)\n    end\nend\nlocal function handleDuplicatedJob(jobKey, jobId, currentParentKey, currentParent,\n  parentData, parentDependenciesKey, completedKey, eventsKey, maxEvents, timestamp)\n  local existedParentKey = rcall("HGET", jobKey, "parentKey")\n  if not existedParentKey or existedParentKey == currentParentKey then\n    updateExistingJobsParent(currentParentKey, currentParent, parentData,\n      parentDependenciesKey, completedKey, jobKey,\n      jobId, timestamp)\n  else\n    if currentParentKey ~= nil and currentParentKey ~= existedParentKey\n      and (rcall("EXISTS", existedParentKey) == 1) then\n      return -7\n    end\n  end\n  rcall("XADD", eventsKey, "MAXLEN", "~", maxEvents, "*", "event",\n    "duplicated", "jobId", jobId)\n  return jobId .. "" -- convert to string\nend\n--[[\n  Function to store a job\n]]\nlocal function storeJob(eventsKey, jobIdKey, jobId, name, data, opts, timestamp,\n                        parentKey, parentData, repeatJobKey)\n    local jsonOpts = cjson.encode(opts)\n    local delay = opts[\'delay\'] or 0\n    local priority = opts[\'priority\'] or 0\n    local debounceId = opts[\'de\'] and opts[\'de\'][\'id\']\n    local optionalValues = {}\n    if parentKey ~= nil then\n        table.insert(optionalValues, "parentKey")\n        table.insert(optionalValues, parentKey)\n        table.insert(optionalValues, "parent")\n        table.insert(optionalValues, parentData)\n    end\n    if repeatJobKey then\n        table.insert(optionalValues, "rjk")\n        table.insert(optionalValues, repeatJobKey)\n    end\n    if debounceId then\n        table.insert(optionalValues, "deid")\n        table.insert(optionalValues, debounceId)\n    end\n    rcall("HMSET", jobIdKey, "name", name, "data", data, "opts", jsonOpts,\n          "timestamp", timestamp, "delay", delay, "priority", priority,\n          unpack(optionalValues))\n    rcall("XADD", eventsKey, "*", "event", "added", "jobId", jobId, "name", name)\n    return delay, priority\nend\nif parentKey ~= nil then\n    if rcall("EXISTS", parentKey) ~= 1 then return -5 end\n    parentData = cjson.encode(parent)\nend\nlocal jobCounter = rcall("INCR", idKey)\nlocal maxEvents = getOrSetMaxEvents(metaKey)\nlocal parentDependenciesKey = args[7]\nlocal timestamp = args[4]\nif args[2] == "" then\n    jobId = jobCounter\n    jobIdKey = args[1] .. jobId\nelse\n    jobId = args[2]\n    jobIdKey = args[1] .. jobId\n    if rcall("EXISTS", jobIdKey) == 1 then\n        return handleDuplicatedJob(jobIdKey, jobId, parentKey, parent,\n            parentData, parentDependenciesKey, completedKey, eventsKey,\n            maxEvents, timestamp)\n    end\nend\nlocal deduplicationJobId = deduplicateJob(opts[\'de\'], jobId, KEYS[3],\n  deduplicationKey, eventsKey, maxEvents, args[1])\nif deduplicationJobId then\n  return deduplicationJobId\nend\n-- Store the job.\nstoreJob(eventsKey, jobIdKey, jobId, args[3], ARGV[2], opts, timestamp,\n         parentKey, parentData, repeatJobKey)\nlocal waitChildrenKey = args[6]\nrcall("ZADD", waitChildrenKey, timestamp, jobId)\nrcall("XADD", eventsKey, "MAXLEN", "~", maxEvents, "*", "event",\n      "waiting-children", "jobId", jobId)\n-- Check if this job is a child of another job, if so add it to the parents dependencies\nif parentDependenciesKey ~= nil then\n    rcall("SADD", parentDependenciesKey, jobIdKey)\nend\nreturn jobId .. "" -- convert to string\n',keys:5}},(e,t,n)=>{"use strict";n.r(t),n.d(t,{addPrioritizedJob:()=>r});const r={name:"addPrioritizedJob",content:'--[[\n  Adds a priotitized job to the queue by doing the following:\n    - Increases the job counter if needed.\n    - Creates a new job key with the job data.\n    - Adds the job to the "added" list so that workers gets notified.\n    Input:\n      KEYS[1] \'marker\',\n      KEYS[2] \'meta\'\n      KEYS[3] \'id\'\n      KEYS[4] \'prioritized\'\n      KEYS[5] \'delayed\'\n      KEYS[6] \'completed\'\n      KEYS[7] \'active\'\n      KEYS[8] events stream key\n      KEYS[9] \'pc\' priority counter\n      ARGV[1] msgpacked arguments array\n            [1]  key prefix,\n            [2]  custom id (will not generate one automatically)\n            [3]  name\n            [4]  timestamp\n            [5]  parentKey?\n            [6]  waitChildrenKey key.\n            [7]  parent dependencies key.\n            [8]  parent? {id, queueKey}\n            [9]  repeat job key\n            [10] deduplication key\n      ARGV[2] Json stringified job data\n      ARGV[3] msgpacked options\n      Output:\n        jobId  - OK\n        -5     - Missing parent key\n]] \nlocal metaKey = KEYS[2]\nlocal idKey = KEYS[3]\nlocal priorityKey = KEYS[4]\nlocal completedKey = KEYS[6]\nlocal activeKey = KEYS[7]\nlocal eventsKey = KEYS[8]\nlocal priorityCounterKey = KEYS[9]\nlocal jobId\nlocal jobIdKey\nlocal rcall = redis.call\nlocal args = cmsgpack.unpack(ARGV[1])\nlocal data = ARGV[2]\nlocal opts = cmsgpack.unpack(ARGV[3])\nlocal parentKey = args[5]\nlocal parent = args[8]\nlocal repeatJobKey = args[9]\nlocal deduplicationKey = args[10]\nlocal parentData\n-- Includes\n--[[\n  Function to add job considering priority.\n]]\n-- Includes\n--[[\n  Add marker if needed when a job is available.\n]]\nlocal function addBaseMarkerIfNeeded(markerKey, isPausedOrMaxed)\n  if not isPausedOrMaxed then\n    rcall("ZADD", markerKey, 0, "0")\n  end  \nend\n--[[\n  Function to get priority score.\n]]\nlocal function getPriorityScore(priority, priorityCounterKey)\n  local prioCounter = rcall("INCR", priorityCounterKey)\n  return priority * 0x100000000 + prioCounter % 0x100000000\nend\nlocal function addJobWithPriority(markerKey, prioritizedKey, priority, jobId, priorityCounterKey,\n  isPausedOrMaxed)\n  local score = getPriorityScore(priority, priorityCounterKey)\n  rcall("ZADD", prioritizedKey, score, jobId)\n  addBaseMarkerIfNeeded(markerKey, isPausedOrMaxed)\nend\n--[[\n  Function to debounce a job.\n]]\n-- Includes\n--[[\n  Function to remove job keys.\n]]\nlocal function removeJobKeys(jobKey)\n  return rcall("DEL", jobKey, jobKey .. \':logs\', jobKey .. \':dependencies\',\n    jobKey .. \':processed\', jobKey .. \':failed\', jobKey .. \':unsuccessful\')\nend\nlocal function deduplicateJob(deduplicationOpts, jobId, delayedKey, deduplicationKey, eventsKey, maxEvents,\n    prefix)\n    local deduplicationId = deduplicationOpts and deduplicationOpts[\'id\']\n    if deduplicationId then\n        local ttl = deduplicationOpts[\'ttl\']\n        if deduplicationOpts[\'replace\'] and ttl and ttl > 0 then\n            local currentDebounceJobId = rcall(\'GET\', deduplicationKey)\n            if currentDebounceJobId then\n                if rcall("ZREM", delayedKey, currentDebounceJobId) > 0 then\n                    removeJobKeys(prefix .. currentDebounceJobId)\n                    rcall("XADD", eventsKey, "*", "event", "removed", "jobId", currentDebounceJobId,\n                        "prev", "delayed")\n                    if deduplicationOpts[\'extend\'] then\n                        rcall(\'SET\', deduplicationKey, jobId, \'PX\', ttl)\n                    else\n                        rcall(\'SET\', deduplicationKey, jobId, \'KEEPTTL\')\n                    end\n                    rcall("XADD", eventsKey, "MAXLEN", "~", maxEvents, "*", "event", "deduplicated", "jobId",\n                        jobId, "deduplicationId", deduplicationId, "deduplicatedJobId", currentDebounceJobId)\n                    return\n                else\n                    return currentDebounceJobId\n                end\n            else\n                rcall(\'SET\', deduplicationKey, jobId, \'PX\', ttl)\n                return\n            end\n        else\n            local ttl = deduplicationOpts[\'ttl\']\n            local deduplicationKeyExists\n            if ttl then\n                if deduplicationOpts[\'extend\'] then\n                    local currentDebounceJobId = rcall(\'GET\', deduplicationKey)\n                    if currentDebounceJobId then\n                        rcall(\'SET\', deduplicationKey, currentDebounceJobId, \'PX\', ttl)\n                        rcall("XADD", eventsKey, "MAXLEN", "~", maxEvents, "*", "event", "debounced",\n                            "jobId", currentDebounceJobId, "debounceId", deduplicationId)\n                        rcall("XADD", eventsKey, "MAXLEN", "~", maxEvents, "*", "event", "deduplicated", "jobId",\n                            currentDebounceJobId, "deduplicationId", deduplicationId, "deduplicatedJobId", jobId)\n                        return currentDebounceJobId\n                    else\n                        rcall(\'SET\', deduplicationKey, jobId, \'PX\', ttl)\n                        return\n                    end\n                else\n                    deduplicationKeyExists = not rcall(\'SET\', deduplicationKey, jobId, \'PX\', ttl, \'NX\')\n                end\n            else\n                deduplicationKeyExists = not rcall(\'SET\', deduplicationKey, jobId, \'NX\')\n            end\n            if deduplicationKeyExists then\n                local currentDebounceJobId = rcall(\'GET\', deduplicationKey)\n                rcall("XADD", eventsKey, "MAXLEN", "~", maxEvents, "*", "event", "debounced", "jobId",\n                    currentDebounceJobId, "debounceId", deduplicationId)\n                rcall("XADD", eventsKey, "MAXLEN", "~", maxEvents, "*", "event", "deduplicated", "jobId",\n                    currentDebounceJobId, "deduplicationId", deduplicationId, "deduplicatedJobId", jobId)\n                return currentDebounceJobId\n            end\n        end\n    end\nend\n--[[\n  Function to store a job\n]]\nlocal function storeJob(eventsKey, jobIdKey, jobId, name, data, opts, timestamp,\n                        parentKey, parentData, repeatJobKey)\n    local jsonOpts = cjson.encode(opts)\n    local delay = opts[\'delay\'] or 0\n    local priority = opts[\'priority\'] or 0\n    local debounceId = opts[\'de\'] and opts[\'de\'][\'id\']\n    local optionalValues = {}\n    if parentKey ~= nil then\n        table.insert(optionalValues, "parentKey")\n        table.insert(optionalValues, parentKey)\n        table.insert(optionalValues, "parent")\n        table.insert(optionalValues, parentData)\n    end\n    if repeatJobKey then\n        table.insert(optionalValues, "rjk")\n        table.insert(optionalValues, repeatJobKey)\n    end\n    if debounceId then\n        table.insert(optionalValues, "deid")\n        table.insert(optionalValues, debounceId)\n    end\n    rcall("HMSET", jobIdKey, "name", name, "data", data, "opts", jsonOpts,\n          "timestamp", timestamp, "delay", delay, "priority", priority,\n          unpack(optionalValues))\n    rcall("XADD", eventsKey, "*", "event", "added", "jobId", jobId, "name", name)\n    return delay, priority\nend\n--[[\n  Function to get max events value or set by default 10000.\n]]\nlocal function getOrSetMaxEvents(metaKey)\n  local maxEvents = rcall("HGET", metaKey, "opts.maxLenEvents")\n  if not maxEvents then\n    maxEvents = 10000\n    rcall("HSET", metaKey, "opts.maxLenEvents", maxEvents)\n  end\n  return maxEvents\nend\n--[[\n  Function to handle the case when job is duplicated.\n]]\n-- Includes\n--[[\n    This function is used to update the parent\'s dependencies if the job\n    is already completed and about to be ignored. The parent must get its\n    dependencies updated to avoid the parent job being stuck forever in \n    the waiting-children state.\n]]\n-- Includes\n--[[\n  Validate and move or add dependencies to parent.\n]]\n-- Includes\n--[[\n  Validate and move parent to a wait status (waiting, delayed or prioritized)\n  if no pending dependencies.\n]]\n-- Includes\n--[[\n  Validate and move parent to a wait status (waiting, delayed or prioritized) if needed.\n]]\n-- Includes\n--[[\n  Move parent to a wait status (wait, prioritized or delayed)\n]]\n-- Includes\n--[[\n  Add delay marker if needed.\n]]\n-- Includes\n--[[\n  Function to return the next delayed job timestamp.\n]]\nlocal function getNextDelayedTimestamp(delayedKey)\n  local result = rcall("ZRANGE", delayedKey, 0, 0, "WITHSCORES")\n  if #result then\n    local nextTimestamp = tonumber(result[2])\n    if nextTimestamp ~= nil then\n      return nextTimestamp / 0x1000\n    end\n  end\nend\nlocal function addDelayMarkerIfNeeded(markerKey, delayedKey)\n  local nextTimestamp = getNextDelayedTimestamp(delayedKey)\n  if nextTimestamp ~= nil then\n    -- Replace the score of the marker with the newest known\n    -- next timestamp.\n    rcall("ZADD", markerKey, nextTimestamp, "1")\n  end\nend\n--[[\n  Function to add job in target list and add marker if needed.\n]]\n-- Includes\nlocal function addJobInTargetList(targetKey, markerKey, pushCmd, isPausedOrMaxed, jobId)\n  rcall(pushCmd, targetKey, jobId)\n  addBaseMarkerIfNeeded(markerKey, isPausedOrMaxed)\nend\n--[[\n  Function to check if queue is paused or maxed\n  (since an empty list and !EXISTS are not really the same).\n]]\nlocal function isQueuePausedOrMaxed(queueMetaKey, activeKey)\n  local queueAttributes = rcall("HMGET", queueMetaKey, "paused", "concurrency")\n  if queueAttributes[1] then\n    return true\n  else\n    if queueAttributes[2] then\n      local activeCount = rcall("LLEN", activeKey)\n      return activeCount >= tonumber(queueAttributes[2])\n    end\n  end\n  return false\nend\n--[[\n  Function to check for the meta.paused key to decide if we are paused or not\n  (since an empty list and !EXISTS are not really the same).\n]]\nlocal function getTargetQueueList(queueMetaKey, activeKey, waitKey, pausedKey)\n  local queueAttributes = rcall("HMGET", queueMetaKey, "paused", "concurrency")\n  if queueAttributes[1] then\n    return pausedKey, true\n  else\n    if queueAttributes[2] then\n      local activeCount = rcall("LLEN", activeKey)\n      if activeCount >= tonumber(queueAttributes[2]) then\n        return waitKey, true\n      else\n        return waitKey, false\n      end\n    end\n  end\n  return waitKey, false\nend\nlocal function moveParentToWait(parentQueueKey, parentKey, parentId, timestamp)\n    local parentWaitKey = parentQueueKey .. ":wait"\n    local parentPausedKey = parentQueueKey .. ":paused"\n    local parentActiveKey = parentQueueKey .. ":active"\n    local parentMetaKey = parentQueueKey .. ":meta"\n    local parentMarkerKey = parentQueueKey .. ":marker"\n    local jobAttributes = rcall("HMGET", parentKey, "priority", "delay")\n    local priority = tonumber(jobAttributes[1]) or 0\n    local delay = tonumber(jobAttributes[2]) or 0\n    if delay > 0 then\n        local delayedTimestamp = tonumber(timestamp) + delay\n        local score = delayedTimestamp * 0x1000\n        local parentDelayedKey = parentQueueKey .. ":delayed"\n        rcall("ZADD", parentDelayedKey, score, parentId)\n        rcall("XADD", parentQueueKey .. ":events", "*", "event", "delayed", "jobId", parentId, "delay",\n            delayedTimestamp)\n        addDelayMarkerIfNeeded(parentMarkerKey, parentDelayedKey)\n    else\n        if priority == 0 then\n            local parentTarget, isParentPausedOrMaxed = getTargetQueueList(parentMetaKey, parentActiveKey,\n                parentWaitKey, parentPausedKey)\n            addJobInTargetList(parentTarget, parentMarkerKey, "RPUSH", isParentPausedOrMaxed, parentId)\n        else\n            local isPausedOrMaxed = isQueuePausedOrMaxed(parentMetaKey, parentActiveKey)\n            addJobWithPriority(parentMarkerKey, parentQueueKey .. ":prioritized", priority, parentId,\n                parentQueueKey .. ":pc", isPausedOrMaxed)\n        end\n        rcall("XADD", parentQueueKey .. ":events", "*", "event", "waiting", "jobId", parentId, "prev",\n            "waiting-children")\n    end\nend\nlocal function moveParentToWaitIfNeeded(parentQueueKey, parentKey, parentId, timestamp)\n  if rcall("EXISTS", parentKey) == 1 then\n    local parentWaitingChildrenKey = parentQueueKey .. ":waiting-children"\n    if rcall("ZSCORE", parentWaitingChildrenKey, parentId) then    \n      rcall("ZREM", parentWaitingChildrenKey, parentId)\n      moveParentToWait(parentQueueKey, parentKey, parentId, timestamp)\n    end\n  end\nend\nlocal function moveParentToWaitIfNoPendingDependencies(parentQueueKey, parentDependenciesKey, parentKey,\n  parentId, timestamp)\n  local doNotHavePendingDependencies = rcall("SCARD", parentDependenciesKey) == 0\n  if doNotHavePendingDependencies then\n    moveParentToWaitIfNeeded(parentQueueKey, parentKey, parentId, timestamp)\n  end\nend\nlocal function updateParentDepsIfNeeded(parentKey, parentQueueKey, parentDependenciesKey,\n  parentId, jobIdKey, returnvalue, timestamp )\n  local processedSet = parentKey .. ":processed"\n  rcall("HSET", processedSet, jobIdKey, returnvalue)\n  moveParentToWaitIfNoPendingDependencies(parentQueueKey, parentDependenciesKey, parentKey, parentId, timestamp)\nend\nlocal function updateExistingJobsParent(parentKey, parent, parentData,\n                                        parentDependenciesKey, completedKey,\n                                        jobIdKey, jobId, timestamp)\n    if parentKey ~= nil then\n        if rcall("ZSCORE", completedKey, jobId) then\n            local returnvalue = rcall("HGET", jobIdKey, "returnvalue")\n            updateParentDepsIfNeeded(parentKey, parent[\'queueKey\'],\n                                     parentDependenciesKey, parent[\'id\'],\n                                     jobIdKey, returnvalue, timestamp)\n        else\n            if parentDependenciesKey ~= nil then\n                rcall("SADD", parentDependenciesKey, jobIdKey)\n            end\n        end\n        rcall("HMSET", jobIdKey, "parentKey", parentKey, "parent", parentData)\n    end\nend\nlocal function handleDuplicatedJob(jobKey, jobId, currentParentKey, currentParent,\n  parentData, parentDependenciesKey, completedKey, eventsKey, maxEvents, timestamp)\n  local existedParentKey = rcall("HGET", jobKey, "parentKey")\n  if not existedParentKey or existedParentKey == currentParentKey then\n    updateExistingJobsParent(currentParentKey, currentParent, parentData,\n      parentDependenciesKey, completedKey, jobKey,\n      jobId, timestamp)\n  else\n    if currentParentKey ~= nil and currentParentKey ~= existedParentKey\n      and (rcall("EXISTS", existedParentKey) == 1) then\n      return -7\n    end\n  end\n  rcall("XADD", eventsKey, "MAXLEN", "~", maxEvents, "*", "event",\n    "duplicated", "jobId", jobId)\n  return jobId .. "" -- convert to string\nend\nif parentKey ~= nil then\n    if rcall("EXISTS", parentKey) ~= 1 then return -5 end\n    parentData = cjson.encode(parent)\nend\nlocal jobCounter = rcall("INCR", idKey)\nlocal maxEvents = getOrSetMaxEvents(metaKey)\nlocal parentDependenciesKey = args[7]\nlocal timestamp = args[4]\nif args[2] == "" then\n    jobId = jobCounter\n    jobIdKey = args[1] .. jobId\nelse\n    jobId = args[2]\n    jobIdKey = args[1] .. jobId\n    if rcall("EXISTS", jobIdKey) == 1 then\n        return handleDuplicatedJob(jobIdKey, jobId, parentKey, parent,\n            parentData, parentDependenciesKey, completedKey, eventsKey,\n            maxEvents, timestamp)\n    end\nend\nlocal deduplicationJobId = deduplicateJob(opts[\'de\'], jobId, KEYS[5],\n  deduplicationKey, eventsKey, maxEvents, args[1])\nif deduplicationJobId then\n  return deduplicationJobId\nend\n-- Store the job.\nlocal delay, priority = storeJob(eventsKey, jobIdKey, jobId, args[3], ARGV[2],\n                                 opts, timestamp, parentKey, parentData,\n                                 repeatJobKey)\n-- Add the job to the prioritized set\nlocal isPausedOrMaxed = isQueuePausedOrMaxed(metaKey, activeKey)\naddJobWithPriority( KEYS[1], priorityKey, priority, jobId, priorityCounterKey, isPausedOrMaxed)\n-- Emit waiting event\nrcall("XADD", eventsKey, "MAXLEN", "~", maxEvents, "*", "event", "waiting",\n      "jobId", jobId)\n-- Check if this job is a child of another job, if so add it to the parents dependencies\nif parentDependenciesKey ~= nil then\n    rcall("SADD", parentDependenciesKey, jobIdKey)\nend\nreturn jobId .. "" -- convert to string\n',keys:9}},(e,t,n)=>{"use strict";n.r(t),n.d(t,{addRepeatableJob:()=>r});const r={name:"addRepeatableJob",content:'--[[\n  Adds a repeatable job\n    Input:\n      KEYS[1] \'repeat\' key\n      KEYS[2] \'delayed\' key\n      ARGV[1] next milliseconds\n      ARGV[2] msgpacked options\n            [1]  name\n            [2]  tz?\n            [3]  patten?\n            [4]  endDate?\n            [5]  every?\n      ARGV[3] legacy custom key TODO: remove this logic in next breaking change\n      ARGV[4] custom key\n      ARGV[5] prefix key\n      Output:\n        repeatableKey  - OK\n]]\nlocal rcall = redis.call\nlocal repeatKey = KEYS[1]\nlocal delayedKey = KEYS[2]\nlocal nextMillis = ARGV[1]\nlocal legacyCustomKey = ARGV[3]\nlocal customKey = ARGV[4]\nlocal prefixKey = ARGV[5]\n-- Includes\n--[[\n  Function to remove job.\n]]\n-- Includes\n--[[\n  Function to remove deduplication key if needed\n  when a job is being removed.\n]]\nlocal function removeDeduplicationKeyIfNeededOnRemoval(prefixKey,\n  jobKey, jobId)\n  local deduplicationId = rcall("HGET", jobKey, "deid")\n  if deduplicationId then\n    local deduplicationKey = prefixKey .. "de:" .. deduplicationId\n    local currentJobId = rcall(\'GET\', deduplicationKey)\n    if currentJobId and currentJobId == jobId then\n      return rcall("DEL", deduplicationKey)\n    end\n  end\nend\n--[[\n  Function to remove job keys.\n]]\nlocal function removeJobKeys(jobKey)\n  return rcall("DEL", jobKey, jobKey .. \':logs\', jobKey .. \':dependencies\',\n    jobKey .. \':processed\', jobKey .. \':failed\', jobKey .. \':unsuccessful\')\nend\n--[[\n  Check if this job has a parent. If so we will just remove it from\n  the parent child list, but if it is the last child we should move the parent to "wait/paused"\n  which requires code from "moveToFinished"\n]]\n-- Includes\n--[[\n  Function to add job in target list and add marker if needed.\n]]\n-- Includes\n--[[\n  Add marker if needed when a job is available.\n]]\nlocal function addBaseMarkerIfNeeded(markerKey, isPausedOrMaxed)\n  if not isPausedOrMaxed then\n    rcall("ZADD", markerKey, 0, "0")\n  end  \nend\nlocal function addJobInTargetList(targetKey, markerKey, pushCmd, isPausedOrMaxed, jobId)\n  rcall(pushCmd, targetKey, jobId)\n  addBaseMarkerIfNeeded(markerKey, isPausedOrMaxed)\nend\n--[[\n  Functions to destructure job key.\n  Just a bit of warning, these functions may be a bit slow and affect performance significantly.\n]]\nlocal getJobIdFromKey = function (jobKey)\n  return string.match(jobKey, ".*:(.*)")\nend\nlocal getJobKeyPrefix = function (jobKey, jobId)\n  return string.sub(jobKey, 0, #jobKey - #jobId)\nend\n--[[\n  Function to check for the meta.paused key to decide if we are paused or not\n  (since an empty list and !EXISTS are not really the same).\n]]\nlocal function getTargetQueueList(queueMetaKey, activeKey, waitKey, pausedKey)\n  local queueAttributes = rcall("HMGET", queueMetaKey, "paused", "concurrency")\n  if queueAttributes[1] then\n    return pausedKey, true\n  else\n    if queueAttributes[2] then\n      local activeCount = rcall("LLEN", activeKey)\n      if activeCount >= tonumber(queueAttributes[2]) then\n        return waitKey, true\n      else\n        return waitKey, false\n      end\n    end\n  end\n  return waitKey, false\nend\nlocal function _moveParentToWait(parentPrefix, parentId, emitEvent)\n  local parentTarget, isPausedOrMaxed = getTargetQueueList(parentPrefix .. "meta", parentPrefix .. "active",\n    parentPrefix .. "wait", parentPrefix .. "paused")\n  addJobInTargetList(parentTarget, parentPrefix .. "marker", "RPUSH", isPausedOrMaxed, parentId)\n  if emitEvent then\n    local parentEventStream = parentPrefix .. "events"\n    rcall("XADD", parentEventStream, "*", "event", "waiting", "jobId", parentId, "prev", "waiting-children")\n  end\nend\nlocal function removeParentDependencyKey(jobKey, hard, parentKey, baseKey, debounceId)\n  if parentKey then\n    local parentDependenciesKey = parentKey .. ":dependencies"\n    local result = rcall("SREM", parentDependenciesKey, jobKey)\n    if result > 0 then\n      local pendingDependencies = rcall("SCARD", parentDependenciesKey)\n      if pendingDependencies == 0 then\n        local parentId = getJobIdFromKey(parentKey)\n        local parentPrefix = getJobKeyPrefix(parentKey, parentId)\n        local numRemovedElements = rcall("ZREM", parentPrefix .. "waiting-children", parentId)\n        if numRemovedElements == 1 then\n          if hard then -- remove parent in same queue\n            if parentPrefix == baseKey then\n              removeParentDependencyKey(parentKey, hard, nil, baseKey, nil)\n              removeJobKeys(parentKey)\n              if debounceId then\n                rcall("DEL", parentPrefix .. "de:" .. debounceId)\n              end\n            else\n              _moveParentToWait(parentPrefix, parentId)\n            end\n          else\n            _moveParentToWait(parentPrefix, parentId, true)\n          end\n        end\n      end\n      return true\n    end\n  else\n    local parentAttributes = rcall("HMGET", jobKey, "parentKey", "deid")\n    local missedParentKey = parentAttributes[1]\n    if( (type(missedParentKey) == "string") and missedParentKey ~= ""\n      and (rcall("EXISTS", missedParentKey) == 1)) then\n      local parentDependenciesKey = missedParentKey .. ":dependencies"\n      local result = rcall("SREM", parentDependenciesKey, jobKey)\n      if result > 0 then\n        local pendingDependencies = rcall("SCARD", parentDependenciesKey)\n        if pendingDependencies == 0 then\n          local parentId = getJobIdFromKey(missedParentKey)\n          local parentPrefix = getJobKeyPrefix(missedParentKey, parentId)\n          local numRemovedElements = rcall("ZREM", parentPrefix .. "waiting-children", parentId)\n          if numRemovedElements == 1 then\n            if hard then\n              if parentPrefix == baseKey then\n                removeParentDependencyKey(missedParentKey, hard, nil, baseKey, nil)\n                removeJobKeys(missedParentKey)\n                if parentAttributes[2] then\n                  rcall("DEL", parentPrefix .. "de:" .. parentAttributes[2])\n                end\n              else\n                _moveParentToWait(parentPrefix, parentId)\n              end\n            else\n              _moveParentToWait(parentPrefix, parentId, true)\n            end\n          end\n        end\n        return true\n      end\n    end\n  end\n  return false\nend\nlocal function removeJob(jobId, hard, baseKey, shouldRemoveDeduplicationKey)\n  local jobKey = baseKey .. jobId\n  removeParentDependencyKey(jobKey, hard, nil, baseKey)\n  if shouldRemoveDeduplicationKey then\n    removeDeduplicationKeyIfNeededOnRemoval(baseKey, jobKey, jobId)\n  end\n  removeJobKeys(jobKey)\nend\nlocal function storeRepeatableJob(repeatKey, customKey, nextMillis, rawOpts)\n  rcall("ZADD", repeatKey, nextMillis, customKey)\n  local opts = cmsgpack.unpack(rawOpts)\n  local optionalValues = {}\n  if opts[\'tz\'] then\n    table.insert(optionalValues, "tz")\n    table.insert(optionalValues, opts[\'tz\'])\n  end\n  if opts[\'pattern\'] then\n    table.insert(optionalValues, "pattern")\n    table.insert(optionalValues, opts[\'pattern\'])\n  end\n  if opts[\'endDate\'] then\n    table.insert(optionalValues, "endDate")\n    table.insert(optionalValues, opts[\'endDate\'])\n  end\n  if opts[\'every\'] then\n    table.insert(optionalValues, "every")\n    table.insert(optionalValues, opts[\'every\'])\n  end\n  rcall("HMSET", repeatKey .. ":" .. customKey, "name", opts[\'name\'],\n    unpack(optionalValues))\n  return customKey\nend\n-- If we are overriding a repeatable job we must delete the delayed job for\n-- the next iteration.\nlocal prevMillis = rcall("ZSCORE", repeatKey, customKey)\nif prevMillis then\n  local delayedJobId =  "repeat:" .. customKey .. ":" .. prevMillis\n  local nextDelayedJobId =  repeatKey .. ":" .. customKey .. ":" .. nextMillis\n  if rcall("ZSCORE", delayedKey, delayedJobId)\n   and rcall("EXISTS", nextDelayedJobId) ~= 1 then\n    removeJob(delayedJobId, true, prefixKey, true --[[remove debounce key]])\n    rcall("ZREM", delayedKey, delayedJobId)\n  end\nend\n-- Keep backwards compatibility with old repeatable jobs (<= 3.0.0)\nif rcall("ZSCORE", repeatKey, legacyCustomKey) ~= false then\n  return storeRepeatableJob(repeatKey, legacyCustomKey, nextMillis, ARGV[2])\nend\nreturn storeRepeatableJob(repeatKey, customKey, nextMillis, ARGV[2])\n',keys:2}},(e,t,n)=>{"use strict";n.r(t),n.d(t,{addStandardJob:()=>r});const r={name:"addStandardJob",content:'--[[\n  Adds a job to the queue by doing the following:\n    - Increases the job counter if needed.\n    - Creates a new job key with the job data.\n    - if delayed:\n      - computes timestamp.\n      - adds to delayed zset.\n      - Emits a global event \'delayed\' if the job is delayed.\n    - if not delayed\n      - Adds the jobId to the wait/paused list in one of three ways:\n         - LIFO\n         - FIFO\n         - prioritized.\n      - Adds the job to the "added" list so that workers gets notified.\n    Input:\n      KEYS[1] \'wait\',\n      KEYS[2] \'paused\'\n      KEYS[3] \'meta\'\n      KEYS[4] \'id\'\n      KEYS[5] \'completed\'\n      KEYS[6] \'delayed\'\n      KEYS[7] \'active\'\n      KEYS[8] events stream key\n      KEYS[9] marker key\n      ARGV[1] msgpacked arguments array\n            [1]  key prefix,\n            [2]  custom id (will not generate one automatically)\n            [3]  name\n            [4]  timestamp\n            [5]  parentKey?\n            [6]  waitChildrenKey key.\n            [7]  parent dependencies key.\n            [8]  parent? {id, queueKey}\n            [9]  repeat job key\n            [10] deduplication key\n      ARGV[2] Json stringified job data\n      ARGV[3] msgpacked options\n      Output:\n        jobId  - OK\n        -5     - Missing parent key\n]]\nlocal eventsKey = KEYS[8]\nlocal jobId\nlocal jobIdKey\nlocal rcall = redis.call\nlocal args = cmsgpack.unpack(ARGV[1])\nlocal data = ARGV[2]\nlocal opts = cmsgpack.unpack(ARGV[3])\nlocal parentKey = args[5]\nlocal parent = args[8]\nlocal repeatJobKey = args[9]\nlocal deduplicationKey = args[10]\nlocal parentData\n-- Includes\n--[[\n  Function to add job in target list and add marker if needed.\n]]\n-- Includes\n--[[\n  Add marker if needed when a job is available.\n]]\nlocal function addBaseMarkerIfNeeded(markerKey, isPausedOrMaxed)\n  if not isPausedOrMaxed then\n    rcall("ZADD", markerKey, 0, "0")\n  end  \nend\nlocal function addJobInTargetList(targetKey, markerKey, pushCmd, isPausedOrMaxed, jobId)\n  rcall(pushCmd, targetKey, jobId)\n  addBaseMarkerIfNeeded(markerKey, isPausedOrMaxed)\nend\n--[[\n  Function to debounce a job.\n]]\n-- Includes\n--[[\n  Function to remove job keys.\n]]\nlocal function removeJobKeys(jobKey)\n  return rcall("DEL", jobKey, jobKey .. \':logs\', jobKey .. \':dependencies\',\n    jobKey .. \':processed\', jobKey .. \':failed\', jobKey .. \':unsuccessful\')\nend\nlocal function deduplicateJob(deduplicationOpts, jobId, delayedKey, deduplicationKey, eventsKey, maxEvents,\n    prefix)\n    local deduplicationId = deduplicationOpts and deduplicationOpts[\'id\']\n    if deduplicationId then\n        local ttl = deduplicationOpts[\'ttl\']\n        if deduplicationOpts[\'replace\'] and ttl and ttl > 0 then\n            local currentDebounceJobId = rcall(\'GET\', deduplicationKey)\n            if currentDebounceJobId then\n                if rcall("ZREM", delayedKey, currentDebounceJobId) > 0 then\n                    removeJobKeys(prefix .. currentDebounceJobId)\n                    rcall("XADD", eventsKey, "*", "event", "removed", "jobId", currentDebounceJobId,\n                        "prev", "delayed")\n                    if deduplicationOpts[\'extend\'] then\n                        rcall(\'SET\', deduplicationKey, jobId, \'PX\', ttl)\n                    else\n                        rcall(\'SET\', deduplicationKey, jobId, \'KEEPTTL\')\n                    end\n                    rcall("XADD", eventsKey, "MAXLEN", "~", maxEvents, "*", "event", "deduplicated", "jobId",\n                        jobId, "deduplicationId", deduplicationId, "deduplicatedJobId", currentDebounceJobId)\n                    return\n                else\n                    return currentDebounceJobId\n                end\n            else\n                rcall(\'SET\', deduplicationKey, jobId, \'PX\', ttl)\n                return\n            end\n        else\n            local ttl = deduplicationOpts[\'ttl\']\n            local deduplicationKeyExists\n            if ttl then\n                if deduplicationOpts[\'extend\'] then\n                    local currentDebounceJobId = rcall(\'GET\', deduplicationKey)\n                    if currentDebounceJobId then\n                        rcall(\'SET\', deduplicationKey, currentDebounceJobId, \'PX\', ttl)\n                        rcall("XADD", eventsKey, "MAXLEN", "~", maxEvents, "*", "event", "debounced",\n                            "jobId", currentDebounceJobId, "debounceId", deduplicationId)\n                        rcall("XADD", eventsKey, "MAXLEN", "~", maxEvents, "*", "event", "deduplicated", "jobId",\n                            currentDebounceJobId, "deduplicationId", deduplicationId, "deduplicatedJobId", jobId)\n                        return currentDebounceJobId\n                    else\n                        rcall(\'SET\', deduplicationKey, jobId, \'PX\', ttl)\n                        return\n                    end\n                else\n                    deduplicationKeyExists = not rcall(\'SET\', deduplicationKey, jobId, \'PX\', ttl, \'NX\')\n                end\n            else\n                deduplicationKeyExists = not rcall(\'SET\', deduplicationKey, jobId, \'NX\')\n            end\n            if deduplicationKeyExists then\n                local currentDebounceJobId = rcall(\'GET\', deduplicationKey)\n                rcall("XADD", eventsKey, "MAXLEN", "~", maxEvents, "*", "event", "debounced", "jobId",\n                    currentDebounceJobId, "debounceId", deduplicationId)\n                rcall("XADD", eventsKey, "MAXLEN", "~", maxEvents, "*", "event", "deduplicated", "jobId",\n                    currentDebounceJobId, "deduplicationId", deduplicationId, "deduplicatedJobId", jobId)\n                return currentDebounceJobId\n            end\n        end\n    end\nend\n--[[\n  Function to get max events value or set by default 10000.\n]]\nlocal function getOrSetMaxEvents(metaKey)\n  local maxEvents = rcall("HGET", metaKey, "opts.maxLenEvents")\n  if not maxEvents then\n    maxEvents = 10000\n    rcall("HSET", metaKey, "opts.maxLenEvents", maxEvents)\n  end\n  return maxEvents\nend\n--[[\n  Function to check for the meta.paused key to decide if we are paused or not\n  (since an empty list and !EXISTS are not really the same).\n]]\nlocal function getTargetQueueList(queueMetaKey, activeKey, waitKey, pausedKey)\n  local queueAttributes = rcall("HMGET", queueMetaKey, "paused", "concurrency")\n  if queueAttributes[1] then\n    return pausedKey, true\n  else\n    if queueAttributes[2] then\n      local activeCount = rcall("LLEN", activeKey)\n      if activeCount >= tonumber(queueAttributes[2]) then\n        return waitKey, true\n      else\n        return waitKey, false\n      end\n    end\n  end\n  return waitKey, false\nend\n--[[\n  Function to handle the case when job is duplicated.\n]]\n-- Includes\n--[[\n    This function is used to update the parent\'s dependencies if the job\n    is already completed and about to be ignored. The parent must get its\n    dependencies updated to avoid the parent job being stuck forever in \n    the waiting-children state.\n]]\n-- Includes\n--[[\n  Validate and move or add dependencies to parent.\n]]\n-- Includes\n--[[\n  Validate and move parent to a wait status (waiting, delayed or prioritized)\n  if no pending dependencies.\n]]\n-- Includes\n--[[\n  Validate and move parent to a wait status (waiting, delayed or prioritized) if needed.\n]]\n-- Includes\n--[[\n  Move parent to a wait status (wait, prioritized or delayed)\n]]\n-- Includes\n--[[\n  Add delay marker if needed.\n]]\n-- Includes\n--[[\n  Function to return the next delayed job timestamp.\n]]\nlocal function getNextDelayedTimestamp(delayedKey)\n  local result = rcall("ZRANGE", delayedKey, 0, 0, "WITHSCORES")\n  if #result then\n    local nextTimestamp = tonumber(result[2])\n    if nextTimestamp ~= nil then\n      return nextTimestamp / 0x1000\n    end\n  end\nend\nlocal function addDelayMarkerIfNeeded(markerKey, delayedKey)\n  local nextTimestamp = getNextDelayedTimestamp(delayedKey)\n  if nextTimestamp ~= nil then\n    -- Replace the score of the marker with the newest known\n    -- next timestamp.\n    rcall("ZADD", markerKey, nextTimestamp, "1")\n  end\nend\n--[[\n  Function to add job considering priority.\n]]\n-- Includes\n--[[\n  Function to get priority score.\n]]\nlocal function getPriorityScore(priority, priorityCounterKey)\n  local prioCounter = rcall("INCR", priorityCounterKey)\n  return priority * 0x100000000 + prioCounter % 0x100000000\nend\nlocal function addJobWithPriority(markerKey, prioritizedKey, priority, jobId, priorityCounterKey,\n  isPausedOrMaxed)\n  local score = getPriorityScore(priority, priorityCounterKey)\n  rcall("ZADD", prioritizedKey, score, jobId)\n  addBaseMarkerIfNeeded(markerKey, isPausedOrMaxed)\nend\n--[[\n  Function to check if queue is paused or maxed\n  (since an empty list and !EXISTS are not really the same).\n]]\nlocal function isQueuePausedOrMaxed(queueMetaKey, activeKey)\n  local queueAttributes = rcall("HMGET", queueMetaKey, "paused", "concurrency")\n  if queueAttributes[1] then\n    return true\n  else\n    if queueAttributes[2] then\n      local activeCount = rcall("LLEN", activeKey)\n      return activeCount >= tonumber(queueAttributes[2])\n    end\n  end\n  return false\nend\nlocal function moveParentToWait(parentQueueKey, parentKey, parentId, timestamp)\n    local parentWaitKey = parentQueueKey .. ":wait"\n    local parentPausedKey = parentQueueKey .. ":paused"\n    local parentActiveKey = parentQueueKey .. ":active"\n    local parentMetaKey = parentQueueKey .. ":meta"\n    local parentMarkerKey = parentQueueKey .. ":marker"\n    local jobAttributes = rcall("HMGET", parentKey, "priority", "delay")\n    local priority = tonumber(jobAttributes[1]) or 0\n    local delay = tonumber(jobAttributes[2]) or 0\n    if delay > 0 then\n        local delayedTimestamp = tonumber(timestamp) + delay\n        local score = delayedTimestamp * 0x1000\n        local parentDelayedKey = parentQueueKey .. ":delayed"\n        rcall("ZADD", parentDelayedKey, score, parentId)\n        rcall("XADD", parentQueueKey .. ":events", "*", "event", "delayed", "jobId", parentId, "delay",\n            delayedTimestamp)\n        addDelayMarkerIfNeeded(parentMarkerKey, parentDelayedKey)\n    else\n        if priority == 0 then\n            local parentTarget, isParentPausedOrMaxed = getTargetQueueList(parentMetaKey, parentActiveKey,\n                parentWaitKey, parentPausedKey)\n            addJobInTargetList(parentTarget, parentMarkerKey, "RPUSH", isParentPausedOrMaxed, parentId)\n        else\n            local isPausedOrMaxed = isQueuePausedOrMaxed(parentMetaKey, parentActiveKey)\n            addJobWithPriority(parentMarkerKey, parentQueueKey .. ":prioritized", priority, parentId,\n                parentQueueKey .. ":pc", isPausedOrMaxed)\n        end\n        rcall("XADD", parentQueueKey .. ":events", "*", "event", "waiting", "jobId", parentId, "prev",\n            "waiting-children")\n    end\nend\nlocal function moveParentToWaitIfNeeded(parentQueueKey, parentKey, parentId, timestamp)\n  if rcall("EXISTS", parentKey) == 1 then\n    local parentWaitingChildrenKey = parentQueueKey .. ":waiting-children"\n    if rcall("ZSCORE", parentWaitingChildrenKey, parentId) then    \n      rcall("ZREM", parentWaitingChildrenKey, parentId)\n      moveParentToWait(parentQueueKey, parentKey, parentId, timestamp)\n    end\n  end\nend\nlocal function moveParentToWaitIfNoPendingDependencies(parentQueueKey, parentDependenciesKey, parentKey,\n  parentId, timestamp)\n  local doNotHavePendingDependencies = rcall("SCARD", parentDependenciesKey) == 0\n  if doNotHavePendingDependencies then\n    moveParentToWaitIfNeeded(parentQueueKey, parentKey, parentId, timestamp)\n  end\nend\nlocal function updateParentDepsIfNeeded(parentKey, parentQueueKey, parentDependenciesKey,\n  parentId, jobIdKey, returnvalue, timestamp )\n  local processedSet = parentKey .. ":processed"\n  rcall("HSET", processedSet, jobIdKey, returnvalue)\n  moveParentToWaitIfNoPendingDependencies(parentQueueKey, parentDependenciesKey, parentKey, parentId, timestamp)\nend\nlocal function updateExistingJobsParent(parentKey, parent, parentData,\n                                        parentDependenciesKey, completedKey,\n                                        jobIdKey, jobId, timestamp)\n    if parentKey ~= nil then\n        if rcall("ZSCORE", completedKey, jobId) then\n            local returnvalue = rcall("HGET", jobIdKey, "returnvalue")\n            updateParentDepsIfNeeded(parentKey, parent[\'queueKey\'],\n                                     parentDependenciesKey, parent[\'id\'],\n                                     jobIdKey, returnvalue, timestamp)\n        else\n            if parentDependenciesKey ~= nil then\n                rcall("SADD", parentDependenciesKey, jobIdKey)\n            end\n        end\n        rcall("HMSET", jobIdKey, "parentKey", parentKey, "parent", parentData)\n    end\nend\nlocal function handleDuplicatedJob(jobKey, jobId, currentParentKey, currentParent,\n  parentData, parentDependenciesKey, completedKey, eventsKey, maxEvents, timestamp)\n  local existedParentKey = rcall("HGET", jobKey, "parentKey")\n  if not existedParentKey or existedParentKey == currentParentKey then\n    updateExistingJobsParent(currentParentKey, currentParent, parentData,\n      parentDependenciesKey, completedKey, jobKey,\n      jobId, timestamp)\n  else\n    if currentParentKey ~= nil and currentParentKey ~= existedParentKey\n      and (rcall("EXISTS", existedParentKey) == 1) then\n      return -7\n    end\n  end\n  rcall("XADD", eventsKey, "MAXLEN", "~", maxEvents, "*", "event",\n    "duplicated", "jobId", jobId)\n  return jobId .. "" -- convert to string\nend\n--[[\n  Function to store a job\n]]\nlocal function storeJob(eventsKey, jobIdKey, jobId, name, data, opts, timestamp,\n                        parentKey, parentData, repeatJobKey)\n    local jsonOpts = cjson.encode(opts)\n    local delay = opts[\'delay\'] or 0\n    local priority = opts[\'priority\'] or 0\n    local debounceId = opts[\'de\'] and opts[\'de\'][\'id\']\n    local optionalValues = {}\n    if parentKey ~= nil then\n        table.insert(optionalValues, "parentKey")\n        table.insert(optionalValues, parentKey)\n        table.insert(optionalValues, "parent")\n        table.insert(optionalValues, parentData)\n    end\n    if repeatJobKey then\n        table.insert(optionalValues, "rjk")\n        table.insert(optionalValues, repeatJobKey)\n    end\n    if debounceId then\n        table.insert(optionalValues, "deid")\n        table.insert(optionalValues, debounceId)\n    end\n    rcall("HMSET", jobIdKey, "name", name, "data", data, "opts", jsonOpts,\n          "timestamp", timestamp, "delay", delay, "priority", priority,\n          unpack(optionalValues))\n    rcall("XADD", eventsKey, "*", "event", "added", "jobId", jobId, "name", name)\n    return delay, priority\nend\nif parentKey ~= nil then\n    if rcall("EXISTS", parentKey) ~= 1 then return -5 end\n    parentData = cjson.encode(parent)\nend\nlocal jobCounter = rcall("INCR", KEYS[4])\nlocal metaKey = KEYS[3]\nlocal maxEvents = getOrSetMaxEvents(metaKey)\nlocal parentDependenciesKey = args[7]\nlocal timestamp = args[4]\nif args[2] == "" then\n    jobId = jobCounter\n    jobIdKey = args[1] .. jobId\nelse\n    jobId = args[2]\n    jobIdKey = args[1] .. jobId\n    if rcall("EXISTS", jobIdKey) == 1 then\n        return handleDuplicatedJob(jobIdKey, jobId, parentKey, parent,\n            parentData, parentDependenciesKey, KEYS[5], eventsKey,\n            maxEvents, timestamp)\n    end\nend\nlocal deduplicationJobId = deduplicateJob(opts[\'de\'], jobId, KEYS[6],\n  deduplicationKey, eventsKey, maxEvents, args[1])\nif deduplicationJobId then\n  return deduplicationJobId\nend\n-- Store the job.\nstoreJob(eventsKey, jobIdKey, jobId, args[3], ARGV[2], opts, timestamp,\n         parentKey, parentData, repeatJobKey)\nlocal target, isPausedOrMaxed = getTargetQueueList(metaKey, KEYS[7], KEYS[1], KEYS[2])\n-- LIFO or FIFO\nlocal pushCmd = opts[\'lifo\'] and \'RPUSH\' or \'LPUSH\'\naddJobInTargetList(target, KEYS[9], pushCmd, isPausedOrMaxed, jobId)\n-- Emit waiting event\nrcall("XADD", eventsKey, "MAXLEN", "~", maxEvents, "*", "event", "waiting",\n      "jobId", jobId)\n-- Check if this job is a child of another job, if so add it to the parents dependencies\nif parentDependenciesKey ~= nil then\n    rcall("SADD", parentDependenciesKey, jobIdKey)\nend\nreturn jobId .. "" -- convert to string\n',keys:9}},(e,t,n)=>{"use strict";n.r(t),n.d(t,{changeDelay:()=>r});const r={name:"changeDelay",content:'--[[\n  Change job delay when it is in delayed set.\n  Input:\n    KEYS[1] delayed key\n    KEYS[2] meta key\n    KEYS[3] marker key\n    KEYS[4] events stream\n    ARGV[1] delay\n    ARGV[2] timestamp\n    ARGV[3] the id of the job\n    ARGV[4] job key\n  Output:\n    0 - OK\n   -1 - Missing job.\n   -3 - Job not in delayed set.\n  Events:\n    - delayed key.\n]]\nlocal rcall = redis.call\n-- Includes\n--[[\n  Add delay marker if needed.\n]]\n-- Includes\n--[[\n  Function to return the next delayed job timestamp.\n]]\nlocal function getNextDelayedTimestamp(delayedKey)\n  local result = rcall("ZRANGE", delayedKey, 0, 0, "WITHSCORES")\n  if #result then\n    local nextTimestamp = tonumber(result[2])\n    if nextTimestamp ~= nil then\n      return nextTimestamp / 0x1000\n    end\n  end\nend\nlocal function addDelayMarkerIfNeeded(markerKey, delayedKey)\n  local nextTimestamp = getNextDelayedTimestamp(delayedKey)\n  if nextTimestamp ~= nil then\n    -- Replace the score of the marker with the newest known\n    -- next timestamp.\n    rcall("ZADD", markerKey, nextTimestamp, "1")\n  end\nend\n--[[\n  Bake in the job id first 12 bits into the timestamp\n  to guarantee correct execution order of delayed jobs\n  (up to 4096 jobs per given timestamp or 4096 jobs apart per timestamp)\n  WARNING: Jobs that are so far apart that they wrap around will cause FIFO to fail\n]]\nlocal function getDelayedScore(delayedKey, timestamp, delay)\n  local delayedTimestamp = (delay > 0 and (tonumber(timestamp) + delay)) or tonumber(timestamp)\n  local minScore = delayedTimestamp * 0x1000\n  local maxScore = (delayedTimestamp + 1 ) * 0x1000 - 1\n  local result = rcall("ZREVRANGEBYSCORE", delayedKey, maxScore,\n    minScore, "WITHSCORES","LIMIT", 0, 1)\n  if #result then\n    local currentMaxScore = tonumber(result[2])\n    if currentMaxScore ~= nil then\n      if currentMaxScore >= maxScore then\n        return maxScore, delayedTimestamp\n      else\n        return currentMaxScore + 1, delayedTimestamp\n      end\n    end\n  end\n  return minScore, delayedTimestamp\nend\n--[[\n  Function to get max events value or set by default 10000.\n]]\nlocal function getOrSetMaxEvents(metaKey)\n  local maxEvents = rcall("HGET", metaKey, "opts.maxLenEvents")\n  if not maxEvents then\n    maxEvents = 10000\n    rcall("HSET", metaKey, "opts.maxLenEvents", maxEvents)\n  end\n  return maxEvents\nend\nif rcall("EXISTS", ARGV[4]) == 1 then\n  local jobId = ARGV[3]\n  local delay = tonumber(ARGV[1])\n  local score, delayedTimestamp = getDelayedScore(KEYS[1], ARGV[2], delay)\n  local numRemovedElements = rcall("ZREM", KEYS[1], jobId)\n  if numRemovedElements < 1 then\n    return -3\n  end\n  rcall("HSET", ARGV[4], "delay", delay)\n  rcall("ZADD", KEYS[1], score, jobId)\n  local maxEvents = getOrSetMaxEvents(KEYS[2])\n  rcall("XADD", KEYS[4], "MAXLEN", "~", maxEvents, "*", "event", "delayed",\n    "jobId", jobId, "delay", delayedTimestamp)\n  -- mark that a delayed job is available\n  addDelayMarkerIfNeeded(KEYS[3], KEYS[1])\n  return 0\nelse\n  return -1\nend',keys:4}},(e,t,n)=>{"use strict";n.r(t),n.d(t,{changePriority:()=>r});const r={name:"changePriority",content:'--[[\n  Change job priority\n  Input:\n    KEYS[1] \'wait\',\n    KEYS[2] \'paused\'\n    KEYS[3] \'meta\'\n    KEYS[4] \'prioritized\'\n    KEYS[5] \'active\'\n    KEYS[6] \'pc\' priority counter\n    KEYS[7] \'marker\'\n    ARGV[1] priority value\n    ARGV[2] prefix key\n    ARGV[3] job id\n    ARGV[4] lifo\n    Output:\n       0  - OK\n      -1  - Missing job\n]]\nlocal jobId = ARGV[3]\nlocal jobKey = ARGV[2] .. jobId\nlocal priority = tonumber(ARGV[1])\nlocal rcall = redis.call\n-- Includes\n--[[\n  Function to add job in target list and add marker if needed.\n]]\n-- Includes\n--[[\n  Add marker if needed when a job is available.\n]]\nlocal function addBaseMarkerIfNeeded(markerKey, isPausedOrMaxed)\n  if not isPausedOrMaxed then\n    rcall("ZADD", markerKey, 0, "0")\n  end  \nend\nlocal function addJobInTargetList(targetKey, markerKey, pushCmd, isPausedOrMaxed, jobId)\n  rcall(pushCmd, targetKey, jobId)\n  addBaseMarkerIfNeeded(markerKey, isPausedOrMaxed)\nend\n--[[\n  Function to add job considering priority.\n]]\n-- Includes\n--[[\n  Function to get priority score.\n]]\nlocal function getPriorityScore(priority, priorityCounterKey)\n  local prioCounter = rcall("INCR", priorityCounterKey)\n  return priority * 0x100000000 + prioCounter % 0x100000000\nend\nlocal function addJobWithPriority(markerKey, prioritizedKey, priority, jobId, priorityCounterKey,\n  isPausedOrMaxed)\n  local score = getPriorityScore(priority, priorityCounterKey)\n  rcall("ZADD", prioritizedKey, score, jobId)\n  addBaseMarkerIfNeeded(markerKey, isPausedOrMaxed)\nend\n--[[\n  Function to check for the meta.paused key to decide if we are paused or not\n  (since an empty list and !EXISTS are not really the same).\n]]\nlocal function getTargetQueueList(queueMetaKey, activeKey, waitKey, pausedKey)\n  local queueAttributes = rcall("HMGET", queueMetaKey, "paused", "concurrency")\n  if queueAttributes[1] then\n    return pausedKey, true\n  else\n    if queueAttributes[2] then\n      local activeCount = rcall("LLEN", activeKey)\n      if activeCount >= tonumber(queueAttributes[2]) then\n        return waitKey, true\n      else\n        return waitKey, false\n      end\n    end\n  end\n  return waitKey, false\nend\n--[[\n  Function to push back job considering priority in front of same prioritized jobs.\n]]\nlocal function pushBackJobWithPriority(prioritizedKey, priority, jobId)\n  -- in order to put it at front of same prioritized jobs\n  -- we consider prioritized counter as 0\n  local score = priority * 0x100000000\n  rcall("ZADD", prioritizedKey, score, jobId)\nend\nlocal function reAddJobWithNewPriority( prioritizedKey, markerKey, targetKey,\n    priorityCounter, lifo, priority, jobId, isPausedOrMaxed)\n    if priority == 0 then\n        local pushCmd = lifo and \'RPUSH\' or \'LPUSH\'\n        addJobInTargetList(targetKey, markerKey, pushCmd, isPausedOrMaxed, jobId)\n    else\n        if lifo then\n            pushBackJobWithPriority(prioritizedKey, priority, jobId)\n        else\n            addJobWithPriority(markerKey, prioritizedKey, priority, jobId,\n                priorityCounter, isPausedOrMaxed)\n        end\n    end\nend\nif rcall("EXISTS", jobKey) == 1 then\n    local metaKey = KEYS[3]\n    local target, isPausedOrMaxed = getTargetQueueList(metaKey, KEYS[5], KEYS[1], KEYS[2])\n    local prioritizedKey = KEYS[4]\n    local priorityCounterKey = KEYS[6]\n    local markerKey = KEYS[7]\n    -- Re-add with the new priority\n    if rcall("ZREM", prioritizedKey, jobId) > 0 then\n        reAddJobWithNewPriority( prioritizedKey, markerKey, target,\n            priorityCounterKey, ARGV[4] == \'1\', priority, jobId, isPausedOrMaxed)\n    elseif rcall("LREM", target, -1, jobId) > 0 then\n        reAddJobWithNewPriority( prioritizedKey, markerKey, target,\n            priorityCounterKey, ARGV[4] == \'1\', priority, jobId, isPausedOrMaxed)\n    end\n    rcall("HSET", jobKey, "priority", priority)\n    return 0\nelse\n    return -1\nend\n',keys:7}},(e,t,n)=>{"use strict";n.r(t),n.d(t,{cleanJobsInSet:()=>r});const r={name:"cleanJobsInSet",content:'--[[\n  Remove jobs from the specific set.\n  Input:\n    KEYS[1]  set key,\n    KEYS[2]  events stream key\n    KEYS[3]  repeat key\n    ARGV[1]  jobKey prefix\n    ARGV[2]  timestamp\n    ARGV[3]  limit the number of jobs to be removed. 0 is unlimited\n    ARGV[4]  set name, can be any of \'wait\', \'active\', \'paused\', \'delayed\', \'completed\', or \'failed\'\n]]\nlocal rcall = redis.call\nlocal repeatKey = KEYS[3]\nlocal rangeStart = 0\nlocal rangeEnd = -1\nlocal limit = tonumber(ARGV[3])\n-- If we\'re only deleting _n_ items, avoid retrieving all items\n-- for faster performance\n--\n-- Start from the tail of the list, since that\'s where oldest elements\n-- are generally added for FIFO lists\nif limit > 0 then\n  rangeStart = -1 - limit + 1\n  rangeEnd = -1\nend\n-- Includes\n--[[\n  Function to clean job list.\n  Returns jobIds and deleted count number.\n]]\n-- Includes\n--[[\n  Function to get the latest saved timestamp.\n]]\nlocal function getTimestamp(jobKey, attributes)\n  if #attributes == 1 then\n    return rcall("HGET", jobKey, attributes[1])\n  end\n  local jobTs\n  for _, ts in ipairs(rcall("HMGET", jobKey, unpack(attributes))) do\n    if (ts) then\n      jobTs = ts\n      break\n    end\n  end\n  return jobTs\nend\n--[[\n  Function to check if the job belongs to a job scheduler and\n  current delayed job matches with jobId\n]]\nlocal function isJobSchedulerJob(jobId, jobKey, jobSchedulersKey)\n  local repeatJobKey = rcall("HGET", jobKey, "rjk")\n  if repeatJobKey  then\n    local prevMillis = rcall("ZSCORE", jobSchedulersKey, repeatJobKey)\n    if prevMillis then\n      local currentDelayedJobId = "repeat:" .. repeatJobKey .. ":" .. prevMillis\n      return jobId == currentDelayedJobId\n    end\n  end\n  return false\nend\n--[[\n  Function to remove job.\n]]\n-- Includes\n--[[\n  Function to remove deduplication key if needed\n  when a job is being removed.\n]]\nlocal function removeDeduplicationKeyIfNeededOnRemoval(prefixKey,\n  jobKey, jobId)\n  local deduplicationId = rcall("HGET", jobKey, "deid")\n  if deduplicationId then\n    local deduplicationKey = prefixKey .. "de:" .. deduplicationId\n    local currentJobId = rcall(\'GET\', deduplicationKey)\n    if currentJobId and currentJobId == jobId then\n      return rcall("DEL", deduplicationKey)\n    end\n  end\nend\n--[[\n  Function to remove job keys.\n]]\nlocal function removeJobKeys(jobKey)\n  return rcall("DEL", jobKey, jobKey .. \':logs\', jobKey .. \':dependencies\',\n    jobKey .. \':processed\', jobKey .. \':failed\', jobKey .. \':unsuccessful\')\nend\n--[[\n  Check if this job has a parent. If so we will just remove it from\n  the parent child list, but if it is the last child we should move the parent to "wait/paused"\n  which requires code from "moveToFinished"\n]]\n-- Includes\n--[[\n  Function to add job in target list and add marker if needed.\n]]\n-- Includes\n--[[\n  Add marker if needed when a job is available.\n]]\nlocal function addBaseMarkerIfNeeded(markerKey, isPausedOrMaxed)\n  if not isPausedOrMaxed then\n    rcall("ZADD", markerKey, 0, "0")\n  end  \nend\nlocal function addJobInTargetList(targetKey, markerKey, pushCmd, isPausedOrMaxed, jobId)\n  rcall(pushCmd, targetKey, jobId)\n  addBaseMarkerIfNeeded(markerKey, isPausedOrMaxed)\nend\n--[[\n  Functions to destructure job key.\n  Just a bit of warning, these functions may be a bit slow and affect performance significantly.\n]]\nlocal getJobIdFromKey = function (jobKey)\n  return string.match(jobKey, ".*:(.*)")\nend\nlocal getJobKeyPrefix = function (jobKey, jobId)\n  return string.sub(jobKey, 0, #jobKey - #jobId)\nend\n--[[\n  Function to check for the meta.paused key to decide if we are paused or not\n  (since an empty list and !EXISTS are not really the same).\n]]\nlocal function getTargetQueueList(queueMetaKey, activeKey, waitKey, pausedKey)\n  local queueAttributes = rcall("HMGET", queueMetaKey, "paused", "concurrency")\n  if queueAttributes[1] then\n    return pausedKey, true\n  else\n    if queueAttributes[2] then\n      local activeCount = rcall("LLEN", activeKey)\n      if activeCount >= tonumber(queueAttributes[2]) then\n        return waitKey, true\n      else\n        return waitKey, false\n      end\n    end\n  end\n  return waitKey, false\nend\nlocal function _moveParentToWait(parentPrefix, parentId, emitEvent)\n  local parentTarget, isPausedOrMaxed = getTargetQueueList(parentPrefix .. "meta", parentPrefix .. "active",\n    parentPrefix .. "wait", parentPrefix .. "paused")\n  addJobInTargetList(parentTarget, parentPrefix .. "marker", "RPUSH", isPausedOrMaxed, parentId)\n  if emitEvent then\n    local parentEventStream = parentPrefix .. "events"\n    rcall("XADD", parentEventStream, "*", "event", "waiting", "jobId", parentId, "prev", "waiting-children")\n  end\nend\nlocal function removeParentDependencyKey(jobKey, hard, parentKey, baseKey, debounceId)\n  if parentKey then\n    local parentDependenciesKey = parentKey .. ":dependencies"\n    local result = rcall("SREM", parentDependenciesKey, jobKey)\n    if result > 0 then\n      local pendingDependencies = rcall("SCARD", parentDependenciesKey)\n      if pendingDependencies == 0 then\n        local parentId = getJobIdFromKey(parentKey)\n        local parentPrefix = getJobKeyPrefix(parentKey, parentId)\n        local numRemovedElements = rcall("ZREM", parentPrefix .. "waiting-children", parentId)\n        if numRemovedElements == 1 then\n          if hard then -- remove parent in same queue\n            if parentPrefix == baseKey then\n              removeParentDependencyKey(parentKey, hard, nil, baseKey, nil)\n              removeJobKeys(parentKey)\n              if debounceId then\n                rcall("DEL", parentPrefix .. "de:" .. debounceId)\n              end\n            else\n              _moveParentToWait(parentPrefix, parentId)\n            end\n          else\n            _moveParentToWait(parentPrefix, parentId, true)\n          end\n        end\n      end\n      return true\n    end\n  else\n    local parentAttributes = rcall("HMGET", jobKey, "parentKey", "deid")\n    local missedParentKey = parentAttributes[1]\n    if( (type(missedParentKey) == "string") and missedParentKey ~= ""\n      and (rcall("EXISTS", missedParentKey) == 1)) then\n      local parentDependenciesKey = missedParentKey .. ":dependencies"\n      local result = rcall("SREM", parentDependenciesKey, jobKey)\n      if result > 0 then\n        local pendingDependencies = rcall("SCARD", parentDependenciesKey)\n        if pendingDependencies == 0 then\n          local parentId = getJobIdFromKey(missedParentKey)\n          local parentPrefix = getJobKeyPrefix(missedParentKey, parentId)\n          local numRemovedElements = rcall("ZREM", parentPrefix .. "waiting-children", parentId)\n          if numRemovedElements == 1 then\n            if hard then\n              if parentPrefix == baseKey then\n                removeParentDependencyKey(missedParentKey, hard, nil, baseKey, nil)\n                removeJobKeys(missedParentKey)\n                if parentAttributes[2] then\n                  rcall("DEL", parentPrefix .. "de:" .. parentAttributes[2])\n                end\n              else\n                _moveParentToWait(parentPrefix, parentId)\n              end\n            else\n              _moveParentToWait(parentPrefix, parentId, true)\n            end\n          end\n        end\n        return true\n      end\n    end\n  end\n  return false\nend\nlocal function removeJob(jobId, hard, baseKey, shouldRemoveDeduplicationKey)\n  local jobKey = baseKey .. jobId\n  removeParentDependencyKey(jobKey, hard, nil, baseKey)\n  if shouldRemoveDeduplicationKey then\n    removeDeduplicationKeyIfNeededOnRemoval(baseKey, jobKey, jobId)\n  end\n  removeJobKeys(jobKey)\nend\nlocal function cleanList(listKey, jobKeyPrefix, rangeStart, rangeEnd,\n  timestamp, isWaiting, jobSchedulersKey)\n  local jobs = rcall("LRANGE", listKey, rangeStart, rangeEnd)\n  local deleted = {}\n  local deletedCount = 0\n  local jobTS\n  local deletionMarker = \'\'\n  local jobIdsLen = #jobs\n  for i, job in ipairs(jobs) do\n    if limit > 0 and deletedCount >= limit then\n      break\n    end\n    local jobKey = jobKeyPrefix .. job\n    if (isWaiting or rcall("EXISTS", jobKey .. ":lock") == 0) and\n      not isJobSchedulerJob(job, jobKey, jobSchedulersKey) then\n      -- Find the right timestamp of the job to compare to maxTimestamp:\n      -- * finishedOn says when the job was completed, but it isn\'t set unless the job has actually completed\n      -- * processedOn represents when the job was last attempted, but it doesn\'t get populated until\n      --   the job is first tried\n      -- * timestamp is the original job submission time\n      -- Fetch all three of these (in that order) and use the first one that is set so that we\'ll leave jobs\n      -- that have been active within the grace period:\n      jobTS = getTimestamp(jobKey, {"finishedOn", "processedOn", "timestamp"})\n      if (not jobTS or jobTS <= timestamp) then\n        -- replace the entry with a deletion marker; the actual deletion will\n        -- occur at the end of the script\n        rcall("LSET", listKey, rangeEnd - jobIdsLen + i, deletionMarker)\n        removeJob(job, true, jobKeyPrefix, true --[[remove debounce key]])\n        deletedCount = deletedCount + 1\n        table.insert(deleted, job)\n      end\n    end\n  end\n  rcall("LREM", listKey, 0, deletionMarker)\n  return {deleted, deletedCount}\nend\n--[[\n  Function to clean job set.\n  Returns jobIds and deleted count number.\n]] \n-- Includes\n--[[\n  Function to loop in batches.\n  Just a bit of warning, some commands as ZREM\n  could receive a maximum of 7000 parameters per call.\n]]\nlocal function batches(n, batchSize)\n  local i = 0\n  return function()\n    local from = i * batchSize + 1\n    i = i + 1\n    if (from <= n) then\n      local to = math.min(from + batchSize - 1, n)\n      return from, to\n    end\n  end\nend\n--[[\n  We use ZRANGEBYSCORE to make the case where we\'re deleting a limited number\n  of items in a sorted set only run a single iteration. If we simply used\n  ZRANGE, we may take a long time traversing through jobs that are within the\n  grace period.\n]]\nlocal function getJobsInZset(zsetKey, rangeEnd, limit)\n  if limit > 0 then\n    return rcall("ZRANGEBYSCORE", zsetKey, 0, rangeEnd, "LIMIT", 0, limit)\n  else\n    return rcall("ZRANGEBYSCORE", zsetKey, 0, rangeEnd)\n  end\nend\nlocal function cleanSet(\n    setKey,\n    jobKeyPrefix,\n    rangeEnd,\n    timestamp,\n    limit,\n    attributes,\n    isFinished,\n    jobSchedulersKey)\n    local jobs = getJobsInZset(setKey, rangeEnd, limit)\n    local deleted = {}\n    local deletedCount = 0\n    local jobTS\n    for i, job in ipairs(jobs) do\n        if limit > 0 and deletedCount >= limit then\n            break\n        end\n        local jobKey = jobKeyPrefix .. job\n        -- Extract a Job Scheduler Id from jobId ("repeat:job-scheduler-id:millis") \n        -- and check if it is in the scheduled jobs\n        if not (jobSchedulersKey and isJobSchedulerJob(job, jobKey, jobSchedulersKey)) then\n            if isFinished then\n                removeJob(job, true, jobKeyPrefix, true --[[remove debounce key]] )\n                deletedCount = deletedCount + 1\n                table.insert(deleted, job)\n            else\n                -- * finishedOn says when the job was completed, but it isn\'t set unless the job has actually completed\n                jobTS = getTimestamp(jobKey, attributes)\n                if (not jobTS or jobTS <= timestamp) then\n                    removeJob(job, true, jobKeyPrefix, true --[[remove debounce key]] )\n                    deletedCount = deletedCount + 1\n                    table.insert(deleted, job)\n                end\n            end\n        end\n    end\n    if (#deleted > 0) then\n        for from, to in batches(#deleted, 7000) do\n            rcall("ZREM", setKey, unpack(deleted, from, to))\n        end\n    end\n    return {deleted, deletedCount}\nend\nlocal result\nif ARGV[4] == "active" then\n  result = cleanList(KEYS[1], ARGV[1], rangeStart, rangeEnd, ARGV[2], false --[[ hasFinished ]],\n                      repeatKey)\nelseif ARGV[4] == "delayed" then\n  rangeEnd = "+inf"\n  result = cleanSet(KEYS[1], ARGV[1], rangeEnd, ARGV[2], limit,\n                    {"processedOn", "timestamp"}, false  --[[ hasFinished ]], repeatKey)\nelseif ARGV[4] == "prioritized" then\n  rangeEnd = "+inf"\n  result = cleanSet(KEYS[1], ARGV[1], rangeEnd, ARGV[2], limit,\n                    {"timestamp"}, false  --[[ hasFinished ]], repeatKey)\nelseif ARGV[4] == "wait" or ARGV[4] == "paused" then\n  result = cleanList(KEYS[1], ARGV[1], rangeStart, rangeEnd, ARGV[2], true --[[ hasFinished ]],\n                      repeatKey)\nelse\n  rangeEnd = ARGV[2]\n  -- No need to pass repeat key as in that moment job won\'t be related to a job scheduler\n  result = cleanSet(KEYS[1], ARGV[1], rangeEnd, ARGV[2], limit,\n                    {"finishedOn"}, true  --[[ hasFinished ]])\nend\nrcall("XADD", KEYS[2], "*", "event", "cleaned", "count", result[2])\nreturn result[1]\n',keys:3}},(e,t,n)=>{"use strict";n.r(t),n.d(t,{drain:()=>r});const r={name:"drain",content:'--[[\n  Drains the queue, removes all jobs that are waiting\n  or delayed, but not active, completed or failed\n  Input:\n    KEYS[1] \'wait\',\n    KEYS[2] \'paused\'\n    KEYS[3] \'delayed\'\n    KEYS[4] \'prioritized\'\n    KEYS[5] \'jobschedulers\' (repeat)\n    ARGV[1]  queue key prefix\n    ARGV[2]  should clean delayed jobs\n]]\nlocal rcall = redis.call\nlocal queueBaseKey = ARGV[1]\n--[[\n  Functions to remove jobs.\n]]\n-- Includes\n--[[\n  Function to filter out jobs to ignore from a table.\n]]\nlocal function filterOutJobsToIgnore(jobs, jobsToIgnore)\n  local filteredJobs = {}\n  for i = 1, #jobs do\n    if not jobsToIgnore[jobs[i]] then\n      table.insert(filteredJobs, jobs[i])\n    end\n  end\n  return filteredJobs\nend\n--[[\n  Functions to remove jobs.\n]]\n-- Includes\n--[[\n  Function to remove job.\n]]\n-- Includes\n--[[\n  Function to remove deduplication key if needed\n  when a job is being removed.\n]]\nlocal function removeDeduplicationKeyIfNeededOnRemoval(prefixKey,\n  jobKey, jobId)\n  local deduplicationId = rcall("HGET", jobKey, "deid")\n  if deduplicationId then\n    local deduplicationKey = prefixKey .. "de:" .. deduplicationId\n    local currentJobId = rcall(\'GET\', deduplicationKey)\n    if currentJobId and currentJobId == jobId then\n      return rcall("DEL", deduplicationKey)\n    end\n  end\nend\n--[[\n  Function to remove job keys.\n]]\nlocal function removeJobKeys(jobKey)\n  return rcall("DEL", jobKey, jobKey .. \':logs\', jobKey .. \':dependencies\',\n    jobKey .. \':processed\', jobKey .. \':failed\', jobKey .. \':unsuccessful\')\nend\n--[[\n  Check if this job has a parent. If so we will just remove it from\n  the parent child list, but if it is the last child we should move the parent to "wait/paused"\n  which requires code from "moveToFinished"\n]]\n-- Includes\n--[[\n  Function to add job in target list and add marker if needed.\n]]\n-- Includes\n--[[\n  Add marker if needed when a job is available.\n]]\nlocal function addBaseMarkerIfNeeded(markerKey, isPausedOrMaxed)\n  if not isPausedOrMaxed then\n    rcall("ZADD", markerKey, 0, "0")\n  end  \nend\nlocal function addJobInTargetList(targetKey, markerKey, pushCmd, isPausedOrMaxed, jobId)\n  rcall(pushCmd, targetKey, jobId)\n  addBaseMarkerIfNeeded(markerKey, isPausedOrMaxed)\nend\n--[[\n  Functions to destructure job key.\n  Just a bit of warning, these functions may be a bit slow and affect performance significantly.\n]]\nlocal getJobIdFromKey = function (jobKey)\n  return string.match(jobKey, ".*:(.*)")\nend\nlocal getJobKeyPrefix = function (jobKey, jobId)\n  return string.sub(jobKey, 0, #jobKey - #jobId)\nend\n--[[\n  Function to check for the meta.paused key to decide if we are paused or not\n  (since an empty list and !EXISTS are not really the same).\n]]\nlocal function getTargetQueueList(queueMetaKey, activeKey, waitKey, pausedKey)\n  local queueAttributes = rcall("HMGET", queueMetaKey, "paused", "concurrency")\n  if queueAttributes[1] then\n    return pausedKey, true\n  else\n    if queueAttributes[2] then\n      local activeCount = rcall("LLEN", activeKey)\n      if activeCount >= tonumber(queueAttributes[2]) then\n        return waitKey, true\n      else\n        return waitKey, false\n      end\n    end\n  end\n  return waitKey, false\nend\nlocal function _moveParentToWait(parentPrefix, parentId, emitEvent)\n  local parentTarget, isPausedOrMaxed = getTargetQueueList(parentPrefix .. "meta", parentPrefix .. "active",\n    parentPrefix .. "wait", parentPrefix .. "paused")\n  addJobInTargetList(parentTarget, parentPrefix .. "marker", "RPUSH", isPausedOrMaxed, parentId)\n  if emitEvent then\n    local parentEventStream = parentPrefix .. "events"\n    rcall("XADD", parentEventStream, "*", "event", "waiting", "jobId", parentId, "prev", "waiting-children")\n  end\nend\nlocal function removeParentDependencyKey(jobKey, hard, parentKey, baseKey, debounceId)\n  if parentKey then\n    local parentDependenciesKey = parentKey .. ":dependencies"\n    local result = rcall("SREM", parentDependenciesKey, jobKey)\n    if result > 0 then\n      local pendingDependencies = rcall("SCARD", parentDependenciesKey)\n      if pendingDependencies == 0 then\n        local parentId = getJobIdFromKey(parentKey)\n        local parentPrefix = getJobKeyPrefix(parentKey, parentId)\n        local numRemovedElements = rcall("ZREM", parentPrefix .. "waiting-children", parentId)\n        if numRemovedElements == 1 then\n          if hard then -- remove parent in same queue\n            if parentPrefix == baseKey then\n              removeParentDependencyKey(parentKey, hard, nil, baseKey, nil)\n              removeJobKeys(parentKey)\n              if debounceId then\n                rcall("DEL", parentPrefix .. "de:" .. debounceId)\n              end\n            else\n              _moveParentToWait(parentPrefix, parentId)\n            end\n          else\n            _moveParentToWait(parentPrefix, parentId, true)\n          end\n        end\n      end\n      return true\n    end\n  else\n    local parentAttributes = rcall("HMGET", jobKey, "parentKey", "deid")\n    local missedParentKey = parentAttributes[1]\n    if( (type(missedParentKey) == "string") and missedParentKey ~= ""\n      and (rcall("EXISTS", missedParentKey) == 1)) then\n      local parentDependenciesKey = missedParentKey .. ":dependencies"\n      local result = rcall("SREM", parentDependenciesKey, jobKey)\n      if result > 0 then\n        local pendingDependencies = rcall("SCARD", parentDependenciesKey)\n        if pendingDependencies == 0 then\n          local parentId = getJobIdFromKey(missedParentKey)\n          local parentPrefix = getJobKeyPrefix(missedParentKey, parentId)\n          local numRemovedElements = rcall("ZREM", parentPrefix .. "waiting-children", parentId)\n          if numRemovedElements == 1 then\n            if hard then\n              if parentPrefix == baseKey then\n                removeParentDependencyKey(missedParentKey, hard, nil, baseKey, nil)\n                removeJobKeys(missedParentKey)\n                if parentAttributes[2] then\n                  rcall("DEL", parentPrefix .. "de:" .. parentAttributes[2])\n                end\n              else\n                _moveParentToWait(parentPrefix, parentId)\n              end\n            else\n              _moveParentToWait(parentPrefix, parentId, true)\n            end\n          end\n        end\n        return true\n      end\n    end\n  end\n  return false\nend\nlocal function removeJob(jobId, hard, baseKey, shouldRemoveDeduplicationKey)\n  local jobKey = baseKey .. jobId\n  removeParentDependencyKey(jobKey, hard, nil, baseKey)\n  if shouldRemoveDeduplicationKey then\n    removeDeduplicationKeyIfNeededOnRemoval(baseKey, jobKey, jobId)\n  end\n  removeJobKeys(jobKey)\nend\nlocal function removeJobs(keys, hard, baseKey, max)\n  for i, key in ipairs(keys) do\n    removeJob(key, hard, baseKey, true --[[remove debounce key]])\n  end\n  return max - #keys\nend\nlocal function getListItems(keyName, max)\n  return rcall(\'LRANGE\', keyName, 0, max - 1)\nend\nlocal function removeListJobs(keyName, hard, baseKey, max, jobsToIgnore)\n  local jobs = getListItems(keyName, max)\n  if jobsToIgnore then\n    jobs = filterOutJobsToIgnore(jobs, jobsToIgnore)\n  end\n  local count = removeJobs(jobs, hard, baseKey, max)\n  rcall("LTRIM", keyName, #jobs, -1)\n  return count\nend\n-- Includes\n--[[\n  Function to loop in batches.\n  Just a bit of warning, some commands as ZREM\n  could receive a maximum of 7000 parameters per call.\n]]\nlocal function batches(n, batchSize)\n  local i = 0\n  return function()\n    local from = i * batchSize + 1\n    i = i + 1\n    if (from <= n) then\n      local to = math.min(from + batchSize - 1, n)\n      return from, to\n    end\n  end\nend\n--[[\n  Function to get ZSet items.\n]]\nlocal function getZSetItems(keyName, max)\n  return rcall(\'ZRANGE\', keyName, 0, max - 1)\nend\nlocal function removeZSetJobs(keyName, hard, baseKey, max, jobsToIgnore)\n  local jobs = getZSetItems(keyName, max)\n  if jobsToIgnore then\n    jobs = filterOutJobsToIgnore(jobs, jobsToIgnore)\n  end\n  local count = removeJobs(jobs, hard, baseKey, max)\n  if(#jobs > 0) then\n    for from, to in batches(#jobs, 7000) do\n      rcall("ZREM", keyName, unpack(jobs, from, to))\n    end\n  end\n  return count\nend\n-- We must not remove delayed jobs if they are associated to a job scheduler.\nlocal scheduledJobs = {}\nlocal jobSchedulers = rcall("ZRANGE", KEYS[5], 0, -1, "WITHSCORES")\n-- For every job scheduler, get the current delayed job id.\nfor i = 1, #jobSchedulers, 2 do\n    local jobSchedulerId = jobSchedulers[i]\n    local jobSchedulerMillis = jobSchedulers[i + 1]\n    local delayedJobId = "repeat:" .. jobSchedulerId .. ":" .. jobSchedulerMillis\n    scheduledJobs[delayedJobId] = true\nend\nremoveListJobs(KEYS[1], true, queueBaseKey, 0, scheduledJobs) -- wait\nremoveListJobs(KEYS[2], true, queueBaseKey, 0, scheduledJobs) -- paused\nif ARGV[2] == "1" then\n  removeZSetJobs(KEYS[3], true, queueBaseKey, 0, scheduledJobs) -- delayed\nend\nremoveZSetJobs(KEYS[4], true, queueBaseKey, 0, scheduledJobs) -- prioritized\n',keys:5}},(e,t,n)=>{"use strict";n.r(t),n.d(t,{extendLock:()=>r});const r={name:"extendLock",content:'--[[\n  Extend lock and removes the job from the stalled set.\n  Input:\n    KEYS[1] \'lock\',\n    KEYS[2] \'stalled\'\n    ARGV[1]  token\n    ARGV[2]  lock duration in milliseconds\n    ARGV[3]  jobid\n  Output:\n    "1" if lock extented succesfully.\n]]\nlocal rcall = redis.call\nif rcall("GET", KEYS[1]) == ARGV[1] then\n  --   if rcall("SET", KEYS[1], ARGV[1], "PX", ARGV[2], "XX") then\n  if rcall("SET", KEYS[1], ARGV[1], "PX", ARGV[2]) then\n    rcall("SREM", KEYS[2], ARGV[3])\n    return 1\n  end\nend\nreturn 0\n',keys:2}},(e,t,n)=>{"use strict";n.r(t),n.d(t,{extendLocks:()=>r});const r={name:"extendLocks",content:'--[[\n  Extend locks for multiple jobs and remove them from the stalled set if successful.\n  Return the list of job IDs for which the operation failed.\n  KEYS[1] = stalledKey\n  ARGV[1] = baseKey\n  ARGV[2] = tokens\n  ARGV[3] = jobIds\n  ARGV[4] = lockDuration (ms)\n  Output:\n    An array of failed job IDs. If empty, all succeeded.\n]]\nlocal rcall = redis.call\nlocal stalledKey = KEYS[1]\nlocal baseKey = ARGV[1]\nlocal tokens = cmsgpack.unpack(ARGV[2])\nlocal jobIds = cmsgpack.unpack(ARGV[3])\nlocal lockDuration = ARGV[4]\nlocal jobCount = #jobIds\nlocal failedJobs = {}\nfor i = 1, jobCount, 1 do\n    local lockKey = baseKey .. jobIds[i] .. \':lock\'\n    local jobId = jobIds[i]\n    local token = tokens[i]\n    local currentToken = rcall("GET", lockKey)\n    if currentToken == token then\n        local setResult = rcall("SET", lockKey, token, "PX", lockDuration)\n        if setResult then\n            rcall("SREM", stalledKey, jobId)\n        else\n            table.insert(failedJobs, jobId)\n        end\n    else\n        table.insert(failedJobs, jobId)\n    end\nend\nreturn failedJobs\n',keys:1}},(e,t,n)=>{"use strict";n.r(t),n.d(t,{getCounts:()=>r});const r={name:"getCounts",content:'--[[\n  Get counts per provided states\n    Input:\n      KEYS[1]    \'prefix\'\n      ARGV[1...] types\n]]\nlocal rcall = redis.call;\nlocal prefix = KEYS[1]\nlocal results = {}\nfor i = 1, #ARGV do\n  local stateKey = prefix .. ARGV[i]\n  if ARGV[i] == "wait" or ARGV[i] == "paused" then\n    -- Markers in waitlist DEPRECATED in v5: Remove in v6.\n    local marker = rcall("LINDEX", stateKey, -1)\n    if marker and string.sub(marker, 1, 2) == "0:" then\n      local count = rcall("LLEN", stateKey)\n      if count > 1 then\n        rcall("RPOP", stateKey)\n        results[#results+1] = count-1\n      else\n        results[#results+1] = 0\n      end\n    else\n      results[#results+1] = rcall("LLEN", stateKey)\n    end\n  elseif ARGV[i] == "active" then\n    results[#results+1] = rcall("LLEN", stateKey)\n  else\n    results[#results+1] = rcall("ZCARD", stateKey)\n  end\nend\nreturn results\n',keys:1}},(e,t,n)=>{"use strict";n.r(t),n.d(t,{getCountsPerPriority:()=>r});const r={name:"getCountsPerPriority",content:'--[[\n  Get counts per provided states\n    Input:\n      KEYS[1] wait key\n      KEYS[2] paused key\n      KEYS[3] meta key\n      KEYS[4] prioritized key\n      ARGV[1...] priorities\n]]\nlocal rcall = redis.call\nlocal results = {}\nlocal waitKey = KEYS[1]\nlocal pausedKey = KEYS[2]\nlocal prioritizedKey = KEYS[4]\n-- Includes\n--[[\n  Function to check for the meta.paused key to decide if we are paused or not\n  (since an empty list and !EXISTS are not really the same).\n]]\nlocal function isQueuePaused(queueMetaKey)\n  return rcall("HEXISTS", queueMetaKey, "paused") == 1\nend\nfor i = 1, #ARGV do\n  local priority = tonumber(ARGV[i])\n  if priority == 0 then\n    if isQueuePaused(KEYS[3]) then\n      results[#results+1] = rcall("LLEN", pausedKey)\n    else\n      results[#results+1] = rcall("LLEN", waitKey)\n    end\n  else\n    results[#results+1] = rcall("ZCOUNT", prioritizedKey,\n      priority * 0x100000000, (priority + 1)  * 0x100000000 - 1)\n  end\nend\nreturn results\n',keys:4}},(e,t,n)=>{"use strict";n.r(t),n.d(t,{getDependencyCounts:()=>r});const r={name:"getDependencyCounts",content:'--[[\n  Get counts per child states\n    Input:\n      KEYS[1]    processed key\n      KEYS[2]    unprocessed key\n      KEYS[3]    ignored key\n      KEYS[4]    failed key\n      ARGV[1...] types\n]]\nlocal rcall = redis.call;\nlocal processedKey = KEYS[1]\nlocal unprocessedKey = KEYS[2]\nlocal ignoredKey = KEYS[3]\nlocal failedKey = KEYS[4]\nlocal results = {}\nfor i = 1, #ARGV do\n  if ARGV[i] == "processed" then\n    results[#results+1] = rcall("HLEN", processedKey)\n  elseif ARGV[i] == "unprocessed" then\n    results[#results+1] = rcall("SCARD", unprocessedKey)\n  elseif ARGV[i] == "ignored" then\n    results[#results+1] = rcall("HLEN", ignoredKey)\n  else\n    results[#results+1] = rcall("ZCARD", failedKey)\n  end\nend\nreturn results\n',keys:4}},(e,t,n)=>{"use strict";n.r(t),n.d(t,{getJobScheduler:()=>r});const r={name:"getJobScheduler",content:'--[[\n  Get job scheduler record.\n  Input:\n    KEYS[1] \'repeat\' key\n    ARGV[1] id\n]]\nlocal rcall = redis.call\nlocal jobSchedulerKey = KEYS[1] .. ":" .. ARGV[1]\nlocal score = rcall("ZSCORE", KEYS[1], ARGV[1])\nif score then\n  return {rcall("HGETALL", jobSchedulerKey), score} -- get job data\nend\nreturn {nil, nil}\n',keys:1}},(e,t,n)=>{"use strict";n.r(t),n.d(t,{getRanges:()=>r});const r={name:"getRanges",content:'--[[\n  Get job ids per provided states\n    Input:\n      KEYS[1]    \'prefix\'\n      ARGV[1]    start\n      ARGV[2]    end\n      ARGV[3]    asc\n      ARGV[4...] types\n]]\nlocal rcall = redis.call\nlocal prefix = KEYS[1]\nlocal rangeStart = tonumber(ARGV[1])\nlocal rangeEnd = tonumber(ARGV[2])\nlocal asc = ARGV[3]\nlocal results = {}\nlocal function getRangeInList(listKey, asc, rangeStart, rangeEnd, results)\n  if asc == "1" then\n    local modifiedRangeStart\n    local modifiedRangeEnd\n    if rangeStart == -1 then\n      modifiedRangeStart = 0\n    else\n      modifiedRangeStart = -(rangeStart + 1)\n    end\n    if rangeEnd == -1 then\n      modifiedRangeEnd = 0\n    else\n      modifiedRangeEnd = -(rangeEnd + 1)\n    end\n    results[#results+1] = rcall("LRANGE", listKey,\n      modifiedRangeEnd,\n      modifiedRangeStart)\n  else\n    results[#results+1] = rcall("LRANGE", listKey, rangeStart, rangeEnd)\n  end\nend\nfor i = 4, #ARGV do\n  local stateKey = prefix .. ARGV[i]\n  if ARGV[i] == "wait" or ARGV[i] == "paused" then\n    -- Markers in waitlist DEPRECATED in v5: Remove in v6.\n    local marker = rcall("LINDEX", stateKey, -1)\n    if marker and string.sub(marker, 1, 2) == "0:" then\n      local count = rcall("LLEN", stateKey)\n      if count > 1 then\n        rcall("RPOP", stateKey)\n        getRangeInList(stateKey, asc, rangeStart, rangeEnd, results)\n      else\n        results[#results+1] = {}\n      end\n    else\n      getRangeInList(stateKey, asc, rangeStart, rangeEnd, results)\n    end\n  elseif ARGV[i] == "active" then\n    getRangeInList(stateKey, asc, rangeStart, rangeEnd, results)\n  else\n    if asc == "1" then\n      results[#results+1] = rcall("ZRANGE", stateKey, rangeStart, rangeEnd)\n    else\n      results[#results+1] = rcall("ZREVRANGE", stateKey, rangeStart, rangeEnd)\n    end\n  end\nend\nreturn results\n',keys:1}},(e,t,n)=>{"use strict";n.r(t),n.d(t,{getRateLimitTtl:()=>r});const r={name:"getRateLimitTtl",content:'--[[\n  Get rate limit ttl\n    Input:\n      KEYS[1] \'limiter\'\n      ARGV[1] maxJobs\n]]\nlocal rcall = redis.call\n-- Includes\n--[[\n  Function to get current rate limit ttl.\n]]\nlocal function getRateLimitTTL(maxJobs, rateLimiterKey)\n  if maxJobs and maxJobs <= tonumber(rcall("GET", rateLimiterKey) or 0) then\n    local pttl = rcall("PTTL", rateLimiterKey)\n    if pttl == 0 then\n      rcall("DEL", rateLimiterKey)\n    end\n    if pttl > 0 then\n      return pttl\n    end\n  end\n  return 0\nend\nlocal rateLimiterKey = KEYS[1]\nif ARGV[1] ~= "0" then\n  return getRateLimitTTL(tonumber(ARGV[1]), rateLimiterKey)\nelse\n  return rcall("PTTL", rateLimiterKey)\nend\n',keys:1}},(e,t,n)=>{"use strict";n.r(t),n.d(t,{getState:()=>r});const r={name:"getState",content:'--[[\n  Get a job state\n  Input: \n    KEYS[1] \'completed\' key,\n    KEYS[2] \'failed\' key\n    KEYS[3] \'delayed\' key\n    KEYS[4] \'active\' key\n    KEYS[5] \'wait\' key\n    KEYS[6] \'paused\' key\n    KEYS[7] \'waiting-children\' key\n    KEYS[8] \'prioritized\' key\n    ARGV[1] job id\n  Output:\n    \'completed\'\n    \'failed\'\n    \'delayed\'\n    \'active\'\n    \'prioritized\'\n    \'waiting\'\n    \'waiting-children\'\n    \'unknown\'\n]]\nlocal rcall = redis.call\nif rcall("ZSCORE", KEYS[1], ARGV[1]) then\n  return "completed"\nend\nif rcall("ZSCORE", KEYS[2], ARGV[1]) then\n  return "failed"\nend\nif rcall("ZSCORE", KEYS[3], ARGV[1]) then\n  return "delayed"\nend\nif rcall("ZSCORE", KEYS[8], ARGV[1]) then\n  return "prioritized"\nend\n-- Includes\n--[[\n  Functions to check if a item belongs to a list.\n]]\nlocal function checkItemInList(list, item)\n  for _, v in pairs(list) do\n    if v == item then\n      return 1\n    end\n  end\n  return nil\nend\nlocal active_items = rcall("LRANGE", KEYS[4] , 0, -1)\nif checkItemInList(active_items, ARGV[1]) ~= nil then\n  return "active"\nend\nlocal wait_items = rcall("LRANGE", KEYS[5] , 0, -1)\nif checkItemInList(wait_items, ARGV[1]) ~= nil then\n  return "waiting"\nend\nlocal paused_items = rcall("LRANGE", KEYS[6] , 0, -1)\nif checkItemInList(paused_items, ARGV[1]) ~= nil then\n  return "waiting"\nend\nif rcall("ZSCORE", KEYS[7], ARGV[1]) then\n  return "waiting-children"\nend\nreturn "unknown"\n',keys:8}},(e,t,n)=>{"use strict";n.r(t),n.d(t,{getStateV2:()=>r});const r={name:"getStateV2",content:'--[[\n  Get a job state\n  Input: \n    KEYS[1] \'completed\' key,\n    KEYS[2] \'failed\' key\n    KEYS[3] \'delayed\' key\n    KEYS[4] \'active\' key\n    KEYS[5] \'wait\' key\n    KEYS[6] \'paused\' key\n    KEYS[7] \'waiting-children\' key\n    KEYS[8] \'prioritized\' key\n    ARGV[1] job id\n  Output:\n    \'completed\'\n    \'failed\'\n    \'delayed\'\n    \'active\'\n    \'waiting\'\n    \'waiting-children\'\n    \'unknown\'\n]]\nlocal rcall = redis.call\nif rcall("ZSCORE", KEYS[1], ARGV[1]) then\n  return "completed"\nend\nif rcall("ZSCORE", KEYS[2], ARGV[1]) then\n  return "failed"\nend\nif rcall("ZSCORE", KEYS[3], ARGV[1]) then\n  return "delayed"\nend\nif rcall("ZSCORE", KEYS[8], ARGV[1]) then\n  return "prioritized"\nend\nif rcall("LPOS", KEYS[4] , ARGV[1]) then\n  return "active"\nend\nif rcall("LPOS", KEYS[5] , ARGV[1]) then\n  return "waiting"\nend\nif rcall("LPOS", KEYS[6] , ARGV[1]) then\n  return "waiting"\nend\nif rcall("ZSCORE", KEYS[7] , ARGV[1]) then\n  return "waiting-children"\nend\nreturn "unknown"\n',keys:8}},(e,t,n)=>{"use strict";n.r(t),n.d(t,{isFinished:()=>r});const r={name:"isFinished",content:'--[[\n  Checks if a job is finished (.i.e. is in the completed or failed set)\n  Input: \n    KEYS[1] completed key\n    KEYS[2] failed key\n    KEYS[3] job key\n    ARGV[1] job id\n    ARGV[2] return value?\n  Output:\n    0 - Not finished.\n    1 - Completed.\n    2 - Failed.\n   -1 - Missing job. \n]]\nlocal rcall = redis.call\nif rcall("EXISTS", KEYS[3]) ~= 1 then\n  if ARGV[2] == "1" then\n    return {-1,"Missing key for job " .. KEYS[3] .. ". isFinished"}\n  end  \n  return -1\nend\nif rcall("ZSCORE", KEYS[1], ARGV[1]) then\n  if ARGV[2] == "1" then\n    local returnValue = rcall("HGET", KEYS[3], "returnvalue")\n    return {1,returnValue}\n  end\n  return 1\nend\nif rcall("ZSCORE", KEYS[2], ARGV[1]) then\n  if ARGV[2] == "1" then\n    local failedReason = rcall("HGET", KEYS[3], "failedReason")\n    return {2,failedReason}\n  end\n  return 2\nend\nif ARGV[2] == "1" then\n  return {0}\nend\nreturn 0\n',keys:3}},(e,t,n)=>{"use strict";n.r(t),n.d(t,{isJobInList:()=>r});const r={name:"isJobInList",content:'--[[\n  Checks if job is in a given list.\n  Input:\n    KEYS[1]\n    ARGV[1]\n  Output:\n    1 if element found in the list.\n]]\n-- Includes\n--[[\n  Functions to check if a item belongs to a list.\n]]\nlocal function checkItemInList(list, item)\n  for _, v in pairs(list) do\n    if v == item then\n      return 1\n    end\n  end\n  return nil\nend\nlocal items = redis.call("LRANGE", KEYS[1] , 0, -1)\nreturn checkItemInList(items, ARGV[1])\n',keys:1}},(e,t,n)=>{"use strict";n.r(t),n.d(t,{isMaxed:()=>r});const r={name:"isMaxed",content:'--[[\n  Checks if queue is maxed.\n  Input:\n    KEYS[1] meta key\n    KEYS[2] active key\n  Output:\n    1 if element found in the list.\n]]\nlocal rcall = redis.call\n-- Includes\n--[[\n  Function to check if queue is maxed or not.\n]]\nlocal function isQueueMaxed(queueMetaKey, activeKey)\n  local maxConcurrency = rcall("HGET", queueMetaKey, "concurrency")\n  if maxConcurrency then\n    local activeCount = rcall("LLEN", activeKey)\n    if activeCount >= tonumber(maxConcurrency) then\n      return true\n    end\n  end\n  return false\nend\nreturn isQueueMaxed(KEYS[1], KEYS[2])\n',keys:2}},(e,t,n)=>{"use strict";n.r(t),n.d(t,{moveJobFromActiveToWait:()=>r});const r={name:"moveJobFromActiveToWait",content:'--[[\n  Function to move job from active state to wait.\n  Input:\n    KEYS[1]  active key\n    KEYS[2]  wait key\n    KEYS[3]  stalled key\n    KEYS[4]  paused key\n    KEYS[5]  meta key\n    KEYS[6]  limiter key\n    KEYS[7]  prioritized key\n    KEYS[8]  marker key\n    KEYS[9] event key\n    ARGV[1] job id\n    ARGV[2] lock token\n    ARGV[3] job id key\n]]\nlocal rcall = redis.call\n-- Includes\n--[[\n  Function to add job in target list and add marker if needed.\n]]\n-- Includes\n--[[\n  Add marker if needed when a job is available.\n]]\nlocal function addBaseMarkerIfNeeded(markerKey, isPausedOrMaxed)\n  if not isPausedOrMaxed then\n    rcall("ZADD", markerKey, 0, "0")\n  end  \nend\nlocal function addJobInTargetList(targetKey, markerKey, pushCmd, isPausedOrMaxed, jobId)\n  rcall(pushCmd, targetKey, jobId)\n  addBaseMarkerIfNeeded(markerKey, isPausedOrMaxed)\nend\n--[[\n  Function to push back job considering priority in front of same prioritized jobs.\n]]\nlocal function pushBackJobWithPriority(prioritizedKey, priority, jobId)\n  -- in order to put it at front of same prioritized jobs\n  -- we consider prioritized counter as 0\n  local score = priority * 0x100000000\n  rcall("ZADD", prioritizedKey, score, jobId)\nend\n--[[\n  Function to get max events value or set by default 10000.\n]]\nlocal function getOrSetMaxEvents(metaKey)\n  local maxEvents = rcall("HGET", metaKey, "opts.maxLenEvents")\n  if not maxEvents then\n    maxEvents = 10000\n    rcall("HSET", metaKey, "opts.maxLenEvents", maxEvents)\n  end\n  return maxEvents\nend\n--[[\n  Function to check for the meta.paused key to decide if we are paused or not\n  (since an empty list and !EXISTS are not really the same).\n]]\nlocal function getTargetQueueList(queueMetaKey, activeKey, waitKey, pausedKey)\n  local queueAttributes = rcall("HMGET", queueMetaKey, "paused", "concurrency")\n  if queueAttributes[1] then\n    return pausedKey, true\n  else\n    if queueAttributes[2] then\n      local activeCount = rcall("LLEN", activeKey)\n      if activeCount >= tonumber(queueAttributes[2]) then\n        return waitKey, true\n      else\n        return waitKey, false\n      end\n    end\n  end\n  return waitKey, false\nend\nlocal function removeLock(jobKey, stalledKey, token, jobId)\n  if token ~= "0" then\n    local lockKey = jobKey .. \':lock\'\n    local lockToken = rcall("GET", lockKey)\n    if lockToken == token then\n      rcall("DEL", lockKey)\n      rcall("SREM", stalledKey, jobId)\n    else\n      if lockToken then\n        -- Lock exists but token does not match\n        return -6\n      else\n        -- Lock is missing completely\n        return -2\n      end\n    end\n  end\n  return 0\nend\nlocal jobId = ARGV[1]\nlocal token = ARGV[2]\nlocal jobKey = ARGV[3]\nlocal errorCode = removeLock(jobKey, KEYS[3], token, jobId)\nif errorCode < 0 then\n  return errorCode\nend\nlocal metaKey = KEYS[5]\nlocal removed = rcall("LREM", KEYS[1], 1, jobId)\nif removed > 0 then\n  local target, isPausedOrMaxed = getTargetQueueList(metaKey, KEYS[1], KEYS[2], KEYS[4])\n  local priority = tonumber(rcall("HGET", ARGV[3], "priority")) or 0\n  if priority > 0 then\n    pushBackJobWithPriority(KEYS[7], priority, jobId)\n  else\n    addJobInTargetList(target, KEYS[8], "RPUSH", isPausedOrMaxed, jobId)\n  end\n  local maxEvents = getOrSetMaxEvents(metaKey)\n  -- Emit waiting event\n  rcall("XADD", KEYS[9], "MAXLEN", "~", maxEvents, "*", "event", "waiting",\n    "jobId", jobId, "prev", "active")\nend\nlocal pttl = rcall("PTTL", KEYS[6])\nif pttl > 0 then\n  return pttl\nelse\n  return 0\nend',keys:9}},(e,t,n)=>{"use strict";n.r(t),n.d(t,{moveJobsToWait:()=>r});const r={name:"moveJobsToWait",content:'--[[\n  Move completed, failed or delayed jobs to wait.\n  Note: Does not support jobs with priorities.\n  Input:\n    KEYS[1] base key\n    KEYS[2] events stream\n    KEYS[3] state key (failed, completed, delayed)\n    KEYS[4] \'wait\'\n    KEYS[5] \'paused\'\n    KEYS[6] \'meta\'\n    KEYS[7] \'active\'\n    KEYS[8] \'marker\'\n    ARGV[1] count\n    ARGV[2] timestamp\n    ARGV[3] prev state\n  Output:\n    1  means the operation is not completed\n    0  means the operation is completed\n]]\nlocal maxCount = tonumber(ARGV[1])\nlocal timestamp = tonumber(ARGV[2])\nlocal rcall = redis.call;\n-- Includes\n--[[\n  Add marker if needed when a job is available.\n]]\nlocal function addBaseMarkerIfNeeded(markerKey, isPausedOrMaxed)\n  if not isPausedOrMaxed then\n    rcall("ZADD", markerKey, 0, "0")\n  end  \nend\n--[[\n  Function to loop in batches.\n  Just a bit of warning, some commands as ZREM\n  could receive a maximum of 7000 parameters per call.\n]]\nlocal function batches(n, batchSize)\n  local i = 0\n  return function()\n    local from = i * batchSize + 1\n    i = i + 1\n    if (from <= n) then\n      local to = math.min(from + batchSize - 1, n)\n      return from, to\n    end\n  end\nend\n--[[\n  Function to get max events value or set by default 10000.\n]]\nlocal function getOrSetMaxEvents(metaKey)\n  local maxEvents = rcall("HGET", metaKey, "opts.maxLenEvents")\n  if not maxEvents then\n    maxEvents = 10000\n    rcall("HSET", metaKey, "opts.maxLenEvents", maxEvents)\n  end\n  return maxEvents\nend\n--[[\n  Function to check for the meta.paused key to decide if we are paused or not\n  (since an empty list and !EXISTS are not really the same).\n]]\nlocal function getTargetQueueList(queueMetaKey, activeKey, waitKey, pausedKey)\n  local queueAttributes = rcall("HMGET", queueMetaKey, "paused", "concurrency")\n  if queueAttributes[1] then\n    return pausedKey, true\n  else\n    if queueAttributes[2] then\n      local activeCount = rcall("LLEN", activeKey)\n      if activeCount >= tonumber(queueAttributes[2]) then\n        return waitKey, true\n      else\n        return waitKey, false\n      end\n    end\n  end\n  return waitKey, false\nend\nlocal metaKey = KEYS[6]\nlocal target, isPausedOrMaxed = getTargetQueueList(metaKey, KEYS[7], KEYS[4], KEYS[5])\nlocal jobs = rcall(\'ZRANGEBYSCORE\', KEYS[3], 0, timestamp, \'LIMIT\', 0, maxCount)\nif (#jobs > 0) then\n    if ARGV[3] == "failed" then\n        for i, key in ipairs(jobs) do\n            local jobKey = KEYS[1] .. key\n            rcall("HDEL", jobKey, "finishedOn", "processedOn", "failedReason")\n        end\n    elseif ARGV[3] == "completed" then\n        for i, key in ipairs(jobs) do\n            local jobKey = KEYS[1] .. key\n            rcall("HDEL", jobKey, "finishedOn", "processedOn", "returnvalue")\n        end\n    end\n    local maxEvents = getOrSetMaxEvents(metaKey)\n    for i, key in ipairs(jobs) do\n        -- Emit waiting event\n        rcall("XADD", KEYS[2], "MAXLEN", "~", maxEvents, "*", "event",\n              "waiting", "jobId", key, "prev", ARGV[3]);\n    end\n    for from, to in batches(#jobs, 7000) do\n        rcall("ZREM", KEYS[3], unpack(jobs, from, to))\n        rcall("LPUSH", target, unpack(jobs, from, to))\n    end\n    addBaseMarkerIfNeeded(KEYS[8], isPausedOrMaxed)\nend\nmaxCount = maxCount - #jobs\nif (maxCount <= 0) then return 1 end\nreturn 0\n',keys:8}},(e,t,n)=>{"use strict";n.r(t),n.d(t,{moveStalledJobsToWait:()=>r});const r={name:"moveStalledJobsToWait",content:'--[[\n  Move stalled jobs to wait.\n    Input:\n      KEYS[1] \'stalled\' (SET)\n      KEYS[2] \'wait\',   (LIST)\n      KEYS[3] \'active\', (LIST)\n      KEYS[4] \'stalled-check\', (KEY)\n      KEYS[5] \'meta\', (KEY)\n      KEYS[6] \'paused\', (LIST)\n      KEYS[7] \'marker\'\n      KEYS[8] \'event stream\' (STREAM)\n      ARGV[1]  Max stalled job count\n      ARGV[2]  queue.toKey(\'\')\n      ARGV[3]  timestamp\n      ARGV[4]  max check time\n    Events:\n      \'stalled\' with stalled job id.\n]]\nlocal rcall = redis.call\n-- Includes\n--[[\n  Function to add job in target list and add marker if needed.\n]]\n-- Includes\n--[[\n  Add marker if needed when a job is available.\n]]\nlocal function addBaseMarkerIfNeeded(markerKey, isPausedOrMaxed)\n  if not isPausedOrMaxed then\n    rcall("ZADD", markerKey, 0, "0")\n  end  \nend\nlocal function addJobInTargetList(targetKey, markerKey, pushCmd, isPausedOrMaxed, jobId)\n  rcall(pushCmd, targetKey, jobId)\n  addBaseMarkerIfNeeded(markerKey, isPausedOrMaxed)\nend\n--[[\n  Function to loop in batches.\n  Just a bit of warning, some commands as ZREM\n  could receive a maximum of 7000 parameters per call.\n]]\nlocal function batches(n, batchSize)\n  local i = 0\n  return function()\n    local from = i * batchSize + 1\n    i = i + 1\n    if (from <= n) then\n      local to = math.min(from + batchSize - 1, n)\n      return from, to\n    end\n  end\nend\n--[[\n  Function to check for the meta.paused key to decide if we are paused or not\n  (since an empty list and !EXISTS are not really the same).\n]]\nlocal function getTargetQueueList(queueMetaKey, activeKey, waitKey, pausedKey)\n  local queueAttributes = rcall("HMGET", queueMetaKey, "paused", "concurrency")\n  if queueAttributes[1] then\n    return pausedKey, true\n  else\n    if queueAttributes[2] then\n      local activeCount = rcall("LLEN", activeKey)\n      if activeCount >= tonumber(queueAttributes[2]) then\n        return waitKey, true\n      else\n        return waitKey, false\n      end\n    end\n  end\n  return waitKey, false\nend\n--[[\n  Function to trim events, default 10000.\n]]\n-- Includes\n--[[\n  Function to get max events value or set by default 10000.\n]]\nlocal function getOrSetMaxEvents(metaKey)\n  local maxEvents = rcall("HGET", metaKey, "opts.maxLenEvents")\n  if not maxEvents then\n    maxEvents = 10000\n    rcall("HSET", metaKey, "opts.maxLenEvents", maxEvents)\n  end\n  return maxEvents\nend\nlocal function trimEvents(metaKey, eventStreamKey)\n  local maxEvents = getOrSetMaxEvents(metaKey)\n  if maxEvents then\n    rcall("XTRIM", eventStreamKey, "MAXLEN", "~", maxEvents)\n  else\n    rcall("XTRIM", eventStreamKey, "MAXLEN", "~", 10000)\n  end\nend\nlocal stalledKey = KEYS[1]\nlocal waitKey = KEYS[2]\nlocal activeKey = KEYS[3]\nlocal stalledCheckKey = KEYS[4]\nlocal metaKey = KEYS[5]\nlocal pausedKey = KEYS[6]\nlocal markerKey = KEYS[7]\nlocal eventStreamKey = KEYS[8]\nlocal maxStalledJobCount = tonumber(ARGV[1])\nlocal queueKeyPrefix = ARGV[2]\nlocal timestamp = ARGV[3]\nlocal maxCheckTime = ARGV[4]\nif rcall("EXISTS", stalledCheckKey) == 1 then\n    return {}\nend\nrcall("SET", stalledCheckKey, timestamp, "PX", maxCheckTime)\n-- Trim events before emiting them to avoid trimming events emitted in this script\ntrimEvents(metaKey, eventStreamKey)\n-- Move all stalled jobs to wait\nlocal stalling = rcall(\'SMEMBERS\', stalledKey)\nlocal stalled = {}\nif (#stalling > 0) then\n    rcall(\'DEL\', stalledKey)\n    -- Remove from active list\n    for i, jobId in ipairs(stalling) do\n        -- Markers in waitlist DEPRECATED in v5: Remove in v6.\n        if string.sub(jobId, 1, 2) == "0:" then\n            -- If the jobId is a delay marker ID we just remove it.\n            rcall("LREM", activeKey, 1, jobId)\n        else\n            local jobKey = queueKeyPrefix .. jobId\n            -- Check that the lock is also missing, then we can handle this job as really stalled.\n            if (rcall("EXISTS", jobKey .. ":lock") == 0) then\n                --  Remove from the active queue.\n                local removed = rcall("LREM", activeKey, 1, jobId)\n                if (removed > 0) then\n                    -- If this job has been stalled too many times, such as if it crashes the worker, then fail it.\n                    local stalledCount = rcall("HINCRBY", jobKey, "stc", 1)\n                    if stalledCount > maxStalledJobCount then\n                        local jobAttributes = rcall("HMGET", jobKey, "opts", "parent")\n                        local rawOpts = jobAttributes[1]\n                        local rawParentData = jobAttributes[2]\n                        local opts = cjson.decode(rawOpts)\n                        local failedReason = "job stalled more than allowable limit"\n                        rcall("HSET", jobKey, "defa", failedReason)\n                    end\n                    local target, isPausedOrMaxed = getTargetQueueList(metaKey, activeKey, waitKey, pausedKey)\n                    -- Move the job back to the wait queue, to immediately be picked up by a waiting worker.\n                    addJobInTargetList(target, markerKey, "RPUSH", isPausedOrMaxed, jobId)\n                    rcall("XADD", eventStreamKey, "*", "event", "waiting", "jobId", jobId, \'prev\', \'active\')\n                    -- Emit the stalled event\n                    rcall("XADD", eventStreamKey, "*", "event", "stalled", "jobId", jobId)\n                    table.insert(stalled, jobId)\n                end\n            end\n        end\n    end\nend\n-- Mark potentially stalled jobs\nlocal active = rcall(\'LRANGE\', activeKey, 0, -1)\nif (#active > 0) then\n    for from, to in batches(#active, 7000) do\n        rcall(\'SADD\', stalledKey, unpack(active, from, to))\n    end\nend\nreturn stalled\n',keys:8}},(e,t,n)=>{"use strict";n.r(t),n.d(t,{moveToActive:()=>r});const r={name:"moveToActive",content:'--[[\n  Move next job to be processed to active, lock it and fetch its data. The job\n  may be delayed, in that case we need to move it to the delayed set instead.\n  This operation guarantees that the worker owns the job during the lock\n  expiration time. The worker is responsible of keeping the lock fresh\n  so that no other worker picks this job again.\n  Input:\n    KEYS[1] wait key\n    KEYS[2] active key\n    KEYS[3] prioritized key\n    KEYS[4] stream events key\n    KEYS[5] stalled key\n    -- Rate limiting\n    KEYS[6] rate limiter key\n    KEYS[7] delayed key\n    -- Delayed jobs\n    KEYS[8] paused key\n    KEYS[9] meta key\n    KEYS[10] pc priority counter\n    -- Marker\n    KEYS[11] marker key\n    -- Arguments\n    ARGV[1] key prefix\n    ARGV[2] timestamp\n    ARGV[3] opts\n    opts - token - lock token\n    opts - lockDuration\n    opts - limiter\n    opts - name - worker name\n]]\nlocal rcall = redis.call\nlocal waitKey = KEYS[1]\nlocal activeKey = KEYS[2]\nlocal eventStreamKey = KEYS[4]\nlocal rateLimiterKey = KEYS[6]\nlocal delayedKey = KEYS[7]\nlocal opts = cmsgpack.unpack(ARGV[3])\n-- Includes\n--[[\n  Function to return the next delayed job timestamp.\n]]\nlocal function getNextDelayedTimestamp(delayedKey)\n  local result = rcall("ZRANGE", delayedKey, 0, 0, "WITHSCORES")\n  if #result then\n    local nextTimestamp = tonumber(result[2])\n    if nextTimestamp ~= nil then\n      return nextTimestamp / 0x1000\n    end\n  end\nend\n--[[\n  Function to get current rate limit ttl.\n]]\nlocal function getRateLimitTTL(maxJobs, rateLimiterKey)\n  if maxJobs and maxJobs <= tonumber(rcall("GET", rateLimiterKey) or 0) then\n    local pttl = rcall("PTTL", rateLimiterKey)\n    if pttl == 0 then\n      rcall("DEL", rateLimiterKey)\n    end\n    if pttl > 0 then\n      return pttl\n    end\n  end\n  return 0\nend\n--[[\n  Function to check for the meta.paused key to decide if we are paused or not\n  (since an empty list and !EXISTS are not really the same).\n]]\nlocal function getTargetQueueList(queueMetaKey, activeKey, waitKey, pausedKey)\n  local queueAttributes = rcall("HMGET", queueMetaKey, "paused", "concurrency")\n  if queueAttributes[1] then\n    return pausedKey, true\n  else\n    if queueAttributes[2] then\n      local activeCount = rcall("LLEN", activeKey)\n      if activeCount >= tonumber(queueAttributes[2]) then\n        return waitKey, true\n      else\n        return waitKey, false\n      end\n    end\n  end\n  return waitKey, false\nend\n--[[\n  Function to move job from prioritized state to active.\n]]\nlocal function moveJobFromPrioritizedToActive(priorityKey, activeKey, priorityCounterKey)\n  local prioritizedJob = rcall("ZPOPMIN", priorityKey)\n  if #prioritizedJob > 0 then\n    rcall("LPUSH", activeKey, prioritizedJob[1])\n    return prioritizedJob[1]\n  else\n    rcall("DEL", priorityCounterKey)\n  end\nend\n--[[\n  Function to move job from wait state to active.\n  Input:\n    opts - token - lock token\n    opts - lockDuration\n    opts - limiter\n]]\n-- Includes\n--[[\n  Add marker if needed when a job is available.\n]]\nlocal function addBaseMarkerIfNeeded(markerKey, isPausedOrMaxed)\n  if not isPausedOrMaxed then\n    rcall("ZADD", markerKey, 0, "0")\n  end  \nend\nlocal function prepareJobForProcessing(keyPrefix, rateLimiterKey, eventStreamKey,\n    jobId, processedOn, maxJobs, markerKey, opts)\n  local jobKey = keyPrefix .. jobId\n  -- Check if we need to perform rate limiting.\n  if maxJobs then\n    local jobCounter = tonumber(rcall("INCR", rateLimiterKey))\n    if jobCounter == 1 then\n      local limiterDuration = opts[\'limiter\'] and opts[\'limiter\'][\'duration\']\n      local integerDuration = math.floor(math.abs(limiterDuration))\n      rcall("PEXPIRE", rateLimiterKey, integerDuration)\n    end\n  end\n  local lockKey = jobKey .. \':lock\'\n  -- get a lock\n  if opts[\'token\'] ~= "0" then\n    rcall("SET", lockKey, opts[\'token\'], "PX", opts[\'lockDuration\'])\n  end\n  local optionalValues = {}\n  if opts[\'name\'] then\n    -- Set "processedBy" field to the worker name\n    table.insert(optionalValues, "pb")\n    table.insert(optionalValues, opts[\'name\'])\n  end\n  rcall("XADD", eventStreamKey, "*", "event", "active", "jobId", jobId, "prev", "waiting")\n  rcall("HMSET", jobKey, "processedOn", processedOn, unpack(optionalValues))\n  rcall("HINCRBY", jobKey, "ats", 1)\n  addBaseMarkerIfNeeded(markerKey, false)\n  -- rate limit delay must be 0 in this case to prevent adding more delay\n  -- when job that is moved to active needs to be processed\n  return {rcall("HGETALL", jobKey), jobId, 0, 0} -- get job data\nend\n--[[\n  Updates the delay set, by moving delayed jobs that should\n  be processed now to "wait".\n     Events:\n      \'waiting\'\n]]\n-- Includes\n--[[\n  Function to add job in target list and add marker if needed.\n]]\n-- Includes\nlocal function addJobInTargetList(targetKey, markerKey, pushCmd, isPausedOrMaxed, jobId)\n  rcall(pushCmd, targetKey, jobId)\n  addBaseMarkerIfNeeded(markerKey, isPausedOrMaxed)\nend\n--[[\n  Function to add job considering priority.\n]]\n-- Includes\n--[[\n  Function to get priority score.\n]]\nlocal function getPriorityScore(priority, priorityCounterKey)\n  local prioCounter = rcall("INCR", priorityCounterKey)\n  return priority * 0x100000000 + prioCounter % 0x100000000\nend\nlocal function addJobWithPriority(markerKey, prioritizedKey, priority, jobId, priorityCounterKey,\n  isPausedOrMaxed)\n  local score = getPriorityScore(priority, priorityCounterKey)\n  rcall("ZADD", prioritizedKey, score, jobId)\n  addBaseMarkerIfNeeded(markerKey, isPausedOrMaxed)\nend\n-- Try to get as much as 1000 jobs at once\nlocal function promoteDelayedJobs(delayedKey, markerKey, targetKey, prioritizedKey,\n                                  eventStreamKey, prefix, timestamp, priorityCounterKey, isPaused)\n    local jobs = rcall("ZRANGEBYSCORE", delayedKey, 0, (timestamp + 1) * 0x1000 - 1, "LIMIT", 0, 1000)\n    if (#jobs > 0) then\n        rcall("ZREM", delayedKey, unpack(jobs))\n        for _, jobId in ipairs(jobs) do\n            local jobKey = prefix .. jobId\n            local priority =\n                tonumber(rcall("HGET", jobKey, "priority")) or 0\n            if priority == 0 then\n                -- LIFO or FIFO\n                rcall("LPUSH", targetKey, jobId)\n            else\n                local score = getPriorityScore(priority, priorityCounterKey)\n                rcall("ZADD", prioritizedKey, score, jobId)\n            end\n            -- Emit waiting event\n            rcall("XADD", eventStreamKey, "*", "event", "waiting", "jobId",\n                  jobId, "prev", "delayed")\n            rcall("HSET", jobKey, "delay", 0)\n        end\n        addBaseMarkerIfNeeded(markerKey, isPaused)\n    end\nend\nlocal target, isPausedOrMaxed = getTargetQueueList(KEYS[9], activeKey, waitKey, KEYS[8])\n-- Check if there are delayed jobs that we can move to wait.\nlocal markerKey = KEYS[11]\npromoteDelayedJobs(delayedKey, markerKey, target, KEYS[3], eventStreamKey, ARGV[1],\n                   ARGV[2], KEYS[10], isPausedOrMaxed)\nlocal maxJobs = tonumber(opts[\'limiter\'] and opts[\'limiter\'][\'max\'])\nlocal expireTime = getRateLimitTTL(maxJobs, rateLimiterKey)\n-- Check if we are rate limited first.\nif expireTime > 0 then return {0, 0, expireTime, 0} end\n-- paused or maxed queue\nif isPausedOrMaxed then return {0, 0, 0, 0} end\n-- no job ID, try non-blocking move from wait to active\nlocal jobId = rcall("RPOPLPUSH", waitKey, activeKey)\n-- Markers in waitlist DEPRECATED in v5: Will be completely removed in v6.\nif jobId and string.sub(jobId, 1, 2) == "0:" then\n    rcall("LREM", activeKey, 1, jobId)\n    jobId = rcall("RPOPLPUSH", waitKey, activeKey)\nend\nif jobId then\n    return prepareJobForProcessing(ARGV[1], rateLimiterKey, eventStreamKey, jobId, ARGV[2],\n                                   maxJobs, markerKey, opts)\nelse\n    jobId = moveJobFromPrioritizedToActive(KEYS[3], activeKey, KEYS[10])\n    if jobId then\n        return prepareJobForProcessing(ARGV[1], rateLimiterKey, eventStreamKey, jobId, ARGV[2],\n                                       maxJobs, markerKey, opts)\n    end\nend\n-- Return the timestamp for the next delayed job if any.\nlocal nextTimestamp = getNextDelayedTimestamp(delayedKey)\nif nextTimestamp ~= nil then return {0, 0, 0, nextTimestamp} end\nreturn {0, 0, 0, 0}\n',keys:11}},(e,t,n)=>{"use strict";n.r(t),n.d(t,{moveToDelayed:()=>r});const r={name:"moveToDelayed",content:'--[[\n  Moves job from active to delayed set.\n  Input:\n    KEYS[1] marker key\n    KEYS[2] active key\n    KEYS[3] prioritized key\n    KEYS[4] delayed key\n    KEYS[5] job key\n    KEYS[6] events stream\n    KEYS[7] meta key\n    KEYS[8] stalled key\n    ARGV[1] key prefix\n    ARGV[2] timestamp\n    ARGV[3] the id of the job\n    ARGV[4] queue token\n    ARGV[5] delay value\n    ARGV[6] skip attempt\n    ARGV[7] optional job fields to update\n  Output:\n    0 - OK\n   -1 - Missing job.\n   -3 - Job not in active set.\n  Events:\n    - delayed key.\n]]\nlocal rcall = redis.call\n-- Includes\n--[[\n  Add delay marker if needed.\n]]\n-- Includes\n--[[\n  Function to return the next delayed job timestamp.\n]]\nlocal function getNextDelayedTimestamp(delayedKey)\n  local result = rcall("ZRANGE", delayedKey, 0, 0, "WITHSCORES")\n  if #result then\n    local nextTimestamp = tonumber(result[2])\n    if nextTimestamp ~= nil then\n      return nextTimestamp / 0x1000\n    end\n  end\nend\nlocal function addDelayMarkerIfNeeded(markerKey, delayedKey)\n  local nextTimestamp = getNextDelayedTimestamp(delayedKey)\n  if nextTimestamp ~= nil then\n    -- Replace the score of the marker with the newest known\n    -- next timestamp.\n    rcall("ZADD", markerKey, nextTimestamp, "1")\n  end\nend\n--[[\n  Bake in the job id first 12 bits into the timestamp\n  to guarantee correct execution order of delayed jobs\n  (up to 4096 jobs per given timestamp or 4096 jobs apart per timestamp)\n  WARNING: Jobs that are so far apart that they wrap around will cause FIFO to fail\n]]\nlocal function getDelayedScore(delayedKey, timestamp, delay)\n  local delayedTimestamp = (delay > 0 and (tonumber(timestamp) + delay)) or tonumber(timestamp)\n  local minScore = delayedTimestamp * 0x1000\n  local maxScore = (delayedTimestamp + 1 ) * 0x1000 - 1\n  local result = rcall("ZREVRANGEBYSCORE", delayedKey, maxScore,\n    minScore, "WITHSCORES","LIMIT", 0, 1)\n  if #result then\n    local currentMaxScore = tonumber(result[2])\n    if currentMaxScore ~= nil then\n      if currentMaxScore >= maxScore then\n        return maxScore, delayedTimestamp\n      else\n        return currentMaxScore + 1, delayedTimestamp\n      end\n    end\n  end\n  return minScore, delayedTimestamp\nend\n--[[\n  Function to get max events value or set by default 10000.\n]]\nlocal function getOrSetMaxEvents(metaKey)\n  local maxEvents = rcall("HGET", metaKey, "opts.maxLenEvents")\n  if not maxEvents then\n    maxEvents = 10000\n    rcall("HSET", metaKey, "opts.maxLenEvents", maxEvents)\n  end\n  return maxEvents\nend\nlocal function removeLock(jobKey, stalledKey, token, jobId)\n  if token ~= "0" then\n    local lockKey = jobKey .. \':lock\'\n    local lockToken = rcall("GET", lockKey)\n    if lockToken == token then\n      rcall("DEL", lockKey)\n      rcall("SREM", stalledKey, jobId)\n    else\n      if lockToken then\n        -- Lock exists but token does not match\n        return -6\n      else\n        -- Lock is missing completely\n        return -2\n      end\n    end\n  end\n  return 0\nend\n--[[\n  Function to update a bunch of fields in a job.\n]]\nlocal function updateJobFields(jobKey, msgpackedFields)\n  if msgpackedFields and #msgpackedFields > 0 then\n    local fieldsToUpdate = cmsgpack.unpack(msgpackedFields)\n    if fieldsToUpdate then\n      rcall("HMSET", jobKey, unpack(fieldsToUpdate))\n    end\n  end\nend\nlocal jobKey = KEYS[5]\nlocal metaKey = KEYS[7]\nlocal token = ARGV[4] \nif rcall("EXISTS", jobKey) == 1 then\n    local errorCode = removeLock(jobKey, KEYS[8], token, ARGV[3])\n    if errorCode < 0 then\n        return errorCode\n    end\n    updateJobFields(jobKey, ARGV[7])\n    local delayedKey = KEYS[4]\n    local jobId = ARGV[3]\n    local delay = tonumber(ARGV[5])\n    local score, delayedTimestamp = getDelayedScore(delayedKey, ARGV[2], delay)\n    local numRemovedElements = rcall("LREM", KEYS[2], -1, jobId)\n    if numRemovedElements < 1 then return -3 end\n    if ARGV[6] == "0" then\n        rcall("HINCRBY", jobKey, "atm", 1)\n    end\n    rcall("HSET", jobKey, "delay", ARGV[5])\n    local maxEvents = getOrSetMaxEvents(metaKey)\n    rcall("ZADD", delayedKey, score, jobId)\n    rcall("XADD", KEYS[6], "MAXLEN", "~", maxEvents, "*", "event", "delayed",\n          "jobId", jobId, "delay", delayedTimestamp)\n    -- Check if we need to push a marker job to wake up sleeping workers.\n    local markerKey = KEYS[1]\n    addDelayMarkerIfNeeded(markerKey, delayedKey)\n    return 0\nelse\n    return -1\nend\n',keys:8}},(e,t,n)=>{"use strict";n.r(t),n.d(t,{moveToFinished:()=>r});const r={name:"moveToFinished",content:'--[[\n  Move job from active to a finished status (completed o failed)\n  A job can only be moved to completed if it was active.\n  The job must be locked before it can be moved to a finished status,\n  and the lock must be released in this script.\n    Input:\n      KEYS[1] wait key\n      KEYS[2] active key\n      KEYS[3] prioritized key\n      KEYS[4] event stream key\n      KEYS[5] stalled key\n      -- Rate limiting\n      KEYS[6] rate limiter key\n      KEYS[7] delayed key\n      KEYS[8] paused key\n      KEYS[9] meta key\n      KEYS[10] pc priority counter\n      KEYS[11] completed/failed key\n      KEYS[12] jobId key\n      KEYS[13] metrics key\n      KEYS[14] marker key\n      ARGV[1]  jobId\n      ARGV[2]  timestamp\n      ARGV[3]  msg property returnvalue / failedReason\n      ARGV[4]  return value / failed reason\n      ARGV[5]  target (completed/failed)\n      ARGV[6]  fetch next?\n      ARGV[7]  keys prefix\n      ARGV[8]  opts\n      ARGV[9]  job fields to update\n      opts - token - lock token\n      opts - keepJobs\n      opts - lockDuration - lock duration in milliseconds\n      opts - attempts max attempts\n      opts - maxMetricsSize\n      opts - fpof - fail parent on fail\n      opts - cpof - continue parent on fail\n      opts - idof - ignore dependency on fail\n      opts - rdof - remove dependency on fail\n      opts - name - worker name\n    Output:\n      0 OK\n      -1 Missing key.\n      -2 Missing lock.\n      -3 Job not in active set\n      -4 Job has pending children\n      -6 Lock is not owned by this client\n      -9 Job has failed children\n    Events:\n      \'completed/failed\'\n]]\nlocal rcall = redis.call\n--- Includes\n--[[\n  Functions to collect metrics based on a current and previous count of jobs.\n  Granualarity is fixed at 1 minute.\n]]\n--[[\n  Function to loop in batches.\n  Just a bit of warning, some commands as ZREM\n  could receive a maximum of 7000 parameters per call.\n]]\nlocal function batches(n, batchSize)\n  local i = 0\n  return function()\n    local from = i * batchSize + 1\n    i = i + 1\n    if (from <= n) then\n      local to = math.min(from + batchSize - 1, n)\n      return from, to\n    end\n  end\nend\nlocal function collectMetrics(metaKey, dataPointsList, maxDataPoints,\n                                 timestamp)\n    -- Increment current count\n    local count = rcall("HINCRBY", metaKey, "count", 1) - 1\n    -- Compute how many data points we need to add to the list, N.\n    local prevTS = rcall("HGET", metaKey, "prevTS")\n    if not prevTS then\n        -- If prevTS is nil, set it to the current timestamp\n        rcall("HSET", metaKey, "prevTS", timestamp, "prevCount", 0)\n        return\n    end\n    local N = math.min(math.floor(timestamp / 60000) - math.floor(prevTS / 60000), tonumber(maxDataPoints))\n    if N > 0 then\n        local delta = count - rcall("HGET", metaKey, "prevCount")\n        -- If N > 1, add N-1 zeros to the list\n        if N > 1 then\n            local points = {}\n            points[1] = delta\n            for i = 2, N do\n                points[i] = 0\n            end\n            for from, to in batches(#points, 7000) do\n                rcall("LPUSH", dataPointsList, unpack(points, from, to))\n            end\n        else\n            -- LPUSH delta to the list\n            rcall("LPUSH", dataPointsList, delta)\n        end\n        -- LTRIM to keep list to its max size\n        rcall("LTRIM", dataPointsList, 0, maxDataPoints - 1)\n        -- update prev count with current count\n        rcall("HSET", metaKey, "prevCount", count, "prevTS", timestamp)\n    end\nend\n--[[\n  Function to return the next delayed job timestamp.\n]]\nlocal function getNextDelayedTimestamp(delayedKey)\n  local result = rcall("ZRANGE", delayedKey, 0, 0, "WITHSCORES")\n  if #result then\n    local nextTimestamp = tonumber(result[2])\n    if nextTimestamp ~= nil then\n      return nextTimestamp / 0x1000\n    end\n  end\nend\n--[[\n  Function to get current rate limit ttl.\n]]\nlocal function getRateLimitTTL(maxJobs, rateLimiterKey)\n  if maxJobs and maxJobs <= tonumber(rcall("GET", rateLimiterKey) or 0) then\n    local pttl = rcall("PTTL", rateLimiterKey)\n    if pttl == 0 then\n      rcall("DEL", rateLimiterKey)\n    end\n    if pttl > 0 then\n      return pttl\n    end\n  end\n  return 0\nend\n--[[\n  Function to check for the meta.paused key to decide if we are paused or not\n  (since an empty list and !EXISTS are not really the same).\n]]\nlocal function getTargetQueueList(queueMetaKey, activeKey, waitKey, pausedKey)\n  local queueAttributes = rcall("HMGET", queueMetaKey, "paused", "concurrency")\n  if queueAttributes[1] then\n    return pausedKey, true\n  else\n    if queueAttributes[2] then\n      local activeCount = rcall("LLEN", activeKey)\n      if activeCount >= tonumber(queueAttributes[2]) then\n        return waitKey, true\n      else\n        return waitKey, false\n      end\n    end\n  end\n  return waitKey, false\nend\n--[[\n  Function to move job from prioritized state to active.\n]]\nlocal function moveJobFromPrioritizedToActive(priorityKey, activeKey, priorityCounterKey)\n  local prioritizedJob = rcall("ZPOPMIN", priorityKey)\n  if #prioritizedJob > 0 then\n    rcall("LPUSH", activeKey, prioritizedJob[1])\n    return prioritizedJob[1]\n  else\n    rcall("DEL", priorityCounterKey)\n  end\nend\n--[[\n  Function to recursively move from waitingChildren to failed.\n]]\n-- Includes\n--[[\n  Validate and move parent to a wait status (waiting, delayed or prioritized)\n  if no pending dependencies.\n]]\n-- Includes\n--[[\n  Validate and move parent to a wait status (waiting, delayed or prioritized) if needed.\n]]\n-- Includes\n--[[\n  Move parent to a wait status (wait, prioritized or delayed)\n]]\n-- Includes\n--[[\n  Add delay marker if needed.\n]]\n-- Includes\nlocal function addDelayMarkerIfNeeded(markerKey, delayedKey)\n  local nextTimestamp = getNextDelayedTimestamp(delayedKey)\n  if nextTimestamp ~= nil then\n    -- Replace the score of the marker with the newest known\n    -- next timestamp.\n    rcall("ZADD", markerKey, nextTimestamp, "1")\n  end\nend\n--[[\n  Function to add job in target list and add marker if needed.\n]]\n-- Includes\n--[[\n  Add marker if needed when a job is available.\n]]\nlocal function addBaseMarkerIfNeeded(markerKey, isPausedOrMaxed)\n  if not isPausedOrMaxed then\n    rcall("ZADD", markerKey, 0, "0")\n  end  \nend\nlocal function addJobInTargetList(targetKey, markerKey, pushCmd, isPausedOrMaxed, jobId)\n  rcall(pushCmd, targetKey, jobId)\n  addBaseMarkerIfNeeded(markerKey, isPausedOrMaxed)\nend\n--[[\n  Function to add job considering priority.\n]]\n-- Includes\n--[[\n  Function to get priority score.\n]]\nlocal function getPriorityScore(priority, priorityCounterKey)\n  local prioCounter = rcall("INCR", priorityCounterKey)\n  return priority * 0x100000000 + prioCounter % 0x100000000\nend\nlocal function addJobWithPriority(markerKey, prioritizedKey, priority, jobId, priorityCounterKey,\n  isPausedOrMaxed)\n  local score = getPriorityScore(priority, priorityCounterKey)\n  rcall("ZADD", prioritizedKey, score, jobId)\n  addBaseMarkerIfNeeded(markerKey, isPausedOrMaxed)\nend\n--[[\n  Function to check if queue is paused or maxed\n  (since an empty list and !EXISTS are not really the same).\n]]\nlocal function isQueuePausedOrMaxed(queueMetaKey, activeKey)\n  local queueAttributes = rcall("HMGET", queueMetaKey, "paused", "concurrency")\n  if queueAttributes[1] then\n    return true\n  else\n    if queueAttributes[2] then\n      local activeCount = rcall("LLEN", activeKey)\n      return activeCount >= tonumber(queueAttributes[2])\n    end\n  end\n  return false\nend\nlocal function moveParentToWait(parentQueueKey, parentKey, parentId, timestamp)\n    local parentWaitKey = parentQueueKey .. ":wait"\n    local parentPausedKey = parentQueueKey .. ":paused"\n    local parentActiveKey = parentQueueKey .. ":active"\n    local parentMetaKey = parentQueueKey .. ":meta"\n    local parentMarkerKey = parentQueueKey .. ":marker"\n    local jobAttributes = rcall("HMGET", parentKey, "priority", "delay")\n    local priority = tonumber(jobAttributes[1]) or 0\n    local delay = tonumber(jobAttributes[2]) or 0\n    if delay > 0 then\n        local delayedTimestamp = tonumber(timestamp) + delay\n        local score = delayedTimestamp * 0x1000\n        local parentDelayedKey = parentQueueKey .. ":delayed"\n        rcall("ZADD", parentDelayedKey, score, parentId)\n        rcall("XADD", parentQueueKey .. ":events", "*", "event", "delayed", "jobId", parentId, "delay",\n            delayedTimestamp)\n        addDelayMarkerIfNeeded(parentMarkerKey, parentDelayedKey)\n    else\n        if priority == 0 then\n            local parentTarget, isParentPausedOrMaxed = getTargetQueueList(parentMetaKey, parentActiveKey,\n                parentWaitKey, parentPausedKey)\n            addJobInTargetList(parentTarget, parentMarkerKey, "RPUSH", isParentPausedOrMaxed, parentId)\n        else\n            local isPausedOrMaxed = isQueuePausedOrMaxed(parentMetaKey, parentActiveKey)\n            addJobWithPriority(parentMarkerKey, parentQueueKey .. ":prioritized", priority, parentId,\n                parentQueueKey .. ":pc", isPausedOrMaxed)\n        end\n        rcall("XADD", parentQueueKey .. ":events", "*", "event", "waiting", "jobId", parentId, "prev",\n            "waiting-children")\n    end\nend\nlocal function moveParentToWaitIfNeeded(parentQueueKey, parentKey, parentId, timestamp)\n  if rcall("EXISTS", parentKey) == 1 then\n    local parentWaitingChildrenKey = parentQueueKey .. ":waiting-children"\n    if rcall("ZSCORE", parentWaitingChildrenKey, parentId) then    \n      rcall("ZREM", parentWaitingChildrenKey, parentId)\n      moveParentToWait(parentQueueKey, parentKey, parentId, timestamp)\n    end\n  end\nend\nlocal function moveParentToWaitIfNoPendingDependencies(parentQueueKey, parentDependenciesKey, parentKey,\n  parentId, timestamp)\n  local doNotHavePendingDependencies = rcall("SCARD", parentDependenciesKey) == 0\n  if doNotHavePendingDependencies then\n    moveParentToWaitIfNeeded(parentQueueKey, parentKey, parentId, timestamp)\n  end\nend\n--[[\n  Functions to remove jobs when removeOnFail option is provided.\n]]\n-- Includes\n--[[\n  Function to remove job.\n]]\n-- Includes\n--[[\n  Function to remove deduplication key if needed\n  when a job is being removed.\n]]\nlocal function removeDeduplicationKeyIfNeededOnRemoval(prefixKey,\n  jobKey, jobId)\n  local deduplicationId = rcall("HGET", jobKey, "deid")\n  if deduplicationId then\n    local deduplicationKey = prefixKey .. "de:" .. deduplicationId\n    local currentJobId = rcall(\'GET\', deduplicationKey)\n    if currentJobId and currentJobId == jobId then\n      return rcall("DEL", deduplicationKey)\n    end\n  end\nend\n--[[\n  Function to remove job keys.\n]]\nlocal function removeJobKeys(jobKey)\n  return rcall("DEL", jobKey, jobKey .. \':logs\', jobKey .. \':dependencies\',\n    jobKey .. \':processed\', jobKey .. \':failed\', jobKey .. \':unsuccessful\')\nend\n--[[\n  Check if this job has a parent. If so we will just remove it from\n  the parent child list, but if it is the last child we should move the parent to "wait/paused"\n  which requires code from "moveToFinished"\n]]\n-- Includes\n--[[\n  Functions to destructure job key.\n  Just a bit of warning, these functions may be a bit slow and affect performance significantly.\n]]\nlocal getJobIdFromKey = function (jobKey)\n  return string.match(jobKey, ".*:(.*)")\nend\nlocal getJobKeyPrefix = function (jobKey, jobId)\n  return string.sub(jobKey, 0, #jobKey - #jobId)\nend\nlocal function _moveParentToWait(parentPrefix, parentId, emitEvent)\n  local parentTarget, isPausedOrMaxed = getTargetQueueList(parentPrefix .. "meta", parentPrefix .. "active",\n    parentPrefix .. "wait", parentPrefix .. "paused")\n  addJobInTargetList(parentTarget, parentPrefix .. "marker", "RPUSH", isPausedOrMaxed, parentId)\n  if emitEvent then\n    local parentEventStream = parentPrefix .. "events"\n    rcall("XADD", parentEventStream, "*", "event", "waiting", "jobId", parentId, "prev", "waiting-children")\n  end\nend\nlocal function removeParentDependencyKey(jobKey, hard, parentKey, baseKey, debounceId)\n  if parentKey then\n    local parentDependenciesKey = parentKey .. ":dependencies"\n    local result = rcall("SREM", parentDependenciesKey, jobKey)\n    if result > 0 then\n      local pendingDependencies = rcall("SCARD", parentDependenciesKey)\n      if pendingDependencies == 0 then\n        local parentId = getJobIdFromKey(parentKey)\n        local parentPrefix = getJobKeyPrefix(parentKey, parentId)\n        local numRemovedElements = rcall("ZREM", parentPrefix .. "waiting-children", parentId)\n        if numRemovedElements == 1 then\n          if hard then -- remove parent in same queue\n            if parentPrefix == baseKey then\n              removeParentDependencyKey(parentKey, hard, nil, baseKey, nil)\n              removeJobKeys(parentKey)\n              if debounceId then\n                rcall("DEL", parentPrefix .. "de:" .. debounceId)\n              end\n            else\n              _moveParentToWait(parentPrefix, parentId)\n            end\n          else\n            _moveParentToWait(parentPrefix, parentId, true)\n          end\n        end\n      end\n      return true\n    end\n  else\n    local parentAttributes = rcall("HMGET", jobKey, "parentKey", "deid")\n    local missedParentKey = parentAttributes[1]\n    if( (type(missedParentKey) == "string") and missedParentKey ~= ""\n      and (rcall("EXISTS", missedParentKey) == 1)) then\n      local parentDependenciesKey = missedParentKey .. ":dependencies"\n      local result = rcall("SREM", parentDependenciesKey, jobKey)\n      if result > 0 then\n        local pendingDependencies = rcall("SCARD", parentDependenciesKey)\n        if pendingDependencies == 0 then\n          local parentId = getJobIdFromKey(missedParentKey)\n          local parentPrefix = getJobKeyPrefix(missedParentKey, parentId)\n          local numRemovedElements = rcall("ZREM", parentPrefix .. "waiting-children", parentId)\n          if numRemovedElements == 1 then\n            if hard then\n              if parentPrefix == baseKey then\n                removeParentDependencyKey(missedParentKey, hard, nil, baseKey, nil)\n                removeJobKeys(missedParentKey)\n                if parentAttributes[2] then\n                  rcall("DEL", parentPrefix .. "de:" .. parentAttributes[2])\n                end\n              else\n                _moveParentToWait(parentPrefix, parentId)\n              end\n            else\n              _moveParentToWait(parentPrefix, parentId, true)\n            end\n          end\n        end\n        return true\n      end\n    end\n  end\n  return false\nend\nlocal function removeJob(jobId, hard, baseKey, shouldRemoveDeduplicationKey)\n  local jobKey = baseKey .. jobId\n  removeParentDependencyKey(jobKey, hard, nil, baseKey)\n  if shouldRemoveDeduplicationKey then\n    removeDeduplicationKeyIfNeededOnRemoval(baseKey, jobKey, jobId)\n  end\n  removeJobKeys(jobKey)\nend\n--[[\n  Functions to remove jobs by max age.\n]]\n-- Includes\nlocal function removeJobsByMaxAge(timestamp, maxAge, targetSet, prefix,\n  shouldRemoveDebounceKey)\n  local start = timestamp - maxAge * 1000\n  local jobIds = rcall("ZREVRANGEBYSCORE", targetSet, start, "-inf")\n  for i, jobId in ipairs(jobIds) do\n    removeJob(jobId, false, prefix, false --[[remove debounce key]])\n  end\n  rcall("ZREMRANGEBYSCORE", targetSet, "-inf", start)\nend\n--[[\n  Functions to remove jobs by max count.\n]]\n-- Includes\nlocal function removeJobsByMaxCount(maxCount, targetSet, prefix)\n  local start = maxCount\n  local jobIds = rcall("ZREVRANGE", targetSet, start, -1)\n  for i, jobId in ipairs(jobIds) do\n    removeJob(jobId, false, prefix, false --[[remove debounce key]])\n  end\n  rcall("ZREMRANGEBYRANK", targetSet, 0, -(maxCount + 1))\nend\nlocal function removeJobsOnFail(queueKeyPrefix, failedKey, jobId, opts, timestamp)\n  local removeOnFailType = type(opts["removeOnFail"])\n  if removeOnFailType == "number" then\n    removeJobsByMaxCount(opts["removeOnFail"],\n                        failedKey, queueKeyPrefix)\n  elseif removeOnFailType == "boolean" then\n    if opts["removeOnFail"] then\n      removeJob(jobId, false, queueKeyPrefix,\n                false --[[remove debounce key]])\n      rcall("ZREM", failedKey, jobId)\n    end\n  elseif removeOnFailType ~= "nil" then\n    local maxAge = opts["removeOnFail"]["age"]\n    local maxCount = opts["removeOnFail"]["count"]\n    if maxAge ~= nil then\n      removeJobsByMaxAge(timestamp, maxAge,\n                        failedKey, queueKeyPrefix)\n    end\n    if maxCount ~= nil and maxCount > 0 then\n      removeJobsByMaxCount(maxCount, failedKey,\n                            queueKeyPrefix)\n    end\n  end \nend\nlocal moveParentToFailedIfNeeded = function (parentQueueKey, parentKey, parentId, jobIdKey, timestamp)\n  if rcall("EXISTS", parentKey) == 1 then\n    local parentWaitingChildrenKey = parentQueueKey .. ":waiting-children"\n    local parentDelayedKey = parentQueueKey .. ":delayed"\n    local parentPrioritizedKey = parentQueueKey .. ":prioritized"\n    local parentWaitingChildrenOrDelayedKey\n    local prevState\n    if rcall("ZSCORE", parentWaitingChildrenKey, parentId) then\n      parentWaitingChildrenOrDelayedKey = parentWaitingChildrenKey\n      prevState = "waiting-children"\n    elseif rcall("ZSCORE", parentDelayedKey, parentId) then\n      parentWaitingChildrenOrDelayedKey = parentDelayedKey\n      prevState = "delayed"\n      rcall("HSET", parentKey, "delay", 0)\n    end\n    if parentWaitingChildrenOrDelayedKey then\n      rcall("ZREM", parentWaitingChildrenOrDelayedKey, parentId)\n      local parentQueuePrefix = parentQueueKey .. ":"\n      local parentFailedKey = parentQueueKey .. ":failed"\n      local deferredFailure = "child " .. jobIdKey .. " failed"\n      rcall("HSET", parentKey, "defa", deferredFailure)\n      moveParentToWait(parentQueueKey, parentKey, parentId, timestamp)\n    else\n      if not rcall("ZSCORE", parentQueueKey .. ":failed", parentId) then\n        local deferredFailure = "child " .. jobIdKey .. " failed"\n        rcall("HSET", parentKey, "defa", deferredFailure)\n      end\n    end\n  end\nend\nlocal moveChildFromDependenciesIfNeeded = function (rawParentData, childKey, failedReason, timestamp)\n  if rawParentData then\n    local parentData = cjson.decode(rawParentData)\n    local parentKey = parentData[\'queueKey\'] .. \':\' .. parentData[\'id\']\n    local parentDependenciesChildrenKey = parentKey .. ":dependencies"\n    if parentData[\'fpof\'] then\n      if rcall("SREM", parentDependenciesChildrenKey, childKey) == 1 then\n        local parentUnsuccesssfulChildrenKey = parentKey .. ":unsuccessful"\n        rcall("ZADD", parentUnsuccesssfulChildrenKey, timestamp, childKey)\n        moveParentToFailedIfNeeded(\n          parentData[\'queueKey\'],\n          parentKey,\n          parentData[\'id\'],\n          childKey,\n          timestamp\n        )\n      end\n    elseif parentData[\'cpof\'] then\n      if rcall("SREM", parentDependenciesChildrenKey, childKey) == 1 then\n        local parentFailedChildrenKey = parentKey .. ":failed"\n        rcall("HSET", parentFailedChildrenKey, childKey, failedReason)\n        moveParentToWaitIfNeeded(parentData[\'queueKey\'], parentKey, parentData[\'id\'], timestamp)\n      end\n    elseif parentData[\'idof\'] or parentData[\'rdof\'] then\n      if rcall("SREM", parentDependenciesChildrenKey, childKey) == 1 then\n        moveParentToWaitIfNoPendingDependencies(parentData[\'queueKey\'], parentDependenciesChildrenKey,\n          parentKey, parentData[\'id\'], timestamp)\n        if parentData[\'idof\'] then\n          local parentFailedChildrenKey = parentKey .. ":failed"\n          rcall("HSET", parentFailedChildrenKey, childKey, failedReason)\n        end\n      end\n    end\n  end\nend\n--[[\n  Function to move job from wait state to active.\n  Input:\n    opts - token - lock token\n    opts - lockDuration\n    opts - limiter\n]]\n-- Includes\nlocal function prepareJobForProcessing(keyPrefix, rateLimiterKey, eventStreamKey,\n    jobId, processedOn, maxJobs, markerKey, opts)\n  local jobKey = keyPrefix .. jobId\n  -- Check if we need to perform rate limiting.\n  if maxJobs then\n    local jobCounter = tonumber(rcall("INCR", rateLimiterKey))\n    if jobCounter == 1 then\n      local limiterDuration = opts[\'limiter\'] and opts[\'limiter\'][\'duration\']\n      local integerDuration = math.floor(math.abs(limiterDuration))\n      rcall("PEXPIRE", rateLimiterKey, integerDuration)\n    end\n  end\n  local lockKey = jobKey .. \':lock\'\n  -- get a lock\n  if opts[\'token\'] ~= "0" then\n    rcall("SET", lockKey, opts[\'token\'], "PX", opts[\'lockDuration\'])\n  end\n  local optionalValues = {}\n  if opts[\'name\'] then\n    -- Set "processedBy" field to the worker name\n    table.insert(optionalValues, "pb")\n    table.insert(optionalValues, opts[\'name\'])\n  end\n  rcall("XADD", eventStreamKey, "*", "event", "active", "jobId", jobId, "prev", "waiting")\n  rcall("HMSET", jobKey, "processedOn", processedOn, unpack(optionalValues))\n  rcall("HINCRBY", jobKey, "ats", 1)\n  addBaseMarkerIfNeeded(markerKey, false)\n  -- rate limit delay must be 0 in this case to prevent adding more delay\n  -- when job that is moved to active needs to be processed\n  return {rcall("HGETALL", jobKey), jobId, 0, 0} -- get job data\nend\n--[[\n  Updates the delay set, by moving delayed jobs that should\n  be processed now to "wait".\n     Events:\n      \'waiting\'\n]]\n-- Includes\n-- Try to get as much as 1000 jobs at once\nlocal function promoteDelayedJobs(delayedKey, markerKey, targetKey, prioritizedKey,\n                                  eventStreamKey, prefix, timestamp, priorityCounterKey, isPaused)\n    local jobs = rcall("ZRANGEBYSCORE", delayedKey, 0, (timestamp + 1) * 0x1000 - 1, "LIMIT", 0, 1000)\n    if (#jobs > 0) then\n        rcall("ZREM", delayedKey, unpack(jobs))\n        for _, jobId in ipairs(jobs) do\n            local jobKey = prefix .. jobId\n            local priority =\n                tonumber(rcall("HGET", jobKey, "priority")) or 0\n            if priority == 0 then\n                -- LIFO or FIFO\n                rcall("LPUSH", targetKey, jobId)\n            else\n                local score = getPriorityScore(priority, priorityCounterKey)\n                rcall("ZADD", prioritizedKey, score, jobId)\n            end\n            -- Emit waiting event\n            rcall("XADD", eventStreamKey, "*", "event", "waiting", "jobId",\n                  jobId, "prev", "delayed")\n            rcall("HSET", jobKey, "delay", 0)\n        end\n        addBaseMarkerIfNeeded(markerKey, isPaused)\n    end\nend\n--[[\n  Function to remove deduplication key if needed\n  when a job is moved to completed or failed states.\n]]\nlocal function removeDeduplicationKeyIfNeededOnFinalization(prefixKey,\n  deduplicationId, jobId)\n  if deduplicationId then\n    local deduplicationKey = prefixKey .. "de:" .. deduplicationId\n    local pttl = rcall("PTTL", deduplicationKey)\n    if pttl == 0 then\n      return rcall("DEL", deduplicationKey)\n    end\n    if pttl == -1 then\n      local currentJobId = rcall(\'GET\', deduplicationKey)\n      if currentJobId and currentJobId == jobId then\n        return rcall("DEL", deduplicationKey)\n      end\n    end\n  end\nend\nlocal function removeLock(jobKey, stalledKey, token, jobId)\n  if token ~= "0" then\n    local lockKey = jobKey .. \':lock\'\n    local lockToken = rcall("GET", lockKey)\n    if lockToken == token then\n      rcall("DEL", lockKey)\n      rcall("SREM", stalledKey, jobId)\n    else\n      if lockToken then\n        -- Lock exists but token does not match\n        return -6\n      else\n        -- Lock is missing completely\n        return -2\n      end\n    end\n  end\n  return 0\nend\n--[[\n  Function to trim events, default 10000.\n]]\n-- Includes\n--[[\n  Function to get max events value or set by default 10000.\n]]\nlocal function getOrSetMaxEvents(metaKey)\n  local maxEvents = rcall("HGET", metaKey, "opts.maxLenEvents")\n  if not maxEvents then\n    maxEvents = 10000\n    rcall("HSET", metaKey, "opts.maxLenEvents", maxEvents)\n  end\n  return maxEvents\nend\nlocal function trimEvents(metaKey, eventStreamKey)\n  local maxEvents = getOrSetMaxEvents(metaKey)\n  if maxEvents then\n    rcall("XTRIM", eventStreamKey, "MAXLEN", "~", maxEvents)\n  else\n    rcall("XTRIM", eventStreamKey, "MAXLEN", "~", 10000)\n  end\nend\n--[[\n  Validate and move or add dependencies to parent.\n]]\n-- Includes\nlocal function updateParentDepsIfNeeded(parentKey, parentQueueKey, parentDependenciesKey,\n  parentId, jobIdKey, returnvalue, timestamp )\n  local processedSet = parentKey .. ":processed"\n  rcall("HSET", processedSet, jobIdKey, returnvalue)\n  moveParentToWaitIfNoPendingDependencies(parentQueueKey, parentDependenciesKey, parentKey, parentId, timestamp)\nend\n--[[\n  Function to update a bunch of fields in a job.\n]]\nlocal function updateJobFields(jobKey, msgpackedFields)\n  if msgpackedFields and #msgpackedFields > 0 then\n    local fieldsToUpdate = cmsgpack.unpack(msgpackedFields)\n    if fieldsToUpdate then\n      rcall("HMSET", jobKey, unpack(fieldsToUpdate))\n    end\n  end\nend\nlocal jobIdKey = KEYS[12]\nif rcall("EXISTS", jobIdKey) == 1 then -- Make sure job exists\n    -- Make sure it does not have pending dependencies\n    -- It must happen before removing lock\n    if ARGV[5] == "completed" then\n        if rcall("SCARD", jobIdKey .. ":dependencies") ~= 0 then\n            return -4\n        end\n        if rcall("ZCARD", jobIdKey .. ":unsuccessful") ~= 0 then\n            return -9\n        end\n    end\n    local opts = cmsgpack.unpack(ARGV[8])\n    local token = opts[\'token\']\n    local errorCode = removeLock(jobIdKey, KEYS[5], token, ARGV[1])\n    if errorCode < 0 then\n        return errorCode\n    end\n    updateJobFields(jobIdKey, ARGV[9]);\n    local attempts = opts[\'attempts\']\n    local maxMetricsSize = opts[\'maxMetricsSize\']\n    local maxCount = opts[\'keepJobs\'][\'count\']\n    local maxAge = opts[\'keepJobs\'][\'age\']\n    local jobAttributes = rcall("HMGET", jobIdKey, "parentKey", "parent", "deid")\n    local parentKey = jobAttributes[1] or ""\n    local parentId = ""\n    local parentQueueKey = ""\n    if jobAttributes[2] then -- TODO: need to revisit this logic if it\'s still needed\n        local jsonDecodedParent = cjson.decode(jobAttributes[2])\n        parentId = jsonDecodedParent[\'id\']\n        parentQueueKey = jsonDecodedParent[\'queueKey\']\n    end\n    local jobId = ARGV[1]\n    local timestamp = ARGV[2]\n    -- Remove from active list (if not active we shall return error)\n    local numRemovedElements = rcall("LREM", KEYS[2], -1, jobId)\n    if (numRemovedElements < 1) then\n        return -3\n    end\n    local eventStreamKey = KEYS[4]\n    local metaKey = KEYS[9]\n    -- Trim events before emiting them to avoid trimming events emitted in this script\n    trimEvents(metaKey, eventStreamKey)\n    local prefix = ARGV[7]\n    removeDeduplicationKeyIfNeededOnFinalization(prefix, jobAttributes[3], jobId)\n    -- If job has a parent we need to\n    -- 1) remove this job id from parents dependencies\n    -- 2) move the job Id to parent "processed" set\n    -- 3) push the results into parent "results" list\n    -- 4) if parent\'s dependencies is empty, then move parent to "wait/paused". Note it may be a different queue!.\n    if parentId == "" and parentKey ~= "" then\n        parentId = getJobIdFromKey(parentKey)\n        parentQueueKey = getJobKeyPrefix(parentKey, ":" .. parentId)\n    end\n    if parentId ~= "" then\n        if ARGV[5] == "completed" then\n            local dependenciesSet = parentKey .. ":dependencies"\n            if rcall("SREM", dependenciesSet, jobIdKey) == 1 then\n                updateParentDepsIfNeeded(parentKey, parentQueueKey, dependenciesSet, parentId, jobIdKey, ARGV[4],\n                    timestamp)\n            end\n        else\n            moveChildFromDependenciesIfNeeded(jobAttributes[2], jobIdKey, ARGV[4], timestamp)\n        end\n    end\n    local attemptsMade = rcall("HINCRBY", jobIdKey, "atm", 1)\n    -- Remove job?\n    if maxCount ~= 0 then\n        local targetSet = KEYS[11]\n        -- Add to complete/failed set\n        rcall("ZADD", targetSet, timestamp, jobId)\n        rcall("HSET", jobIdKey, ARGV[3], ARGV[4], "finishedOn", timestamp)\n        -- "returnvalue" / "failedReason" and "finishedOn"\n        if ARGV[5] == "failed" then\n            rcall("HDEL", jobIdKey, "defa")\n        end\n        -- Remove old jobs?\n        if maxAge ~= nil then\n            removeJobsByMaxAge(timestamp, maxAge, targetSet, prefix)\n        end\n        if maxCount ~= nil and maxCount > 0 then\n            removeJobsByMaxCount(maxCount, targetSet, prefix)\n        end\n    else\n        removeJobKeys(jobIdKey)\n        if parentKey ~= "" then\n            -- TODO: when a child is removed when finished, result or failure in parent\n            -- must not be deleted, those value references should be deleted when the parent\n            -- is deleted\n            removeParentDependencyKey(jobIdKey, false, parentKey, jobAttributes[3])\n        end\n    end\n    rcall("XADD", eventStreamKey, "*", "event", ARGV[5], "jobId", jobId, ARGV[3], ARGV[4], "prev", "active")\n    if ARGV[5] == "failed" then\n        if tonumber(attemptsMade) >= tonumber(attempts) then\n            rcall("XADD", eventStreamKey, "*", "event", "retries-exhausted", "jobId", jobId, "attemptsMade",\n                attemptsMade)\n        end\n    end\n    -- Collect metrics\n    if maxMetricsSize ~= "" then\n        collectMetrics(KEYS[13], KEYS[13] .. \':data\', maxMetricsSize, timestamp)\n    end\n    -- Try to get next job to avoid an extra roundtrip if the queue is not closing,\n    -- and not rate limited.\n    if (ARGV[6] == "1") then\n        local target, isPausedOrMaxed = getTargetQueueList(metaKey, KEYS[2], KEYS[1], KEYS[8])\n        local markerKey = KEYS[14]\n        -- Check if there are delayed jobs that can be promoted\n        promoteDelayedJobs(KEYS[7], markerKey, target, KEYS[3], eventStreamKey, prefix, timestamp, KEYS[10],\n            isPausedOrMaxed)\n        local maxJobs = tonumber(opts[\'limiter\'] and opts[\'limiter\'][\'max\'])\n        -- Check if we are rate limited first.\n        local expireTime = getRateLimitTTL(maxJobs, KEYS[6])\n        if expireTime > 0 then\n            return {0, 0, expireTime, 0}\n        end\n        -- paused or maxed queue\n        if isPausedOrMaxed then\n            return {0, 0, 0, 0}\n        end\n        jobId = rcall("RPOPLPUSH", KEYS[1], KEYS[2])\n        if jobId then\n            -- Markers in waitlist DEPRECATED in v5: Remove in v6.\n            if string.sub(jobId, 1, 2) == "0:" then\n                rcall("LREM", KEYS[2], 1, jobId)\n                -- If jobId is special ID 0:delay (delay greater than 0), then there is no job to process\n                -- but if ID is 0:0, then there is at least 1 prioritized job to process\n                if jobId == "0:0" then\n                    jobId = moveJobFromPrioritizedToActive(KEYS[3], KEYS[2], KEYS[10])\n                    return prepareJobForProcessing(prefix, KEYS[6], eventStreamKey, jobId, timestamp, maxJobs,\n                        markerKey, opts)\n                end\n            else\n                return prepareJobForProcessing(prefix, KEYS[6], eventStreamKey, jobId, timestamp, maxJobs, markerKey,\n                    opts)\n            end\n        else\n            jobId = moveJobFromPrioritizedToActive(KEYS[3], KEYS[2], KEYS[10])\n            if jobId then\n                return prepareJobForProcessing(prefix, KEYS[6], eventStreamKey, jobId, timestamp, maxJobs, markerKey,\n                    opts)\n            end\n        end\n        -- Return the timestamp for the next delayed job if any.\n        local nextTimestamp = getNextDelayedTimestamp(KEYS[7])\n        if nextTimestamp ~= nil then\n            -- The result is guaranteed to be positive, since the\n            -- ZRANGEBYSCORE command would have return a job otherwise.\n            return {0, 0, 0, nextTimestamp}\n        end\n    end\n    local waitLen = rcall("LLEN", KEYS[1])\n    if waitLen == 0 then\n        local activeLen = rcall("LLEN", KEYS[2])\n        if activeLen == 0 then\n            local prioritizedLen = rcall("ZCARD", KEYS[3])\n            if prioritizedLen == 0 then\n                rcall("XADD", eventStreamKey, "*", "event", "drained")\n            end\n        end\n    end\n    return 0\nelse\n    return -1\nend\n',keys:14}},(e,t,n)=>{"use strict";n.r(t),n.d(t,{moveToWaitingChildren:()=>r});const r={name:"moveToWaitingChildren",content:'--[[\n  Moves job from active to waiting children set.\n  Input:\n    KEYS[1] active key\n    KEYS[2] wait-children key\n    KEYS[3] job key\n    KEYS[4] job dependencies key\n    KEYS[5] job unsuccessful key\n    KEYS[6] stalled key\n    KEYS[7] failed key\n    KEYS[8] events key\n    ARGV[1] token\n    ARGV[2] child key\n    ARGV[3] timestamp\n    ARGV[4] jobId\n    ARGV[5] prefix\n  Output:\n    0 - OK\n    1 - There are not pending dependencies.\n   -1 - Missing job.\n   -2 - Missing lock\n   -3 - Job not in active set\n]]\nlocal rcall = redis.call\nlocal activeKey = KEYS[1]\nlocal waitingChildrenKey = KEYS[2]\nlocal jobKey = KEYS[3]\nlocal jobDependenciesKey = KEYS[4]\nlocal jobUnsuccessfulKey = KEYS[5]\nlocal stalledKey = KEYS[6]\nlocal failedKey = KEYS[7]\nlocal timestamp = ARGV[3]\nlocal jobId = ARGV[4]\n--- Includes\n--[[\n  Function to recursively move from waitingChildren to failed.\n]]\n-- Includes\n--[[\n  Validate and move parent to a wait status (waiting, delayed or prioritized)\n  if no pending dependencies.\n]]\n-- Includes\n--[[\n  Validate and move parent to a wait status (waiting, delayed or prioritized) if needed.\n]]\n-- Includes\n--[[\n  Move parent to a wait status (wait, prioritized or delayed)\n]]\n-- Includes\n--[[\n  Add delay marker if needed.\n]]\n-- Includes\n--[[\n  Function to return the next delayed job timestamp.\n]]\nlocal function getNextDelayedTimestamp(delayedKey)\n  local result = rcall("ZRANGE", delayedKey, 0, 0, "WITHSCORES")\n  if #result then\n    local nextTimestamp = tonumber(result[2])\n    if nextTimestamp ~= nil then\n      return nextTimestamp / 0x1000\n    end\n  end\nend\nlocal function addDelayMarkerIfNeeded(markerKey, delayedKey)\n  local nextTimestamp = getNextDelayedTimestamp(delayedKey)\n  if nextTimestamp ~= nil then\n    -- Replace the score of the marker with the newest known\n    -- next timestamp.\n    rcall("ZADD", markerKey, nextTimestamp, "1")\n  end\nend\n--[[\n  Function to add job in target list and add marker if needed.\n]]\n-- Includes\n--[[\n  Add marker if needed when a job is available.\n]]\nlocal function addBaseMarkerIfNeeded(markerKey, isPausedOrMaxed)\n  if not isPausedOrMaxed then\n    rcall("ZADD", markerKey, 0, "0")\n  end  \nend\nlocal function addJobInTargetList(targetKey, markerKey, pushCmd, isPausedOrMaxed, jobId)\n  rcall(pushCmd, targetKey, jobId)\n  addBaseMarkerIfNeeded(markerKey, isPausedOrMaxed)\nend\n--[[\n  Function to add job considering priority.\n]]\n-- Includes\n--[[\n  Function to get priority score.\n]]\nlocal function getPriorityScore(priority, priorityCounterKey)\n  local prioCounter = rcall("INCR", priorityCounterKey)\n  return priority * 0x100000000 + prioCounter % 0x100000000\nend\nlocal function addJobWithPriority(markerKey, prioritizedKey, priority, jobId, priorityCounterKey,\n  isPausedOrMaxed)\n  local score = getPriorityScore(priority, priorityCounterKey)\n  rcall("ZADD", prioritizedKey, score, jobId)\n  addBaseMarkerIfNeeded(markerKey, isPausedOrMaxed)\nend\n--[[\n  Function to check if queue is paused or maxed\n  (since an empty list and !EXISTS are not really the same).\n]]\nlocal function isQueuePausedOrMaxed(queueMetaKey, activeKey)\n  local queueAttributes = rcall("HMGET", queueMetaKey, "paused", "concurrency")\n  if queueAttributes[1] then\n    return true\n  else\n    if queueAttributes[2] then\n      local activeCount = rcall("LLEN", activeKey)\n      return activeCount >= tonumber(queueAttributes[2])\n    end\n  end\n  return false\nend\n--[[\n  Function to check for the meta.paused key to decide if we are paused or not\n  (since an empty list and !EXISTS are not really the same).\n]]\nlocal function getTargetQueueList(queueMetaKey, activeKey, waitKey, pausedKey)\n  local queueAttributes = rcall("HMGET", queueMetaKey, "paused", "concurrency")\n  if queueAttributes[1] then\n    return pausedKey, true\n  else\n    if queueAttributes[2] then\n      local activeCount = rcall("LLEN", activeKey)\n      if activeCount >= tonumber(queueAttributes[2]) then\n        return waitKey, true\n      else\n        return waitKey, false\n      end\n    end\n  end\n  return waitKey, false\nend\nlocal function moveParentToWait(parentQueueKey, parentKey, parentId, timestamp)\n    local parentWaitKey = parentQueueKey .. ":wait"\n    local parentPausedKey = parentQueueKey .. ":paused"\n    local parentActiveKey = parentQueueKey .. ":active"\n    local parentMetaKey = parentQueueKey .. ":meta"\n    local parentMarkerKey = parentQueueKey .. ":marker"\n    local jobAttributes = rcall("HMGET", parentKey, "priority", "delay")\n    local priority = tonumber(jobAttributes[1]) or 0\n    local delay = tonumber(jobAttributes[2]) or 0\n    if delay > 0 then\n        local delayedTimestamp = tonumber(timestamp) + delay\n        local score = delayedTimestamp * 0x1000\n        local parentDelayedKey = parentQueueKey .. ":delayed"\n        rcall("ZADD", parentDelayedKey, score, parentId)\n        rcall("XADD", parentQueueKey .. ":events", "*", "event", "delayed", "jobId", parentId, "delay",\n            delayedTimestamp)\n        addDelayMarkerIfNeeded(parentMarkerKey, parentDelayedKey)\n    else\n        if priority == 0 then\n            local parentTarget, isParentPausedOrMaxed = getTargetQueueList(parentMetaKey, parentActiveKey,\n                parentWaitKey, parentPausedKey)\n            addJobInTargetList(parentTarget, parentMarkerKey, "RPUSH", isParentPausedOrMaxed, parentId)\n        else\n            local isPausedOrMaxed = isQueuePausedOrMaxed(parentMetaKey, parentActiveKey)\n            addJobWithPriority(parentMarkerKey, parentQueueKey .. ":prioritized", priority, parentId,\n                parentQueueKey .. ":pc", isPausedOrMaxed)\n        end\n        rcall("XADD", parentQueueKey .. ":events", "*", "event", "waiting", "jobId", parentId, "prev",\n            "waiting-children")\n    end\nend\nlocal function moveParentToWaitIfNeeded(parentQueueKey, parentKey, parentId, timestamp)\n  if rcall("EXISTS", parentKey) == 1 then\n    local parentWaitingChildrenKey = parentQueueKey .. ":waiting-children"\n    if rcall("ZSCORE", parentWaitingChildrenKey, parentId) then    \n      rcall("ZREM", parentWaitingChildrenKey, parentId)\n      moveParentToWait(parentQueueKey, parentKey, parentId, timestamp)\n    end\n  end\nend\nlocal function moveParentToWaitIfNoPendingDependencies(parentQueueKey, parentDependenciesKey, parentKey,\n  parentId, timestamp)\n  local doNotHavePendingDependencies = rcall("SCARD", parentDependenciesKey) == 0\n  if doNotHavePendingDependencies then\n    moveParentToWaitIfNeeded(parentQueueKey, parentKey, parentId, timestamp)\n  end\nend\n--[[\n  Functions to remove jobs when removeOnFail option is provided.\n]]\n-- Includes\n--[[\n  Function to remove job.\n]]\n-- Includes\n--[[\n  Function to remove deduplication key if needed\n  when a job is being removed.\n]]\nlocal function removeDeduplicationKeyIfNeededOnRemoval(prefixKey,\n  jobKey, jobId)\n  local deduplicationId = rcall("HGET", jobKey, "deid")\n  if deduplicationId then\n    local deduplicationKey = prefixKey .. "de:" .. deduplicationId\n    local currentJobId = rcall(\'GET\', deduplicationKey)\n    if currentJobId and currentJobId == jobId then\n      return rcall("DEL", deduplicationKey)\n    end\n  end\nend\n--[[\n  Function to remove job keys.\n]]\nlocal function removeJobKeys(jobKey)\n  return rcall("DEL", jobKey, jobKey .. \':logs\', jobKey .. \':dependencies\',\n    jobKey .. \':processed\', jobKey .. \':failed\', jobKey .. \':unsuccessful\')\nend\n--[[\n  Check if this job has a parent. If so we will just remove it from\n  the parent child list, but if it is the last child we should move the parent to "wait/paused"\n  which requires code from "moveToFinished"\n]]\n-- Includes\n--[[\n  Functions to destructure job key.\n  Just a bit of warning, these functions may be a bit slow and affect performance significantly.\n]]\nlocal getJobIdFromKey = function (jobKey)\n  return string.match(jobKey, ".*:(.*)")\nend\nlocal getJobKeyPrefix = function (jobKey, jobId)\n  return string.sub(jobKey, 0, #jobKey - #jobId)\nend\nlocal function _moveParentToWait(parentPrefix, parentId, emitEvent)\n  local parentTarget, isPausedOrMaxed = getTargetQueueList(parentPrefix .. "meta", parentPrefix .. "active",\n    parentPrefix .. "wait", parentPrefix .. "paused")\n  addJobInTargetList(parentTarget, parentPrefix .. "marker", "RPUSH", isPausedOrMaxed, parentId)\n  if emitEvent then\n    local parentEventStream = parentPrefix .. "events"\n    rcall("XADD", parentEventStream, "*", "event", "waiting", "jobId", parentId, "prev", "waiting-children")\n  end\nend\nlocal function removeParentDependencyKey(jobKey, hard, parentKey, baseKey, debounceId)\n  if parentKey then\n    local parentDependenciesKey = parentKey .. ":dependencies"\n    local result = rcall("SREM", parentDependenciesKey, jobKey)\n    if result > 0 then\n      local pendingDependencies = rcall("SCARD", parentDependenciesKey)\n      if pendingDependencies == 0 then\n        local parentId = getJobIdFromKey(parentKey)\n        local parentPrefix = getJobKeyPrefix(parentKey, parentId)\n        local numRemovedElements = rcall("ZREM", parentPrefix .. "waiting-children", parentId)\n        if numRemovedElements == 1 then\n          if hard then -- remove parent in same queue\n            if parentPrefix == baseKey then\n              removeParentDependencyKey(parentKey, hard, nil, baseKey, nil)\n              removeJobKeys(parentKey)\n              if debounceId then\n                rcall("DEL", parentPrefix .. "de:" .. debounceId)\n              end\n            else\n              _moveParentToWait(parentPrefix, parentId)\n            end\n          else\n            _moveParentToWait(parentPrefix, parentId, true)\n          end\n        end\n      end\n      return true\n    end\n  else\n    local parentAttributes = rcall("HMGET", jobKey, "parentKey", "deid")\n    local missedParentKey = parentAttributes[1]\n    if( (type(missedParentKey) == "string") and missedParentKey ~= ""\n      and (rcall("EXISTS", missedParentKey) == 1)) then\n      local parentDependenciesKey = missedParentKey .. ":dependencies"\n      local result = rcall("SREM", parentDependenciesKey, jobKey)\n      if result > 0 then\n        local pendingDependencies = rcall("SCARD", parentDependenciesKey)\n        if pendingDependencies == 0 then\n          local parentId = getJobIdFromKey(missedParentKey)\n          local parentPrefix = getJobKeyPrefix(missedParentKey, parentId)\n          local numRemovedElements = rcall("ZREM", parentPrefix .. "waiting-children", parentId)\n          if numRemovedElements == 1 then\n            if hard then\n              if parentPrefix == baseKey then\n                removeParentDependencyKey(missedParentKey, hard, nil, baseKey, nil)\n                removeJobKeys(missedParentKey)\n                if parentAttributes[2] then\n                  rcall("DEL", parentPrefix .. "de:" .. parentAttributes[2])\n                end\n              else\n                _moveParentToWait(parentPrefix, parentId)\n              end\n            else\n              _moveParentToWait(parentPrefix, parentId, true)\n            end\n          end\n        end\n        return true\n      end\n    end\n  end\n  return false\nend\nlocal function removeJob(jobId, hard, baseKey, shouldRemoveDeduplicationKey)\n  local jobKey = baseKey .. jobId\n  removeParentDependencyKey(jobKey, hard, nil, baseKey)\n  if shouldRemoveDeduplicationKey then\n    removeDeduplicationKeyIfNeededOnRemoval(baseKey, jobKey, jobId)\n  end\n  removeJobKeys(jobKey)\nend\n--[[\n  Functions to remove jobs by max age.\n]]\n-- Includes\nlocal function removeJobsByMaxAge(timestamp, maxAge, targetSet, prefix,\n  shouldRemoveDebounceKey)\n  local start = timestamp - maxAge * 1000\n  local jobIds = rcall("ZREVRANGEBYSCORE", targetSet, start, "-inf")\n  for i, jobId in ipairs(jobIds) do\n    removeJob(jobId, false, prefix, false --[[remove debounce key]])\n  end\n  rcall("ZREMRANGEBYSCORE", targetSet, "-inf", start)\nend\n--[[\n  Functions to remove jobs by max count.\n]]\n-- Includes\nlocal function removeJobsByMaxCount(maxCount, targetSet, prefix)\n  local start = maxCount\n  local jobIds = rcall("ZREVRANGE", targetSet, start, -1)\n  for i, jobId in ipairs(jobIds) do\n    removeJob(jobId, false, prefix, false --[[remove debounce key]])\n  end\n  rcall("ZREMRANGEBYRANK", targetSet, 0, -(maxCount + 1))\nend\nlocal function removeJobsOnFail(queueKeyPrefix, failedKey, jobId, opts, timestamp)\n  local removeOnFailType = type(opts["removeOnFail"])\n  if removeOnFailType == "number" then\n    removeJobsByMaxCount(opts["removeOnFail"],\n                        failedKey, queueKeyPrefix)\n  elseif removeOnFailType == "boolean" then\n    if opts["removeOnFail"] then\n      removeJob(jobId, false, queueKeyPrefix,\n                false --[[remove debounce key]])\n      rcall("ZREM", failedKey, jobId)\n    end\n  elseif removeOnFailType ~= "nil" then\n    local maxAge = opts["removeOnFail"]["age"]\n    local maxCount = opts["removeOnFail"]["count"]\n    if maxAge ~= nil then\n      removeJobsByMaxAge(timestamp, maxAge,\n                        failedKey, queueKeyPrefix)\n    end\n    if maxCount ~= nil and maxCount > 0 then\n      removeJobsByMaxCount(maxCount, failedKey,\n                            queueKeyPrefix)\n    end\n  end \nend\nlocal moveParentToFailedIfNeeded = function (parentQueueKey, parentKey, parentId, jobIdKey, timestamp)\n  if rcall("EXISTS", parentKey) == 1 then\n    local parentWaitingChildrenKey = parentQueueKey .. ":waiting-children"\n    local parentDelayedKey = parentQueueKey .. ":delayed"\n    local parentPrioritizedKey = parentQueueKey .. ":prioritized"\n    local parentWaitingChildrenOrDelayedKey\n    local prevState\n    if rcall("ZSCORE", parentWaitingChildrenKey, parentId) then\n      parentWaitingChildrenOrDelayedKey = parentWaitingChildrenKey\n      prevState = "waiting-children"\n    elseif rcall("ZSCORE", parentDelayedKey, parentId) then\n      parentWaitingChildrenOrDelayedKey = parentDelayedKey\n      prevState = "delayed"\n      rcall("HSET", parentKey, "delay", 0)\n    end\n    if parentWaitingChildrenOrDelayedKey then\n      rcall("ZREM", parentWaitingChildrenOrDelayedKey, parentId)\n      local parentQueuePrefix = parentQueueKey .. ":"\n      local parentFailedKey = parentQueueKey .. ":failed"\n      local deferredFailure = "child " .. jobIdKey .. " failed"\n      rcall("HSET", parentKey, "defa", deferredFailure)\n      moveParentToWait(parentQueueKey, parentKey, parentId, timestamp)\n    else\n      if not rcall("ZSCORE", parentQueueKey .. ":failed", parentId) then\n        local deferredFailure = "child " .. jobIdKey .. " failed"\n        rcall("HSET", parentKey, "defa", deferredFailure)\n      end\n    end\n  end\nend\nlocal moveChildFromDependenciesIfNeeded = function (rawParentData, childKey, failedReason, timestamp)\n  if rawParentData then\n    local parentData = cjson.decode(rawParentData)\n    local parentKey = parentData[\'queueKey\'] .. \':\' .. parentData[\'id\']\n    local parentDependenciesChildrenKey = parentKey .. ":dependencies"\n    if parentData[\'fpof\'] then\n      if rcall("SREM", parentDependenciesChildrenKey, childKey) == 1 then\n        local parentUnsuccesssfulChildrenKey = parentKey .. ":unsuccessful"\n        rcall("ZADD", parentUnsuccesssfulChildrenKey, timestamp, childKey)\n        moveParentToFailedIfNeeded(\n          parentData[\'queueKey\'],\n          parentKey,\n          parentData[\'id\'],\n          childKey,\n          timestamp\n        )\n      end\n    elseif parentData[\'cpof\'] then\n      if rcall("SREM", parentDependenciesChildrenKey, childKey) == 1 then\n        local parentFailedChildrenKey = parentKey .. ":failed"\n        rcall("HSET", parentFailedChildrenKey, childKey, failedReason)\n        moveParentToWaitIfNeeded(parentData[\'queueKey\'], parentKey, parentData[\'id\'], timestamp)\n      end\n    elseif parentData[\'idof\'] or parentData[\'rdof\'] then\n      if rcall("SREM", parentDependenciesChildrenKey, childKey) == 1 then\n        moveParentToWaitIfNoPendingDependencies(parentData[\'queueKey\'], parentDependenciesChildrenKey,\n          parentKey, parentData[\'id\'], timestamp)\n        if parentData[\'idof\'] then\n          local parentFailedChildrenKey = parentKey .. ":failed"\n          rcall("HSET", parentFailedChildrenKey, childKey, failedReason)\n        end\n      end\n    end\n  end\nend\n--[[\n  Function to remove deduplication key if needed\n  when a job is moved to completed or failed states.\n]]\nlocal function removeDeduplicationKeyIfNeededOnFinalization(prefixKey,\n  deduplicationId, jobId)\n  if deduplicationId then\n    local deduplicationKey = prefixKey .. "de:" .. deduplicationId\n    local pttl = rcall("PTTL", deduplicationKey)\n    if pttl == 0 then\n      return rcall("DEL", deduplicationKey)\n    end\n    if pttl == -1 then\n      local currentJobId = rcall(\'GET\', deduplicationKey)\n      if currentJobId and currentJobId == jobId then\n        return rcall("DEL", deduplicationKey)\n      end\n    end\n  end\nend\nlocal function removeLock(jobKey, stalledKey, token, jobId)\n  if token ~= "0" then\n    local lockKey = jobKey .. \':lock\'\n    local lockToken = rcall("GET", lockKey)\n    if lockToken == token then\n      rcall("DEL", lockKey)\n      rcall("SREM", stalledKey, jobId)\n    else\n      if lockToken then\n        -- Lock exists but token does not match\n        return -6\n      else\n        -- Lock is missing completely\n        return -2\n      end\n    end\n  end\n  return 0\nend\nlocal function moveToWaitingChildren(activeKey, waitingChildrenKey, jobId,\n    timestamp)\n  local score = tonumber(timestamp)\n  local numRemovedElements = rcall("LREM", activeKey, -1, jobId)\n  if(numRemovedElements < 1) then\n    return -3\n  end\n  rcall("ZADD", waitingChildrenKey, score, jobId)\n  return 0\nend\nif rcall("EXISTS", jobKey) == 1 then\n  if rcall("ZCARD", jobUnsuccessfulKey) ~= 0 then\n    -- TODO: refactor this logic in an include later\n    local jobAttributes = rcall("HMGET", jobKey, "parent", "deid", "opts")\n    removeDeduplicationKeyIfNeededOnFinalization(ARGV[5], jobAttributes[2], jobId)\n    local failedReason = "children are failed"\n    rcall("ZADD", failedKey, timestamp, jobId)\n    rcall("HSET", jobKey, "finishedOn", timestamp)\n    rcall("XADD", KEYS[8], "*", "event", "failed", "jobId", jobId, "failedReason",\n      failedReason, "prev", "active")\n    local rawParentData = jobAttributes[1]\n    local rawOpts = jobAttributes[3]\n    local opts = cjson.decode(rawOpts)\n    moveChildFromDependenciesIfNeeded(rawParentData, jobKey, failedReason, timestamp)\n    removeJobsOnFail(ARGV[5], failedKey, jobId, opts, timestamp)\n    return 0\n  else\n    if ARGV[2] ~= "" then\n      if rcall("SISMEMBER", jobDependenciesKey, ARGV[2]) ~= 0 then\n        local errorCode = removeLock(jobKey, stalledKey, ARGV[1], jobId)\n        if errorCode < 0 then\n          return errorCode\n        end\n        return moveToWaitingChildren(activeKey, waitingChildrenKey, jobId, timestamp)\n      end\n      return 1\n    else\n      if rcall("SCARD", jobDependenciesKey) ~= 0 then \n        local errorCode = removeLock(jobKey, stalledKey, ARGV[1], jobId)\n        if errorCode < 0 then\n          return errorCode\n        end\n        return moveToWaitingChildren(activeKey, waitingChildrenKey, jobId, timestamp)\n      end\n      return 1\n    end    \n  end\nend\nreturn -1\n',keys:8}},(e,t,n)=>{"use strict";n.r(t),n.d(t,{obliterate:()=>r});const r={name:"obliterate",content:'--[[\n  Completely obliterates a queue and all of its contents\n  This command completely destroys a queue including all of its jobs, current or past \n  leaving no trace of its existence. Since this script needs to iterate to find all the job\n  keys, consider that this call may be slow for very large queues.\n  The queue needs to be "paused" or it will return an error\n  If the queue has currently active jobs then the script by default will return error,\n  however this behaviour can be overrided using the \'force\' option.\n  Input:\n    KEYS[1] meta\n    KEYS[2] base\n    ARGV[1] count\n    ARGV[2] force\n]]\nlocal maxCount = tonumber(ARGV[1])\nlocal baseKey = KEYS[2]\nlocal rcall = redis.call\n-- Includes\n--[[\n  Functions to remove jobs.\n]]\n-- Includes\n--[[\n  Function to remove job.\n]]\n-- Includes\n--[[\n  Function to remove deduplication key if needed\n  when a job is being removed.\n]]\nlocal function removeDeduplicationKeyIfNeededOnRemoval(prefixKey,\n  jobKey, jobId)\n  local deduplicationId = rcall("HGET", jobKey, "deid")\n  if deduplicationId then\n    local deduplicationKey = prefixKey .. "de:" .. deduplicationId\n    local currentJobId = rcall(\'GET\', deduplicationKey)\n    if currentJobId and currentJobId == jobId then\n      return rcall("DEL", deduplicationKey)\n    end\n  end\nend\n--[[\n  Function to remove job keys.\n]]\nlocal function removeJobKeys(jobKey)\n  return rcall("DEL", jobKey, jobKey .. \':logs\', jobKey .. \':dependencies\',\n    jobKey .. \':processed\', jobKey .. \':failed\', jobKey .. \':unsuccessful\')\nend\n--[[\n  Check if this job has a parent. If so we will just remove it from\n  the parent child list, but if it is the last child we should move the parent to "wait/paused"\n  which requires code from "moveToFinished"\n]]\n-- Includes\n--[[\n  Function to add job in target list and add marker if needed.\n]]\n-- Includes\n--[[\n  Add marker if needed when a job is available.\n]]\nlocal function addBaseMarkerIfNeeded(markerKey, isPausedOrMaxed)\n  if not isPausedOrMaxed then\n    rcall("ZADD", markerKey, 0, "0")\n  end  \nend\nlocal function addJobInTargetList(targetKey, markerKey, pushCmd, isPausedOrMaxed, jobId)\n  rcall(pushCmd, targetKey, jobId)\n  addBaseMarkerIfNeeded(markerKey, isPausedOrMaxed)\nend\n--[[\n  Functions to destructure job key.\n  Just a bit of warning, these functions may be a bit slow and affect performance significantly.\n]]\nlocal getJobIdFromKey = function (jobKey)\n  return string.match(jobKey, ".*:(.*)")\nend\nlocal getJobKeyPrefix = function (jobKey, jobId)\n  return string.sub(jobKey, 0, #jobKey - #jobId)\nend\n--[[\n  Function to check for the meta.paused key to decide if we are paused or not\n  (since an empty list and !EXISTS are not really the same).\n]]\nlocal function getTargetQueueList(queueMetaKey, activeKey, waitKey, pausedKey)\n  local queueAttributes = rcall("HMGET", queueMetaKey, "paused", "concurrency")\n  if queueAttributes[1] then\n    return pausedKey, true\n  else\n    if queueAttributes[2] then\n      local activeCount = rcall("LLEN", activeKey)\n      if activeCount >= tonumber(queueAttributes[2]) then\n        return waitKey, true\n      else\n        return waitKey, false\n      end\n    end\n  end\n  return waitKey, false\nend\nlocal function _moveParentToWait(parentPrefix, parentId, emitEvent)\n  local parentTarget, isPausedOrMaxed = getTargetQueueList(parentPrefix .. "meta", parentPrefix .. "active",\n    parentPrefix .. "wait", parentPrefix .. "paused")\n  addJobInTargetList(parentTarget, parentPrefix .. "marker", "RPUSH", isPausedOrMaxed, parentId)\n  if emitEvent then\n    local parentEventStream = parentPrefix .. "events"\n    rcall("XADD", parentEventStream, "*", "event", "waiting", "jobId", parentId, "prev", "waiting-children")\n  end\nend\nlocal function removeParentDependencyKey(jobKey, hard, parentKey, baseKey, debounceId)\n  if parentKey then\n    local parentDependenciesKey = parentKey .. ":dependencies"\n    local result = rcall("SREM", parentDependenciesKey, jobKey)\n    if result > 0 then\n      local pendingDependencies = rcall("SCARD", parentDependenciesKey)\n      if pendingDependencies == 0 then\n        local parentId = getJobIdFromKey(parentKey)\n        local parentPrefix = getJobKeyPrefix(parentKey, parentId)\n        local numRemovedElements = rcall("ZREM", parentPrefix .. "waiting-children", parentId)\n        if numRemovedElements == 1 then\n          if hard then -- remove parent in same queue\n            if parentPrefix == baseKey then\n              removeParentDependencyKey(parentKey, hard, nil, baseKey, nil)\n              removeJobKeys(parentKey)\n              if debounceId then\n                rcall("DEL", parentPrefix .. "de:" .. debounceId)\n              end\n            else\n              _moveParentToWait(parentPrefix, parentId)\n            end\n          else\n            _moveParentToWait(parentPrefix, parentId, true)\n          end\n        end\n      end\n      return true\n    end\n  else\n    local parentAttributes = rcall("HMGET", jobKey, "parentKey", "deid")\n    local missedParentKey = parentAttributes[1]\n    if( (type(missedParentKey) == "string") and missedParentKey ~= ""\n      and (rcall("EXISTS", missedParentKey) == 1)) then\n      local parentDependenciesKey = missedParentKey .. ":dependencies"\n      local result = rcall("SREM", parentDependenciesKey, jobKey)\n      if result > 0 then\n        local pendingDependencies = rcall("SCARD", parentDependenciesKey)\n        if pendingDependencies == 0 then\n          local parentId = getJobIdFromKey(missedParentKey)\n          local parentPrefix = getJobKeyPrefix(missedParentKey, parentId)\n          local numRemovedElements = rcall("ZREM", parentPrefix .. "waiting-children", parentId)\n          if numRemovedElements == 1 then\n            if hard then\n              if parentPrefix == baseKey then\n                removeParentDependencyKey(missedParentKey, hard, nil, baseKey, nil)\n                removeJobKeys(missedParentKey)\n                if parentAttributes[2] then\n                  rcall("DEL", parentPrefix .. "de:" .. parentAttributes[2])\n                end\n              else\n                _moveParentToWait(parentPrefix, parentId)\n              end\n            else\n              _moveParentToWait(parentPrefix, parentId, true)\n            end\n          end\n        end\n        return true\n      end\n    end\n  end\n  return false\nend\nlocal function removeJob(jobId, hard, baseKey, shouldRemoveDeduplicationKey)\n  local jobKey = baseKey .. jobId\n  removeParentDependencyKey(jobKey, hard, nil, baseKey)\n  if shouldRemoveDeduplicationKey then\n    removeDeduplicationKeyIfNeededOnRemoval(baseKey, jobKey, jobId)\n  end\n  removeJobKeys(jobKey)\nend\nlocal function removeJobs(keys, hard, baseKey, max)\n  for i, key in ipairs(keys) do\n    removeJob(key, hard, baseKey, true --[[remove debounce key]])\n  end\n  return max - #keys\nend\n--[[\n  Functions to remove jobs.\n]]\n-- Includes\n--[[\n  Function to filter out jobs to ignore from a table.\n]]\nlocal function filterOutJobsToIgnore(jobs, jobsToIgnore)\n  local filteredJobs = {}\n  for i = 1, #jobs do\n    if not jobsToIgnore[jobs[i]] then\n      table.insert(filteredJobs, jobs[i])\n    end\n  end\n  return filteredJobs\nend\nlocal function getListItems(keyName, max)\n  return rcall(\'LRANGE\', keyName, 0, max - 1)\nend\nlocal function removeListJobs(keyName, hard, baseKey, max, jobsToIgnore)\n  local jobs = getListItems(keyName, max)\n  if jobsToIgnore then\n    jobs = filterOutJobsToIgnore(jobs, jobsToIgnore)\n  end\n  local count = removeJobs(jobs, hard, baseKey, max)\n  rcall("LTRIM", keyName, #jobs, -1)\n  return count\nend\n-- Includes\n--[[\n  Function to loop in batches.\n  Just a bit of warning, some commands as ZREM\n  could receive a maximum of 7000 parameters per call.\n]]\nlocal function batches(n, batchSize)\n  local i = 0\n  return function()\n    local from = i * batchSize + 1\n    i = i + 1\n    if (from <= n) then\n      local to = math.min(from + batchSize - 1, n)\n      return from, to\n    end\n  end\nend\n--[[\n  Function to get ZSet items.\n]]\nlocal function getZSetItems(keyName, max)\n  return rcall(\'ZRANGE\', keyName, 0, max - 1)\nend\nlocal function removeZSetJobs(keyName, hard, baseKey, max, jobsToIgnore)\n  local jobs = getZSetItems(keyName, max)\n  if jobsToIgnore then\n    jobs = filterOutJobsToIgnore(jobs, jobsToIgnore)\n  end\n  local count = removeJobs(jobs, hard, baseKey, max)\n  if(#jobs > 0) then\n    for from, to in batches(#jobs, 7000) do\n      rcall("ZREM", keyName, unpack(jobs, from, to))\n    end\n  end\n  return count\nend\nlocal function removeLockKeys(keys)\n  for i, key in ipairs(keys) do\n    rcall("DEL", baseKey .. key .. \':lock\')\n  end\nend\n-- 1) Check if paused, if not return with error.\nif rcall("HEXISTS", KEYS[1], "paused") ~= 1 then\n  return -1 -- Error, NotPaused\nend\n-- 2) Check if there are active jobs, if there are and not "force" return error.\nlocal activeKey = baseKey .. \'active\'\nlocal activeJobs = getListItems(activeKey, maxCount)\nif (#activeJobs > 0) then\n  if(ARGV[2] == "") then \n    return -2 -- Error, ExistActiveJobs\n  end\nend\nremoveLockKeys(activeJobs)\nmaxCount = removeJobs(activeJobs, true, baseKey, maxCount)\nrcall("LTRIM", activeKey, #activeJobs, -1)\nif(maxCount <= 0) then\n  return 1\nend\nlocal delayedKey = baseKey .. \'delayed\'\nmaxCount = removeZSetJobs(delayedKey, true, baseKey, maxCount)\nif(maxCount <= 0) then\n  return 1\nend\nlocal repeatKey = baseKey .. \'repeat\'\nlocal repeatJobsIds = getZSetItems(repeatKey, maxCount)\nfor i, key in ipairs(repeatJobsIds) do\n  local jobKey = repeatKey .. ":" .. key\n  rcall("DEL", jobKey)\nend\nif(#repeatJobsIds > 0) then\n  for from, to in batches(#repeatJobsIds, 7000) do\n    rcall("ZREM", repeatKey, unpack(repeatJobsIds, from, to))\n  end\nend\nmaxCount = maxCount - #repeatJobsIds\nif(maxCount <= 0) then\n  return 1\nend\nlocal completedKey = baseKey .. \'completed\'\nmaxCount = removeZSetJobs(completedKey, true, baseKey, maxCount)\nif(maxCount <= 0) then\n  return 1\nend\nlocal waitKey = baseKey .. \'paused\'\nmaxCount = removeListJobs(waitKey, true, baseKey, maxCount)\nif(maxCount <= 0) then\n  return 1\nend\nlocal prioritizedKey = baseKey .. \'prioritized\'\nmaxCount = removeZSetJobs(prioritizedKey, true, baseKey, maxCount)\nif(maxCount <= 0) then\n  return 1\nend\nlocal failedKey = baseKey .. \'failed\'\nmaxCount = removeZSetJobs(failedKey, true, baseKey, maxCount)\nif(maxCount <= 0) then\n  return 1\nend\nif(maxCount > 0) then\n  rcall("DEL",\n    baseKey .. \'events\',\n    baseKey .. \'delay\', \n    baseKey .. \'stalled-check\',\n    baseKey .. \'stalled\',\n    baseKey .. \'id\',\n    baseKey .. \'pc\',\n    baseKey .. \'meta\',\n    baseKey .. \'metrics:completed\',\n    baseKey .. \'metrics:completed:data\',\n    baseKey .. \'metrics:failed\',\n    baseKey .. \'metrics:failed:data\')\n  return 0\nelse\n  return 1\nend\n',keys:2}},(e,t,n)=>{"use strict";n.r(t),n.d(t,{paginate:()=>r});const r={name:"paginate",content:'--[[\n    Paginate a set or hash\n    Input:\n      KEYS[1] key pointing to the set or hash to be paginated.\n      ARGV[1]  page start offset\n      ARGV[2]  page end offset (-1 for all the elements)\n      ARGV[3]  cursor\n      ARGV[4]  offset\n      ARGV[5]  max iterations\n      ARGV[6]  fetch jobs?\n    Output:\n      [cursor, offset, items, numItems]\n]]\nlocal rcall = redis.call\n-- Includes\n--[[\n  Function to achieve pagination for a set or hash.\n  This function simulates pagination in the most efficient way possible\n  for a set using sscan or hscan.\n  The main limitation is that sets are not order preserving, so the\n  pagination is not stable. This means that if the set is modified\n  between pages, the same element may appear in different pages.\n]] -- Maximum number of elements to be returned by sscan per iteration.\nlocal maxCount = 100\n-- Finds the cursor, and returns the first elements available for the requested page.\nlocal function findPage(key, command, pageStart, pageSize, cursor, offset,\n                        maxIterations, fetchJobs)\n    local items = {}\n    local jobs = {}\n    local iterations = 0\n    repeat\n        -- Iterate over the set using sscan/hscan.\n        local result = rcall(command, key, cursor, "COUNT", maxCount)\n        cursor = result[1]\n        local members = result[2]\n        local step = 1\n        if command == "HSCAN" then\n            step = 2\n        end\n        if #members == 0 then\n            -- If the result is empty, we can return the result.\n            return cursor, offset, items, jobs\n        end\n        local chunkStart = offset\n        local chunkEnd = offset + #members / step\n        local pageEnd = pageStart + pageSize\n        if chunkEnd < pageStart then\n            -- If the chunk is before the page, we can skip it.\n            offset = chunkEnd\n        elseif chunkStart > pageEnd then\n            -- If the chunk is after the page, we can return the result.\n            return cursor, offset, items, jobs\n        else\n            -- If the chunk is overlapping the page, we need to add the elements to the result.\n            for i = 1, #members, step do\n                if offset >= pageEnd then\n                    return cursor, offset, items, jobs\n                end\n                if offset >= pageStart then\n                    local index = #items + 1\n                    if fetchJobs ~= nil then\n                        jobs[#jobs+1] = rcall("HGETALL", members[i])\n                    end\n                    if step == 2 then\n                        items[index] = {members[i], members[i + 1]}\n                    else\n                        items[index] = members[i]\n                    end\n                end\n                offset = offset + 1\n            end\n        end\n        iterations = iterations + 1\n    until cursor == "0" or iterations >= maxIterations\n    return cursor, offset, items, jobs\nend\nlocal key = KEYS[1]\nlocal scanCommand = "SSCAN"\nlocal countCommand = "SCARD"\nlocal type = rcall("TYPE", key)["ok"]\nif type == "none" then\n    return {0, 0, {}, 0}\nelseif type == "hash" then\n    scanCommand = "HSCAN"\n    countCommand = "HLEN"\nelseif type ~= "set" then\n    return\n        redis.error_reply("Pagination is only supported for sets and hashes.")\nend\nlocal numItems = rcall(countCommand, key)\nlocal startOffset = tonumber(ARGV[1])\nlocal endOffset = tonumber(ARGV[2])\nif endOffset == -1 then \n  endOffset = numItems\nend\nlocal pageSize = (endOffset - startOffset) + 1\nlocal cursor, offset, items, jobs = findPage(key, scanCommand, startOffset,\n                                       pageSize, ARGV[3], tonumber(ARGV[4]),\n                                       tonumber(ARGV[5]), ARGV[6])\nreturn {cursor, offset, items, numItems, jobs}\n',keys:1}},(e,t,n)=>{"use strict";n.r(t),n.d(t,{pause:()=>r});const r={name:"pause",content:'--[[\n  Pauses or resumes a queue globably.\n  Input:\n    KEYS[1] \'wait\' or \'paused\'\'\n    KEYS[2] \'paused\' or \'wait\'\n    KEYS[3] \'meta\'\n    KEYS[4] \'prioritized\'\n    KEYS[5] events stream key\n    KEYS[6] \'delayed\'\n    KEYS|7] \'marker\'\n    ARGV[1] \'paused\' or \'resumed\'\n  Event:\n    publish paused or resumed event.\n]]\nlocal rcall = redis.call\n-- Includes\n--[[\n  Add delay marker if needed.\n]]\n-- Includes\n--[[\n  Function to return the next delayed job timestamp.\n]]\nlocal function getNextDelayedTimestamp(delayedKey)\n  local result = rcall("ZRANGE", delayedKey, 0, 0, "WITHSCORES")\n  if #result then\n    local nextTimestamp = tonumber(result[2])\n    if nextTimestamp ~= nil then\n      return nextTimestamp / 0x1000\n    end\n  end\nend\nlocal function addDelayMarkerIfNeeded(markerKey, delayedKey)\n  local nextTimestamp = getNextDelayedTimestamp(delayedKey)\n  if nextTimestamp ~= nil then\n    -- Replace the score of the marker with the newest known\n    -- next timestamp.\n    rcall("ZADD", markerKey, nextTimestamp, "1")\n  end\nend\nlocal markerKey = KEYS[7]\nlocal hasJobs = rcall("EXISTS", KEYS[1]) == 1\n--TODO: check this logic to be reused when changing a delay\nif hasJobs then rcall("RENAME", KEYS[1], KEYS[2]) end\nif ARGV[1] == "paused" then\n    rcall("HSET", KEYS[3], "paused", 1)\n    rcall("DEL", markerKey)\nelse\n    rcall("HDEL", KEYS[3], "paused")\n    if hasJobs or rcall("ZCARD", KEYS[4]) > 0 then\n        -- Add marker if there are waiting or priority jobs\n        rcall("ZADD", markerKey, 0, "0")\n    else\n        addDelayMarkerIfNeeded(markerKey, KEYS[6])\n    end\nend\nrcall("XADD", KEYS[5], "*", "event", ARGV[1]);\n',keys:7}},(e,t,n)=>{"use strict";n.r(t),n.d(t,{promote:()=>r});const r={name:"promote",content:'--[[\n  Promotes a job that is currently "delayed" to the "waiting" state\n    Input:\n      KEYS[1] \'delayed\'\n      KEYS[2] \'wait\'\n      KEYS[3] \'paused\'\n      KEYS[4] \'meta\'\n      KEYS[5] \'prioritized\'\n      KEYS[6] \'active\'\n      KEYS[7] \'pc\' priority counter\n      KEYS[8] \'event stream\'\n      KEYS[9] \'marker\'\n      ARGV[1]  queue.toKey(\'\')\n      ARGV[2]  jobId\n    Output:\n       0 - OK\n      -3 - Job not in delayed zset.\n    Events:\n      \'waiting\'\n]]\nlocal rcall = redis.call\nlocal jobId = ARGV[2]\n-- Includes\n--[[\n  Function to add job in target list and add marker if needed.\n]]\n-- Includes\n--[[\n  Add marker if needed when a job is available.\n]]\nlocal function addBaseMarkerIfNeeded(markerKey, isPausedOrMaxed)\n  if not isPausedOrMaxed then\n    rcall("ZADD", markerKey, 0, "0")\n  end  \nend\nlocal function addJobInTargetList(targetKey, markerKey, pushCmd, isPausedOrMaxed, jobId)\n  rcall(pushCmd, targetKey, jobId)\n  addBaseMarkerIfNeeded(markerKey, isPausedOrMaxed)\nend\n--[[\n  Function to add job considering priority.\n]]\n-- Includes\n--[[\n  Function to get priority score.\n]]\nlocal function getPriorityScore(priority, priorityCounterKey)\n  local prioCounter = rcall("INCR", priorityCounterKey)\n  return priority * 0x100000000 + prioCounter % 0x100000000\nend\nlocal function addJobWithPriority(markerKey, prioritizedKey, priority, jobId, priorityCounterKey,\n  isPausedOrMaxed)\n  local score = getPriorityScore(priority, priorityCounterKey)\n  rcall("ZADD", prioritizedKey, score, jobId)\n  addBaseMarkerIfNeeded(markerKey, isPausedOrMaxed)\nend\n--[[\n  Function to check for the meta.paused key to decide if we are paused or not\n  (since an empty list and !EXISTS are not really the same).\n]]\nlocal function getTargetQueueList(queueMetaKey, activeKey, waitKey, pausedKey)\n  local queueAttributes = rcall("HMGET", queueMetaKey, "paused", "concurrency")\n  if queueAttributes[1] then\n    return pausedKey, true\n  else\n    if queueAttributes[2] then\n      local activeCount = rcall("LLEN", activeKey)\n      if activeCount >= tonumber(queueAttributes[2]) then\n        return waitKey, true\n      else\n        return waitKey, false\n      end\n    end\n  end\n  return waitKey, false\nend\nif rcall("ZREM", KEYS[1], jobId) == 1 then\n    local jobKey = ARGV[1] .. jobId\n    local priority = tonumber(rcall("HGET", jobKey, "priority")) or 0\n    local metaKey = KEYS[4]\n    local markerKey = KEYS[9]\n    -- Remove delayed "marker" from the wait list if there is any.\n    -- Since we are adding a job we do not need the marker anymore.\n    -- Markers in waitlist DEPRECATED in v5: Remove in v6.\n    local target, isPausedOrMaxed = getTargetQueueList(metaKey, KEYS[6], KEYS[2], KEYS[3])\n    local marker = rcall("LINDEX", target, 0)\n    if marker and string.sub(marker, 1, 2) == "0:" then rcall("LPOP", target) end\n    if priority == 0 then\n        -- LIFO or FIFO\n        addJobInTargetList(target, markerKey, "LPUSH", isPausedOrMaxed, jobId)\n    else\n        addJobWithPriority(markerKey, KEYS[5], priority, jobId, KEYS[7], isPausedOrMaxed)\n    end\n    -- Emit waiting event (wait..ing@token)\n    rcall("XADD", KEYS[8], "*", "event", "waiting", "jobId", jobId, "prev",\n          "delayed");\n    rcall("HSET", jobKey, "delay", 0)\n    return 0\nelse\n    return -3\nend\n',keys:9}},(e,t,n)=>{"use strict";n.r(t),n.d(t,{releaseLock:()=>r});const r={name:"releaseLock",content:'--[[\n  Release lock\n    Input:\n      KEYS[1] \'lock\',\n      ARGV[1]  token\n      ARGV[2]  lock duration in milliseconds\n    Output:\n      "OK" if lock extented succesfully.\n]]\nlocal rcall = redis.call\nif rcall("GET", KEYS[1]) == ARGV[1] then\n  return rcall("DEL", KEYS[1])\nelse\n  return 0\nend\n',keys:1}},(e,t,n)=>{"use strict";n.r(t),n.d(t,{removeChildDependency:()=>r});const r={name:"removeChildDependency",content:'--[[\n  Break parent-child dependency by removing\n  child reference from parent\n  Input:\n    KEYS[1] \'key\' prefix,\n    ARGV[1] job key\n    ARGV[2] parent key\n    Output:\n       0  - OK\n       1  - There is not relationship.\n      -1  - Missing job key\n      -5  - Missing parent key\n]]\nlocal rcall = redis.call\nlocal jobKey = ARGV[1]\nlocal parentKey = ARGV[2]\n-- Includes\n--[[\n  Check if this job has a parent. If so we will just remove it from\n  the parent child list, but if it is the last child we should move the parent to "wait/paused"\n  which requires code from "moveToFinished"\n]]\n-- Includes\n--[[\n  Function to add job in target list and add marker if needed.\n]]\n-- Includes\n--[[\n  Add marker if needed when a job is available.\n]]\nlocal function addBaseMarkerIfNeeded(markerKey, isPausedOrMaxed)\n  if not isPausedOrMaxed then\n    rcall("ZADD", markerKey, 0, "0")\n  end  \nend\nlocal function addJobInTargetList(targetKey, markerKey, pushCmd, isPausedOrMaxed, jobId)\n  rcall(pushCmd, targetKey, jobId)\n  addBaseMarkerIfNeeded(markerKey, isPausedOrMaxed)\nend\n--[[\n  Functions to destructure job key.\n  Just a bit of warning, these functions may be a bit slow and affect performance significantly.\n]]\nlocal getJobIdFromKey = function (jobKey)\n  return string.match(jobKey, ".*:(.*)")\nend\nlocal getJobKeyPrefix = function (jobKey, jobId)\n  return string.sub(jobKey, 0, #jobKey - #jobId)\nend\n--[[\n  Function to check for the meta.paused key to decide if we are paused or not\n  (since an empty list and !EXISTS are not really the same).\n]]\nlocal function getTargetQueueList(queueMetaKey, activeKey, waitKey, pausedKey)\n  local queueAttributes = rcall("HMGET", queueMetaKey, "paused", "concurrency")\n  if queueAttributes[1] then\n    return pausedKey, true\n  else\n    if queueAttributes[2] then\n      local activeCount = rcall("LLEN", activeKey)\n      if activeCount >= tonumber(queueAttributes[2]) then\n        return waitKey, true\n      else\n        return waitKey, false\n      end\n    end\n  end\n  return waitKey, false\nend\n--[[\n  Function to remove job keys.\n]]\nlocal function removeJobKeys(jobKey)\n  return rcall("DEL", jobKey, jobKey .. \':logs\', jobKey .. \':dependencies\',\n    jobKey .. \':processed\', jobKey .. \':failed\', jobKey .. \':unsuccessful\')\nend\nlocal function _moveParentToWait(parentPrefix, parentId, emitEvent)\n  local parentTarget, isPausedOrMaxed = getTargetQueueList(parentPrefix .. "meta", parentPrefix .. "active",\n    parentPrefix .. "wait", parentPrefix .. "paused")\n  addJobInTargetList(parentTarget, parentPrefix .. "marker", "RPUSH", isPausedOrMaxed, parentId)\n  if emitEvent then\n    local parentEventStream = parentPrefix .. "events"\n    rcall("XADD", parentEventStream, "*", "event", "waiting", "jobId", parentId, "prev", "waiting-children")\n  end\nend\nlocal function removeParentDependencyKey(jobKey, hard, parentKey, baseKey, debounceId)\n  if parentKey then\n    local parentDependenciesKey = parentKey .. ":dependencies"\n    local result = rcall("SREM", parentDependenciesKey, jobKey)\n    if result > 0 then\n      local pendingDependencies = rcall("SCARD", parentDependenciesKey)\n      if pendingDependencies == 0 then\n        local parentId = getJobIdFromKey(parentKey)\n        local parentPrefix = getJobKeyPrefix(parentKey, parentId)\n        local numRemovedElements = rcall("ZREM", parentPrefix .. "waiting-children", parentId)\n        if numRemovedElements == 1 then\n          if hard then -- remove parent in same queue\n            if parentPrefix == baseKey then\n              removeParentDependencyKey(parentKey, hard, nil, baseKey, nil)\n              removeJobKeys(parentKey)\n              if debounceId then\n                rcall("DEL", parentPrefix .. "de:" .. debounceId)\n              end\n            else\n              _moveParentToWait(parentPrefix, parentId)\n            end\n          else\n            _moveParentToWait(parentPrefix, parentId, true)\n          end\n        end\n      end\n      return true\n    end\n  else\n    local parentAttributes = rcall("HMGET", jobKey, "parentKey", "deid")\n    local missedParentKey = parentAttributes[1]\n    if( (type(missedParentKey) == "string") and missedParentKey ~= ""\n      and (rcall("EXISTS", missedParentKey) == 1)) then\n      local parentDependenciesKey = missedParentKey .. ":dependencies"\n      local result = rcall("SREM", parentDependenciesKey, jobKey)\n      if result > 0 then\n        local pendingDependencies = rcall("SCARD", parentDependenciesKey)\n        if pendingDependencies == 0 then\n          local parentId = getJobIdFromKey(missedParentKey)\n          local parentPrefix = getJobKeyPrefix(missedParentKey, parentId)\n          local numRemovedElements = rcall("ZREM", parentPrefix .. "waiting-children", parentId)\n          if numRemovedElements == 1 then\n            if hard then\n              if parentPrefix == baseKey then\n                removeParentDependencyKey(missedParentKey, hard, nil, baseKey, nil)\n                removeJobKeys(missedParentKey)\n                if parentAttributes[2] then\n                  rcall("DEL", parentPrefix .. "de:" .. parentAttributes[2])\n                end\n              else\n                _moveParentToWait(parentPrefix, parentId)\n              end\n            else\n              _moveParentToWait(parentPrefix, parentId, true)\n            end\n          end\n        end\n        return true\n      end\n    end\n  end\n  return false\nend\nif rcall("EXISTS", jobKey) ~= 1 then return -1 end\nif rcall("EXISTS", parentKey) ~= 1 then return -5 end\nif removeParentDependencyKey(jobKey, false, parentKey, KEYS[1], nil) then\n  rcall("HDEL", jobKey, "parentKey", "parent")\n  return 0\nelse\n  return 1\nend',keys:1}},(e,t,n)=>{"use strict";n.r(t),n.d(t,{removeJob:()=>r});const r={name:"removeJob",content:'--[[\n    Remove a job from all the statuses it may be in as well as all its data.\n    In order to be able to remove a job, it cannot be active.\n    Input:\n      KEYS[1] jobKey\n      KEYS[2] repeat key\n      ARGV[1] jobId\n      ARGV[2] remove children\n      ARGV[3] queue prefix\n    Events:\n      \'removed\'\n]]\nlocal rcall = redis.call\n-- Includes\n--[[\n  Function to check if the job belongs to a job scheduler and\n  current delayed job matches with jobId\n]]\nlocal function isJobSchedulerJob(jobId, jobKey, jobSchedulersKey)\n  local repeatJobKey = rcall("HGET", jobKey, "rjk")\n  if repeatJobKey  then\n    local prevMillis = rcall("ZSCORE", jobSchedulersKey, repeatJobKey)\n    if prevMillis then\n      local currentDelayedJobId = "repeat:" .. repeatJobKey .. ":" .. prevMillis\n      return jobId == currentDelayedJobId\n    end\n  end\n  return false\nend\n--[[\n  Function to recursively check if there are no locks\n  on the jobs to be removed.\n  returns:\n    boolean\n]]\n--[[\n  Functions to destructure job key.\n  Just a bit of warning, these functions may be a bit slow and affect performance significantly.\n]]\nlocal getJobIdFromKey = function (jobKey)\n  return string.match(jobKey, ".*:(.*)")\nend\nlocal getJobKeyPrefix = function (jobKey, jobId)\n  return string.sub(jobKey, 0, #jobKey - #jobId)\nend\nlocal function isLocked( prefix, jobId, removeChildren)\n  local jobKey = prefix .. jobId;\n  -- Check if this job is locked\n  local lockKey = jobKey .. \':lock\'\n  local lock = rcall("GET", lockKey)\n  if not lock then\n    if removeChildren == "1" then\n      local dependencies = rcall("SMEMBERS", jobKey .. ":dependencies")\n      if (#dependencies > 0) then\n        for i, childJobKey in ipairs(dependencies) do\n          -- We need to get the jobId for this job.\n          local childJobId = getJobIdFromKey(childJobKey)\n          local childJobPrefix = getJobKeyPrefix(childJobKey, childJobId)\n          local result = isLocked( childJobPrefix, childJobId, removeChildren )\n          if result then\n            return true\n          end\n        end\n      end\n    end\n    return false\n  end\n  return true\nend\n--[[\n    Remove a job from all the statuses it may be in as well as all its data,\n    including its children. Active children can be ignored.\n    Events:\n      \'removed\'\n]]\nlocal rcall = redis.call\n-- Includes\n--[[\n  Function to get max events value or set by default 10000.\n]]\nlocal function getOrSetMaxEvents(metaKey)\n  local maxEvents = rcall("HGET", metaKey, "opts.maxLenEvents")\n  if not maxEvents then\n    maxEvents = 10000\n    rcall("HSET", metaKey, "opts.maxLenEvents", maxEvents)\n  end\n  return maxEvents\nend\n--[[\n  Function to remove deduplication key if needed\n  when a job is being removed.\n]]\nlocal function removeDeduplicationKeyIfNeededOnRemoval(prefixKey,\n  jobKey, jobId)\n  local deduplicationId = rcall("HGET", jobKey, "deid")\n  if deduplicationId then\n    local deduplicationKey = prefixKey .. "de:" .. deduplicationId\n    local currentJobId = rcall(\'GET\', deduplicationKey)\n    if currentJobId and currentJobId == jobId then\n      return rcall("DEL", deduplicationKey)\n    end\n  end\nend\n--[[\n  Function to remove from any state.\n  returns:\n    prev state\n]]\nlocal function removeJobFromAnyState( prefix, jobId)\n  -- We start with the ZSCORE checks, since they have O(1) complexity\n  if rcall("ZSCORE", prefix .. "completed", jobId) then\n    rcall("ZREM", prefix .. "completed", jobId)\n    return "completed"\n  elseif rcall("ZSCORE", prefix .. "waiting-children", jobId) then\n    rcall("ZREM", prefix .. "waiting-children", jobId)\n    return "waiting-children"\n  elseif rcall("ZSCORE", prefix .. "delayed", jobId) then\n    rcall("ZREM", prefix .. "delayed", jobId)\n    return "delayed"\n  elseif rcall("ZSCORE", prefix .. "failed", jobId) then\n    rcall("ZREM", prefix .. "failed", jobId)\n    return "failed"\n  elseif rcall("ZSCORE", prefix .. "prioritized", jobId) then\n    rcall("ZREM", prefix .. "prioritized", jobId)\n    return "prioritized"\n  -- We remove only 1 element from the list, since we assume they are not added multiple times\n  elseif rcall("LREM", prefix .. "wait", 1, jobId) == 1 then\n    return "wait"\n  elseif rcall("LREM", prefix .. "paused", 1, jobId) == 1 then\n    return "paused"\n  elseif rcall("LREM", prefix .. "active", 1, jobId) == 1 then\n    return "active"\n  end\n  return "unknown"\nend\n--[[\n  Function to remove job keys.\n]]\nlocal function removeJobKeys(jobKey)\n  return rcall("DEL", jobKey, jobKey .. \':logs\', jobKey .. \':dependencies\',\n    jobKey .. \':processed\', jobKey .. \':failed\', jobKey .. \':unsuccessful\')\nend\n--[[\n  Check if this job has a parent. If so we will just remove it from\n  the parent child list, but if it is the last child we should move the parent to "wait/paused"\n  which requires code from "moveToFinished"\n]]\n-- Includes\n--[[\n  Function to add job in target list and add marker if needed.\n]]\n-- Includes\n--[[\n  Add marker if needed when a job is available.\n]]\nlocal function addBaseMarkerIfNeeded(markerKey, isPausedOrMaxed)\n  if not isPausedOrMaxed then\n    rcall("ZADD", markerKey, 0, "0")\n  end  \nend\nlocal function addJobInTargetList(targetKey, markerKey, pushCmd, isPausedOrMaxed, jobId)\n  rcall(pushCmd, targetKey, jobId)\n  addBaseMarkerIfNeeded(markerKey, isPausedOrMaxed)\nend\n--[[\n  Function to check for the meta.paused key to decide if we are paused or not\n  (since an empty list and !EXISTS are not really the same).\n]]\nlocal function getTargetQueueList(queueMetaKey, activeKey, waitKey, pausedKey)\n  local queueAttributes = rcall("HMGET", queueMetaKey, "paused", "concurrency")\n  if queueAttributes[1] then\n    return pausedKey, true\n  else\n    if queueAttributes[2] then\n      local activeCount = rcall("LLEN", activeKey)\n      if activeCount >= tonumber(queueAttributes[2]) then\n        return waitKey, true\n      else\n        return waitKey, false\n      end\n    end\n  end\n  return waitKey, false\nend\nlocal function _moveParentToWait(parentPrefix, parentId, emitEvent)\n  local parentTarget, isPausedOrMaxed = getTargetQueueList(parentPrefix .. "meta", parentPrefix .. "active",\n    parentPrefix .. "wait", parentPrefix .. "paused")\n  addJobInTargetList(parentTarget, parentPrefix .. "marker", "RPUSH", isPausedOrMaxed, parentId)\n  if emitEvent then\n    local parentEventStream = parentPrefix .. "events"\n    rcall("XADD", parentEventStream, "*", "event", "waiting", "jobId", parentId, "prev", "waiting-children")\n  end\nend\nlocal function removeParentDependencyKey(jobKey, hard, parentKey, baseKey, debounceId)\n  if parentKey then\n    local parentDependenciesKey = parentKey .. ":dependencies"\n    local result = rcall("SREM", parentDependenciesKey, jobKey)\n    if result > 0 then\n      local pendingDependencies = rcall("SCARD", parentDependenciesKey)\n      if pendingDependencies == 0 then\n        local parentId = getJobIdFromKey(parentKey)\n        local parentPrefix = getJobKeyPrefix(parentKey, parentId)\n        local numRemovedElements = rcall("ZREM", parentPrefix .. "waiting-children", parentId)\n        if numRemovedElements == 1 then\n          if hard then -- remove parent in same queue\n            if parentPrefix == baseKey then\n              removeParentDependencyKey(parentKey, hard, nil, baseKey, nil)\n              removeJobKeys(parentKey)\n              if debounceId then\n                rcall("DEL", parentPrefix .. "de:" .. debounceId)\n              end\n            else\n              _moveParentToWait(parentPrefix, parentId)\n            end\n          else\n            _moveParentToWait(parentPrefix, parentId, true)\n          end\n        end\n      end\n      return true\n    end\n  else\n    local parentAttributes = rcall("HMGET", jobKey, "parentKey", "deid")\n    local missedParentKey = parentAttributes[1]\n    if( (type(missedParentKey) == "string") and missedParentKey ~= ""\n      and (rcall("EXISTS", missedParentKey) == 1)) then\n      local parentDependenciesKey = missedParentKey .. ":dependencies"\n      local result = rcall("SREM", parentDependenciesKey, jobKey)\n      if result > 0 then\n        local pendingDependencies = rcall("SCARD", parentDependenciesKey)\n        if pendingDependencies == 0 then\n          local parentId = getJobIdFromKey(missedParentKey)\n          local parentPrefix = getJobKeyPrefix(missedParentKey, parentId)\n          local numRemovedElements = rcall("ZREM", parentPrefix .. "waiting-children", parentId)\n          if numRemovedElements == 1 then\n            if hard then\n              if parentPrefix == baseKey then\n                removeParentDependencyKey(missedParentKey, hard, nil, baseKey, nil)\n                removeJobKeys(missedParentKey)\n                if parentAttributes[2] then\n                  rcall("DEL", parentPrefix .. "de:" .. parentAttributes[2])\n                end\n              else\n                _moveParentToWait(parentPrefix, parentId)\n              end\n            else\n              _moveParentToWait(parentPrefix, parentId, true)\n            end\n          end\n        end\n        return true\n      end\n    end\n  end\n  return false\nend\nlocal removeJobChildren\nlocal removeJobWithChildren\nremoveJobChildren = function(prefix, jobKey, options)\n    -- Check if this job has children\n    -- If so, we are going to try to remove the children recursively in a depth-first way\n    -- because if some job is locked, we must exit with an error.\n    if not options.ignoreProcessed then\n        local processed = rcall("HGETALL", jobKey .. ":processed")\n        if #processed > 0 then\n            for i = 1, #processed, 2 do\n                local childJobId = getJobIdFromKey(processed[i])\n                local childJobPrefix = getJobKeyPrefix(processed[i], childJobId)\n                removeJobWithChildren(childJobPrefix, childJobId, jobKey, options)\n            end\n        end\n        local failed = rcall("HGETALL", jobKey .. ":failed")\n        if #failed > 0 then\n            for i = 1, #failed, 2 do\n                local childJobId = getJobIdFromKey(failed[i])\n                local childJobPrefix = getJobKeyPrefix(failed[i], childJobId)\n                removeJobWithChildren(childJobPrefix, childJobId, jobKey, options)\n            end\n        end\n        local unsuccessful = rcall("ZRANGE", jobKey .. ":unsuccessful", 0, -1)\n        if #unsuccessful > 0 then\n            for i = 1, #unsuccessful, 1 do\n                local childJobId = getJobIdFromKey(unsuccessful[i])\n                local childJobPrefix = getJobKeyPrefix(unsuccessful[i], childJobId)\n                removeJobWithChildren(childJobPrefix, childJobId, jobKey, options)\n            end\n        end\n    end\n    local dependencies = rcall("SMEMBERS", jobKey .. ":dependencies")\n    if #dependencies > 0 then\n        for i, childJobKey in ipairs(dependencies) do\n            local childJobId = getJobIdFromKey(childJobKey)\n            local childJobPrefix = getJobKeyPrefix(childJobKey, childJobId)\n            removeJobWithChildren(childJobPrefix, childJobId, jobKey, options)\n        end\n    end\nend\nremoveJobWithChildren = function(prefix, jobId, parentKey, options)\n    local jobKey = prefix .. jobId\n    if options.ignoreLocked then\n        if isLocked(prefix, jobId) then\n            return\n        end\n    end\n    -- Check if job is in the failed zset\n    local failedSet = prefix .. "failed"\n    if not (options.ignoreProcessed and rcall("ZSCORE", failedSet, jobId)) then\n        removeParentDependencyKey(jobKey, false, parentKey, nil)\n        if options.removeChildren then\n            removeJobChildren(prefix, jobKey, options)\n        end\n        local prev = removeJobFromAnyState(prefix, jobId)\n        removeDeduplicationKeyIfNeededOnRemoval(prefix, jobKey, jobId)\n        if removeJobKeys(jobKey) > 0 then\n            local metaKey = prefix .. "meta"\n            local maxEvents = getOrSetMaxEvents(metaKey)\n            rcall("XADD", prefix .. "events", "MAXLEN", "~", maxEvents, "*", "event", "removed",\n                "jobId", jobId, "prev", prev)\n        end\n    end\nend\nlocal jobId = ARGV[1]\nlocal shouldRemoveChildren = ARGV[2]\nlocal prefix = ARGV[3]\nlocal jobKey = KEYS[1]\nlocal repeatKey = KEYS[2]\nif isJobSchedulerJob(jobId, jobKey, repeatKey) then\n    return -8\nend\nif not isLocked(prefix, jobId, shouldRemoveChildren) then\n    local options = {\n        removeChildren = shouldRemoveChildren == "1",\n        ignoreProcessed = false,\n        ignoreLocked = false\n    }\n    removeJobWithChildren(prefix, jobId, nil, options)\n    return 1\nend\nreturn 0\n',keys:2}},(e,t,n)=>{"use strict";n.r(t),n.d(t,{removeJobScheduler:()=>r});const r={name:"removeJobScheduler",content:'--[[\n  Removes a job scheduler and its next scheduled job.\n  Input:\n    KEYS[1] job schedulers key\n    KEYS[2] delayed jobs key\n    KEYS[3] events key\n    ARGV[1] job scheduler id\n    ARGV[2] prefix key\n  Output:\n    0 - OK\n    1 - Missing repeat job\n  Events:\n    \'removed\'\n]]\nlocal rcall = redis.call\n-- Includes\n--[[\n  Function to remove job keys.\n]]\nlocal function removeJobKeys(jobKey)\n  return rcall("DEL", jobKey, jobKey .. \':logs\', jobKey .. \':dependencies\',\n    jobKey .. \':processed\', jobKey .. \':failed\', jobKey .. \':unsuccessful\')\nend\nlocal jobSchedulerId = ARGV[1]\nlocal prefix = ARGV[2]\nlocal millis = rcall("ZSCORE", KEYS[1], jobSchedulerId)\nif millis then\n  -- Delete next programmed job.\n  local delayedJobId = "repeat:" .. jobSchedulerId .. ":" .. millis\n  if(rcall("ZREM", KEYS[2], delayedJobId) == 1) then\n    removeJobKeys(prefix .. delayedJobId)\n    rcall("XADD", KEYS[3], "*", "event", "removed", "jobId", delayedJobId, "prev", "delayed")\n  end\nend\nif(rcall("ZREM", KEYS[1], jobSchedulerId) == 1) then\n  rcall("DEL", KEYS[1] .. ":" .. jobSchedulerId)\n  return 0\nend\nreturn 1\n',keys:3}},(e,t,n)=>{"use strict";n.r(t),n.d(t,{removeRepeatable:()=>r});const r={name:"removeRepeatable",content:'--[[\n  Removes a repeatable job\n  Input:\n    KEYS[1] repeat jobs key\n    KEYS[2] delayed jobs key\n    KEYS[3] events key\n    ARGV[1] old repeat job id\n    ARGV[2] options concat\n    ARGV[3] repeat job key\n    ARGV[4] prefix key\n  Output:\n    0 - OK\n    1 - Missing repeat job\n  Events:\n    \'removed\'\n]]\nlocal rcall = redis.call\nlocal millis = rcall("ZSCORE", KEYS[1], ARGV[2])\n-- Includes\n--[[\n  Function to remove job keys.\n]]\nlocal function removeJobKeys(jobKey)\n  return rcall("DEL", jobKey, jobKey .. \':logs\', jobKey .. \':dependencies\',\n    jobKey .. \':processed\', jobKey .. \':failed\', jobKey .. \':unsuccessful\')\nend\n-- legacy removal TODO: remove in next breaking change\nif millis then\n  -- Delete next programmed job.\n  local repeatJobId = ARGV[1] .. millis\n  if(rcall("ZREM", KEYS[2], repeatJobId) == 1) then\n    removeJobKeys(ARGV[4] .. repeatJobId)\n    rcall("XADD", KEYS[3], "*", "event", "removed", "jobId", repeatJobId, "prev", "delayed");\n  end\nend\nif(rcall("ZREM", KEYS[1], ARGV[2]) == 1) then\n  return 0\nend\n-- new removal\nmillis = rcall("ZSCORE", KEYS[1], ARGV[3])\nif millis then\n  -- Delete next programmed job.\n  local repeatJobId = "repeat:" .. ARGV[3] .. ":" .. millis\n  if(rcall("ZREM", KEYS[2], repeatJobId) == 1) then\n    removeJobKeys(ARGV[4] .. repeatJobId)\n    rcall("XADD", KEYS[3], "*", "event", "removed", "jobId", repeatJobId, "prev", "delayed")\n  end\nend\nif(rcall("ZREM", KEYS[1], ARGV[3]) == 1) then\n  rcall("DEL", KEYS[1] .. ":" .. ARGV[3])\n  return 0\nend\nreturn 1\n',keys:3}},(e,t,n)=>{"use strict";n.r(t),n.d(t,{removeUnprocessedChildren:()=>r});const r={name:"removeUnprocessedChildren",content:'--[[\n    Remove a job from all the statuses it may be in as well as all its data.\n    In order to be able to remove a job, it cannot be active.\n    Input:\n      KEYS[1] jobKey\n      KEYS[2] meta key\n      ARGV[1] prefix\n      ARGV[2] jobId\n    Events:\n      \'removed\' for every children removed\n]]\n-- Includes\n--[[\n    Remove a job from all the statuses it may be in as well as all its data,\n    including its children. Active children can be ignored.\n    Events:\n      \'removed\'\n]]\nlocal rcall = redis.call\n-- Includes\n--[[\n  Functions to destructure job key.\n  Just a bit of warning, these functions may be a bit slow and affect performance significantly.\n]]\nlocal getJobIdFromKey = function (jobKey)\n  return string.match(jobKey, ".*:(.*)")\nend\nlocal getJobKeyPrefix = function (jobKey, jobId)\n  return string.sub(jobKey, 0, #jobKey - #jobId)\nend\n--[[\n  Function to get max events value or set by default 10000.\n]]\nlocal function getOrSetMaxEvents(metaKey)\n  local maxEvents = rcall("HGET", metaKey, "opts.maxLenEvents")\n  if not maxEvents then\n    maxEvents = 10000\n    rcall("HSET", metaKey, "opts.maxLenEvents", maxEvents)\n  end\n  return maxEvents\nend\n--[[\n  Function to check if the job belongs to a job scheduler and\n  current delayed job matches with jobId\n]]\nlocal function isJobSchedulerJob(jobId, jobKey, jobSchedulersKey)\n  local repeatJobKey = rcall("HGET", jobKey, "rjk")\n  if repeatJobKey  then\n    local prevMillis = rcall("ZSCORE", jobSchedulersKey, repeatJobKey)\n    if prevMillis then\n      local currentDelayedJobId = "repeat:" .. repeatJobKey .. ":" .. prevMillis\n      return jobId == currentDelayedJobId\n    end\n  end\n  return false\nend\n--[[\n  Function to remove deduplication key if needed\n  when a job is being removed.\n]]\nlocal function removeDeduplicationKeyIfNeededOnRemoval(prefixKey,\n  jobKey, jobId)\n  local deduplicationId = rcall("HGET", jobKey, "deid")\n  if deduplicationId then\n    local deduplicationKey = prefixKey .. "de:" .. deduplicationId\n    local currentJobId = rcall(\'GET\', deduplicationKey)\n    if currentJobId and currentJobId == jobId then\n      return rcall("DEL", deduplicationKey)\n    end\n  end\nend\n--[[\n  Function to remove from any state.\n  returns:\n    prev state\n]]\nlocal function removeJobFromAnyState( prefix, jobId)\n  -- We start with the ZSCORE checks, since they have O(1) complexity\n  if rcall("ZSCORE", prefix .. "completed", jobId) then\n    rcall("ZREM", prefix .. "completed", jobId)\n    return "completed"\n  elseif rcall("ZSCORE", prefix .. "waiting-children", jobId) then\n    rcall("ZREM", prefix .. "waiting-children", jobId)\n    return "waiting-children"\n  elseif rcall("ZSCORE", prefix .. "delayed", jobId) then\n    rcall("ZREM", prefix .. "delayed", jobId)\n    return "delayed"\n  elseif rcall("ZSCORE", prefix .. "failed", jobId) then\n    rcall("ZREM", prefix .. "failed", jobId)\n    return "failed"\n  elseif rcall("ZSCORE", prefix .. "prioritized", jobId) then\n    rcall("ZREM", prefix .. "prioritized", jobId)\n    return "prioritized"\n  -- We remove only 1 element from the list, since we assume they are not added multiple times\n  elseif rcall("LREM", prefix .. "wait", 1, jobId) == 1 then\n    return "wait"\n  elseif rcall("LREM", prefix .. "paused", 1, jobId) == 1 then\n    return "paused"\n  elseif rcall("LREM", prefix .. "active", 1, jobId) == 1 then\n    return "active"\n  end\n  return "unknown"\nend\n--[[\n  Function to remove job keys.\n]]\nlocal function removeJobKeys(jobKey)\n  return rcall("DEL", jobKey, jobKey .. \':logs\', jobKey .. \':dependencies\',\n    jobKey .. \':processed\', jobKey .. \':failed\', jobKey .. \':unsuccessful\')\nend\n--[[\n  Check if this job has a parent. If so we will just remove it from\n  the parent child list, but if it is the last child we should move the parent to "wait/paused"\n  which requires code from "moveToFinished"\n]]\n-- Includes\n--[[\n  Function to add job in target list and add marker if needed.\n]]\n-- Includes\n--[[\n  Add marker if needed when a job is available.\n]]\nlocal function addBaseMarkerIfNeeded(markerKey, isPausedOrMaxed)\n  if not isPausedOrMaxed then\n    rcall("ZADD", markerKey, 0, "0")\n  end  \nend\nlocal function addJobInTargetList(targetKey, markerKey, pushCmd, isPausedOrMaxed, jobId)\n  rcall(pushCmd, targetKey, jobId)\n  addBaseMarkerIfNeeded(markerKey, isPausedOrMaxed)\nend\n--[[\n  Function to check for the meta.paused key to decide if we are paused or not\n  (since an empty list and !EXISTS are not really the same).\n]]\nlocal function getTargetQueueList(queueMetaKey, activeKey, waitKey, pausedKey)\n  local queueAttributes = rcall("HMGET", queueMetaKey, "paused", "concurrency")\n  if queueAttributes[1] then\n    return pausedKey, true\n  else\n    if queueAttributes[2] then\n      local activeCount = rcall("LLEN", activeKey)\n      if activeCount >= tonumber(queueAttributes[2]) then\n        return waitKey, true\n      else\n        return waitKey, false\n      end\n    end\n  end\n  return waitKey, false\nend\nlocal function _moveParentToWait(parentPrefix, parentId, emitEvent)\n  local parentTarget, isPausedOrMaxed = getTargetQueueList(parentPrefix .. "meta", parentPrefix .. "active",\n    parentPrefix .. "wait", parentPrefix .. "paused")\n  addJobInTargetList(parentTarget, parentPrefix .. "marker", "RPUSH", isPausedOrMaxed, parentId)\n  if emitEvent then\n    local parentEventStream = parentPrefix .. "events"\n    rcall("XADD", parentEventStream, "*", "event", "waiting", "jobId", parentId, "prev", "waiting-children")\n  end\nend\nlocal function removeParentDependencyKey(jobKey, hard, parentKey, baseKey, debounceId)\n  if parentKey then\n    local parentDependenciesKey = parentKey .. ":dependencies"\n    local result = rcall("SREM", parentDependenciesKey, jobKey)\n    if result > 0 then\n      local pendingDependencies = rcall("SCARD", parentDependenciesKey)\n      if pendingDependencies == 0 then\n        local parentId = getJobIdFromKey(parentKey)\n        local parentPrefix = getJobKeyPrefix(parentKey, parentId)\n        local numRemovedElements = rcall("ZREM", parentPrefix .. "waiting-children", parentId)\n        if numRemovedElements == 1 then\n          if hard then -- remove parent in same queue\n            if parentPrefix == baseKey then\n              removeParentDependencyKey(parentKey, hard, nil, baseKey, nil)\n              removeJobKeys(parentKey)\n              if debounceId then\n                rcall("DEL", parentPrefix .. "de:" .. debounceId)\n              end\n            else\n              _moveParentToWait(parentPrefix, parentId)\n            end\n          else\n            _moveParentToWait(parentPrefix, parentId, true)\n          end\n        end\n      end\n      return true\n    end\n  else\n    local parentAttributes = rcall("HMGET", jobKey, "parentKey", "deid")\n    local missedParentKey = parentAttributes[1]\n    if( (type(missedParentKey) == "string") and missedParentKey ~= ""\n      and (rcall("EXISTS", missedParentKey) == 1)) then\n      local parentDependenciesKey = missedParentKey .. ":dependencies"\n      local result = rcall("SREM", parentDependenciesKey, jobKey)\n      if result > 0 then\n        local pendingDependencies = rcall("SCARD", parentDependenciesKey)\n        if pendingDependencies == 0 then\n          local parentId = getJobIdFromKey(missedParentKey)\n          local parentPrefix = getJobKeyPrefix(missedParentKey, parentId)\n          local numRemovedElements = rcall("ZREM", parentPrefix .. "waiting-children", parentId)\n          if numRemovedElements == 1 then\n            if hard then\n              if parentPrefix == baseKey then\n                removeParentDependencyKey(missedParentKey, hard, nil, baseKey, nil)\n                removeJobKeys(missedParentKey)\n                if parentAttributes[2] then\n                  rcall("DEL", parentPrefix .. "de:" .. parentAttributes[2])\n                end\n              else\n                _moveParentToWait(parentPrefix, parentId)\n              end\n            else\n              _moveParentToWait(parentPrefix, parentId, true)\n            end\n          end\n        end\n        return true\n      end\n    end\n  end\n  return false\nend\n--[[\n  Function to recursively check if there are no locks\n  on the jobs to be removed.\n  returns:\n    boolean\n]]\nlocal function isLocked( prefix, jobId, removeChildren)\n  local jobKey = prefix .. jobId;\n  -- Check if this job is locked\n  local lockKey = jobKey .. \':lock\'\n  local lock = rcall("GET", lockKey)\n  if not lock then\n    if removeChildren == "1" then\n      local dependencies = rcall("SMEMBERS", jobKey .. ":dependencies")\n      if (#dependencies > 0) then\n        for i, childJobKey in ipairs(dependencies) do\n          -- We need to get the jobId for this job.\n          local childJobId = getJobIdFromKey(childJobKey)\n          local childJobPrefix = getJobKeyPrefix(childJobKey, childJobId)\n          local result = isLocked( childJobPrefix, childJobId, removeChildren )\n          if result then\n            return true\n          end\n        end\n      end\n    end\n    return false\n  end\n  return true\nend\nlocal removeJobChildren\nlocal removeJobWithChildren\nremoveJobChildren = function(prefix, jobKey, options)\n    -- Check if this job has children\n    -- If so, we are going to try to remove the children recursively in a depth-first way\n    -- because if some job is locked, we must exit with an error.\n    if not options.ignoreProcessed then\n        local processed = rcall("HGETALL", jobKey .. ":processed")\n        if #processed > 0 then\n            for i = 1, #processed, 2 do\n                local childJobId = getJobIdFromKey(processed[i])\n                local childJobPrefix = getJobKeyPrefix(processed[i], childJobId)\n                removeJobWithChildren(childJobPrefix, childJobId, jobKey, options)\n            end\n        end\n        local failed = rcall("HGETALL", jobKey .. ":failed")\n        if #failed > 0 then\n            for i = 1, #failed, 2 do\n                local childJobId = getJobIdFromKey(failed[i])\n                local childJobPrefix = getJobKeyPrefix(failed[i], childJobId)\n                removeJobWithChildren(childJobPrefix, childJobId, jobKey, options)\n            end\n        end\n        local unsuccessful = rcall("ZRANGE", jobKey .. ":unsuccessful", 0, -1)\n        if #unsuccessful > 0 then\n            for i = 1, #unsuccessful, 1 do\n                local childJobId = getJobIdFromKey(unsuccessful[i])\n                local childJobPrefix = getJobKeyPrefix(unsuccessful[i], childJobId)\n                removeJobWithChildren(childJobPrefix, childJobId, jobKey, options)\n            end\n        end\n    end\n    local dependencies = rcall("SMEMBERS", jobKey .. ":dependencies")\n    if #dependencies > 0 then\n        for i, childJobKey in ipairs(dependencies) do\n            local childJobId = getJobIdFromKey(childJobKey)\n            local childJobPrefix = getJobKeyPrefix(childJobKey, childJobId)\n            removeJobWithChildren(childJobPrefix, childJobId, jobKey, options)\n        end\n    end\nend\nremoveJobWithChildren = function(prefix, jobId, parentKey, options)\n    local jobKey = prefix .. jobId\n    if options.ignoreLocked then\n        if isLocked(prefix, jobId) then\n            return\n        end\n    end\n    -- Check if job is in the failed zset\n    local failedSet = prefix .. "failed"\n    if not (options.ignoreProcessed and rcall("ZSCORE", failedSet, jobId)) then\n        removeParentDependencyKey(jobKey, false, parentKey, nil)\n        if options.removeChildren then\n            removeJobChildren(prefix, jobKey, options)\n        end\n        local prev = removeJobFromAnyState(prefix, jobId)\n        removeDeduplicationKeyIfNeededOnRemoval(prefix, jobKey, jobId)\n        if removeJobKeys(jobKey) > 0 then\n            local metaKey = prefix .. "meta"\n            local maxEvents = getOrSetMaxEvents(metaKey)\n            rcall("XADD", prefix .. "events", "MAXLEN", "~", maxEvents, "*", "event", "removed",\n                "jobId", jobId, "prev", prev)\n        end\n    end\nend\nlocal prefix = ARGV[1]\nlocal jobId = ARGV[2]\nlocal jobKey = KEYS[1]\nlocal metaKey = KEYS[2]\nlocal options = {\n  removeChildren = "1",\n  ignoreProcessed = true,\n  ignoreLocked = true\n}\nremoveJobChildren(prefix, jobKey, options) \n',keys:2}},(e,t,n)=>{"use strict";n.r(t),n.d(t,{reprocessJob:()=>r});const r={name:"reprocessJob",content:'--[[\n  Attempts to reprocess a job\n  Input:\n    KEYS[1] job key\n    KEYS[2] events stream\n    KEYS[3] job state\n    KEYS[4] wait key\n    KEYS[5] meta\n    KEYS[6] paused key\n    KEYS[7] active key\n    KEYS[8] marker key\n    ARGV[1] job.id\n    ARGV[2] (job.opts.lifo ? \'R\' : \'L\') + \'PUSH\'\n    ARGV[3] propVal - failedReason/returnvalue\n    ARGV[4] prev state - failed/completed\n  Output:\n     1 means the operation was a success\n    -1 means the job does not exist\n    -3 means the job was not found in the expected set.\n]]\nlocal rcall = redis.call;\n-- Includes\n--[[\n  Function to add job in target list and add marker if needed.\n]]\n-- Includes\n--[[\n  Add marker if needed when a job is available.\n]]\nlocal function addBaseMarkerIfNeeded(markerKey, isPausedOrMaxed)\n  if not isPausedOrMaxed then\n    rcall("ZADD", markerKey, 0, "0")\n  end  \nend\nlocal function addJobInTargetList(targetKey, markerKey, pushCmd, isPausedOrMaxed, jobId)\n  rcall(pushCmd, targetKey, jobId)\n  addBaseMarkerIfNeeded(markerKey, isPausedOrMaxed)\nend\n--[[\n  Function to get max events value or set by default 10000.\n]]\nlocal function getOrSetMaxEvents(metaKey)\n  local maxEvents = rcall("HGET", metaKey, "opts.maxLenEvents")\n  if not maxEvents then\n    maxEvents = 10000\n    rcall("HSET", metaKey, "opts.maxLenEvents", maxEvents)\n  end\n  return maxEvents\nend\n--[[\n  Function to check for the meta.paused key to decide if we are paused or not\n  (since an empty list and !EXISTS are not really the same).\n]]\nlocal function getTargetQueueList(queueMetaKey, activeKey, waitKey, pausedKey)\n  local queueAttributes = rcall("HMGET", queueMetaKey, "paused", "concurrency")\n  if queueAttributes[1] then\n    return pausedKey, true\n  else\n    if queueAttributes[2] then\n      local activeCount = rcall("LLEN", activeKey)\n      if activeCount >= tonumber(queueAttributes[2]) then\n        return waitKey, true\n      else\n        return waitKey, false\n      end\n    end\n  end\n  return waitKey, false\nend\nif rcall("EXISTS", KEYS[1]) == 1 then\n  local jobId = ARGV[1]\n  if (rcall("ZREM", KEYS[3], jobId) == 1) then\n    rcall("HDEL", KEYS[1], "finishedOn", "processedOn", ARGV[3])\n    local target, isPausedOrMaxed = getTargetQueueList(KEYS[5], KEYS[7], KEYS[4], KEYS[6])\n    addJobInTargetList(target, KEYS[8], ARGV[2], isPausedOrMaxed, jobId)\n    local maxEvents = getOrSetMaxEvents(KEYS[5])\n    -- Emit waiting event\n    rcall("XADD", KEYS[2], "MAXLEN", "~", maxEvents, "*", "event", "waiting",\n      "jobId", jobId, "prev", ARGV[4]);\n    return 1\n  else\n    return -3\n  end\nelse\n  return -1\nend\n',keys:8}},(e,t,n)=>{"use strict";n.r(t),n.d(t,{retryJob:()=>r});const r={name:"retryJob",content:'--[[\n  Retries a failed job by moving it back to the wait queue.\n    Input:\n      KEYS[1]  \'active\',\n      KEYS[2]  \'wait\'\n      KEYS[3]  \'paused\'\n      KEYS[4]  job key\n      KEYS[5]  \'meta\'\n      KEYS[6]  events stream\n      KEYS[7]  delayed key\n      KEYS[8]  prioritized key\n      KEYS[9]  \'pc\' priority counter\n      KEYS[10] \'marker\'\n      KEYS[11] \'stalled\'\n      ARGV[1]  key prefix\n      ARGV[2]  timestamp\n      ARGV[3]  pushCmd\n      ARGV[4]  jobId\n      ARGV[5]  token\n      ARGV[6]  optional job fields to update\n    Events:\n      \'waiting\'\n    Output:\n     0  - OK\n     -1 - Missing key\n     -2 - Missing lock\n     -3 - Job not in active set\n]]\nlocal rcall = redis.call\n-- Includes\n--[[\n  Function to add job in target list and add marker if needed.\n]]\n-- Includes\n--[[\n  Add marker if needed when a job is available.\n]]\nlocal function addBaseMarkerIfNeeded(markerKey, isPausedOrMaxed)\n  if not isPausedOrMaxed then\n    rcall("ZADD", markerKey, 0, "0")\n  end  \nend\nlocal function addJobInTargetList(targetKey, markerKey, pushCmd, isPausedOrMaxed, jobId)\n  rcall(pushCmd, targetKey, jobId)\n  addBaseMarkerIfNeeded(markerKey, isPausedOrMaxed)\nend\n--[[\n  Function to add job considering priority.\n]]\n-- Includes\n--[[\n  Function to get priority score.\n]]\nlocal function getPriorityScore(priority, priorityCounterKey)\n  local prioCounter = rcall("INCR", priorityCounterKey)\n  return priority * 0x100000000 + prioCounter % 0x100000000\nend\nlocal function addJobWithPriority(markerKey, prioritizedKey, priority, jobId, priorityCounterKey,\n  isPausedOrMaxed)\n  local score = getPriorityScore(priority, priorityCounterKey)\n  rcall("ZADD", prioritizedKey, score, jobId)\n  addBaseMarkerIfNeeded(markerKey, isPausedOrMaxed)\nend\n--[[\n  Function to get max events value or set by default 10000.\n]]\nlocal function getOrSetMaxEvents(metaKey)\n  local maxEvents = rcall("HGET", metaKey, "opts.maxLenEvents")\n  if not maxEvents then\n    maxEvents = 10000\n    rcall("HSET", metaKey, "opts.maxLenEvents", maxEvents)\n  end\n  return maxEvents\nend\n--[[\n  Function to check for the meta.paused key to decide if we are paused or not\n  (since an empty list and !EXISTS are not really the same).\n]]\nlocal function getTargetQueueList(queueMetaKey, activeKey, waitKey, pausedKey)\n  local queueAttributes = rcall("HMGET", queueMetaKey, "paused", "concurrency")\n  if queueAttributes[1] then\n    return pausedKey, true\n  else\n    if queueAttributes[2] then\n      local activeCount = rcall("LLEN", activeKey)\n      if activeCount >= tonumber(queueAttributes[2]) then\n        return waitKey, true\n      else\n        return waitKey, false\n      end\n    end\n  end\n  return waitKey, false\nend\n--[[\n  Function to check if queue is paused or maxed\n  (since an empty list and !EXISTS are not really the same).\n]]\nlocal function isQueuePausedOrMaxed(queueMetaKey, activeKey)\n  local queueAttributes = rcall("HMGET", queueMetaKey, "paused", "concurrency")\n  if queueAttributes[1] then\n    return true\n  else\n    if queueAttributes[2] then\n      local activeCount = rcall("LLEN", activeKey)\n      return activeCount >= tonumber(queueAttributes[2])\n    end\n  end\n  return false\nend\n--[[\n  Updates the delay set, by moving delayed jobs that should\n  be processed now to "wait".\n     Events:\n      \'waiting\'\n]]\n-- Includes\n-- Try to get as much as 1000 jobs at once\nlocal function promoteDelayedJobs(delayedKey, markerKey, targetKey, prioritizedKey,\n                                  eventStreamKey, prefix, timestamp, priorityCounterKey, isPaused)\n    local jobs = rcall("ZRANGEBYSCORE", delayedKey, 0, (timestamp + 1) * 0x1000 - 1, "LIMIT", 0, 1000)\n    if (#jobs > 0) then\n        rcall("ZREM", delayedKey, unpack(jobs))\n        for _, jobId in ipairs(jobs) do\n            local jobKey = prefix .. jobId\n            local priority =\n                tonumber(rcall("HGET", jobKey, "priority")) or 0\n            if priority == 0 then\n                -- LIFO or FIFO\n                rcall("LPUSH", targetKey, jobId)\n            else\n                local score = getPriorityScore(priority, priorityCounterKey)\n                rcall("ZADD", prioritizedKey, score, jobId)\n            end\n            -- Emit waiting event\n            rcall("XADD", eventStreamKey, "*", "event", "waiting", "jobId",\n                  jobId, "prev", "delayed")\n            rcall("HSET", jobKey, "delay", 0)\n        end\n        addBaseMarkerIfNeeded(markerKey, isPaused)\n    end\nend\nlocal function removeLock(jobKey, stalledKey, token, jobId)\n  if token ~= "0" then\n    local lockKey = jobKey .. \':lock\'\n    local lockToken = rcall("GET", lockKey)\n    if lockToken == token then\n      rcall("DEL", lockKey)\n      rcall("SREM", stalledKey, jobId)\n    else\n      if lockToken then\n        -- Lock exists but token does not match\n        return -6\n      else\n        -- Lock is missing completely\n        return -2\n      end\n    end\n  end\n  return 0\nend\n--[[\n  Function to update a bunch of fields in a job.\n]]\nlocal function updateJobFields(jobKey, msgpackedFields)\n  if msgpackedFields and #msgpackedFields > 0 then\n    local fieldsToUpdate = cmsgpack.unpack(msgpackedFields)\n    if fieldsToUpdate then\n      rcall("HMSET", jobKey, unpack(fieldsToUpdate))\n    end\n  end\nend\nlocal target, isPausedOrMaxed = getTargetQueueList(KEYS[5], KEYS[1], KEYS[2], KEYS[3])\nlocal markerKey = KEYS[10]\n-- Check if there are delayed jobs that we can move to wait.\n-- test example: when there are delayed jobs between retries\npromoteDelayedJobs(KEYS[7], markerKey, target, KEYS[8], KEYS[6], ARGV[1], ARGV[2], KEYS[9], isPausedOrMaxed)\nlocal jobKey = KEYS[4]\nif rcall("EXISTS", jobKey) == 1 then\n  local errorCode = removeLock(jobKey, KEYS[11], ARGV[5], ARGV[4]) \n  if errorCode < 0 then\n    return errorCode\n  end\n  updateJobFields(jobKey, ARGV[6])\n  local numRemovedElements = rcall("LREM", KEYS[1], -1, ARGV[4])\n  if (numRemovedElements < 1) then return -3 end\n  local priority = tonumber(rcall("HGET", jobKey, "priority")) or 0\n  --need to re-evaluate after removing job from active\n  isPausedOrMaxed = isQueuePausedOrMaxed(KEYS[5], KEYS[1])\n  -- Standard or priority add\n  if priority == 0 then\n    addJobInTargetList(target, markerKey, ARGV[3], isPausedOrMaxed, ARGV[4])\n  else\n    addJobWithPriority(markerKey, KEYS[8], priority, ARGV[4], KEYS[9], isPausedOrMaxed)\n  end\n  rcall("HINCRBY", jobKey, "atm", 1)\n  local maxEvents = getOrSetMaxEvents(KEYS[5])\n  -- Emit waiting event\n  rcall("XADD", KEYS[6], "MAXLEN", "~", maxEvents, "*", "event", "waiting",\n    "jobId", ARGV[4], "prev", "failed")\n  return 0\nelse\n  return -1\nend\n',keys:11}},(e,t,n)=>{"use strict";n.r(t),n.d(t,{saveStacktrace:()=>r});const r={name:"saveStacktrace",content:'--[[\n  Save stacktrace and failedReason.\n  Input:\n    KEYS[1] job key\n    ARGV[1]  stacktrace\n    ARGV[2]  failedReason\n  Output:\n     0 - OK\n    -1 - Missing key\n]]\nlocal rcall = redis.call\nif rcall("EXISTS", KEYS[1]) == 1 then\n  rcall("HMSET", KEYS[1], "stacktrace", ARGV[1], "failedReason", ARGV[2])\n  return 0\nelse\n  return -1\nend\n',keys:1}},(e,t,n)=>{"use strict";n.r(t),n.d(t,{updateData:()=>r});const r={name:"updateData",content:'--[[\n  Update job data\n  Input:\n    KEYS[1] Job id key\n    ARGV[1] data\n  Output:\n    0 - OK\n   -1 - Missing job.\n]]\nlocal rcall = redis.call\nif rcall("EXISTS",KEYS[1]) == 1 then -- // Make sure job exists\n  rcall("HSET", KEYS[1], "data", ARGV[1])\n  return 0\nelse\n  return -1\nend\n',keys:1}},(e,t,n)=>{"use strict";n.r(t),n.d(t,{updateJobScheduler:()=>r});const r={name:"updateJobScheduler",content:'--[[\n  Updates a job scheduler and adds next delayed job\n  Input:\n    KEYS[1]  \'repeat\' key\n    KEYS[2]  \'delayed\'\n    KEYS[3]  \'wait\' key\n    KEYS[4]  \'paused\' key\n    KEYS[5]  \'meta\'\n    KEYS[6]  \'prioritized\' key\n    KEYS[7]  \'marker\',\n    KEYS[8]  \'id\'\n    KEYS[9]  events stream key\n    KEYS[10] \'pc\' priority counter\n    KEYS[11] producer key\n    KEYS[12] \'active\' key\n    ARGV[1] next milliseconds\n    ARGV[2] jobs scheduler id\n    ARGV[3] Json stringified delayed data\n    ARGV[4] msgpacked delayed opts\n    ARGV[5] timestamp\n    ARGV[6] prefix key\n    ARGV[7] producer id\n    Output:\n      next delayed job id  - OK\n]]\nlocal rcall = redis.call\nlocal repeatKey = KEYS[1]\nlocal delayedKey = KEYS[2]\nlocal waitKey = KEYS[3]\nlocal pausedKey = KEYS[4]\nlocal metaKey = KEYS[5]\nlocal prioritizedKey = KEYS[6]\nlocal nextMillis = ARGV[1]\nlocal jobSchedulerId = ARGV[2]\nlocal timestamp = ARGV[5]\nlocal prefixKey = ARGV[6]\nlocal producerId = ARGV[7]\n-- Includes\n--[[\n  Add delay marker if needed.\n]]\n-- Includes\n--[[\n  Adds a delayed job to the queue by doing the following:\n    - Creates a new job key with the job data.\n    - adds to delayed zset.\n    - Emits a global event \'delayed\' if the job is delayed.\n]]\n-- Includes\n--[[\n  Add delay marker if needed.\n]]\n-- Includes\n--[[\n  Function to return the next delayed job timestamp.\n]]\nlocal function getNextDelayedTimestamp(delayedKey)\n  local result = rcall("ZRANGE", delayedKey, 0, 0, "WITHSCORES")\n  if #result then\n    local nextTimestamp = tonumber(result[2])\n    if nextTimestamp ~= nil then\n      return nextTimestamp / 0x1000\n    end\n  end\nend\nlocal function addDelayMarkerIfNeeded(markerKey, delayedKey)\n  local nextTimestamp = getNextDelayedTimestamp(delayedKey)\n  if nextTimestamp ~= nil then\n    -- Replace the score of the marker with the newest known\n    -- next timestamp.\n    rcall("ZADD", markerKey, nextTimestamp, "1")\n  end\nend\n--[[\n  Bake in the job id first 12 bits into the timestamp\n  to guarantee correct execution order of delayed jobs\n  (up to 4096 jobs per given timestamp or 4096 jobs apart per timestamp)\n  WARNING: Jobs that are so far apart that they wrap around will cause FIFO to fail\n]]\nlocal function getDelayedScore(delayedKey, timestamp, delay)\n  local delayedTimestamp = (delay > 0 and (tonumber(timestamp) + delay)) or tonumber(timestamp)\n  local minScore = delayedTimestamp * 0x1000\n  local maxScore = (delayedTimestamp + 1 ) * 0x1000 - 1\n  local result = rcall("ZREVRANGEBYSCORE", delayedKey, maxScore,\n    minScore, "WITHSCORES","LIMIT", 0, 1)\n  if #result then\n    local currentMaxScore = tonumber(result[2])\n    if currentMaxScore ~= nil then\n      if currentMaxScore >= maxScore then\n        return maxScore, delayedTimestamp\n      else\n        return currentMaxScore + 1, delayedTimestamp\n      end\n    end\n  end\n  return minScore, delayedTimestamp\nend\nlocal function addDelayedJob(jobId, delayedKey, eventsKey, timestamp,\n  maxEvents, markerKey, delay)\n  local score, delayedTimestamp = getDelayedScore(delayedKey, timestamp, tonumber(delay))\n  rcall("ZADD", delayedKey, score, jobId)\n  rcall("XADD", eventsKey, "MAXLEN", "~", maxEvents, "*", "event", "delayed",\n    "jobId", jobId, "delay", delayedTimestamp)\n  -- mark that a delayed job is available\n  addDelayMarkerIfNeeded(markerKey, delayedKey)\nend\n--[[\n  Function to add job considering priority.\n]]\n-- Includes\n--[[\n  Add marker if needed when a job is available.\n]]\nlocal function addBaseMarkerIfNeeded(markerKey, isPausedOrMaxed)\n  if not isPausedOrMaxed then\n    rcall("ZADD", markerKey, 0, "0")\n  end  \nend\n--[[\n  Function to get priority score.\n]]\nlocal function getPriorityScore(priority, priorityCounterKey)\n  local prioCounter = rcall("INCR", priorityCounterKey)\n  return priority * 0x100000000 + prioCounter % 0x100000000\nend\nlocal function addJobWithPriority(markerKey, prioritizedKey, priority, jobId, priorityCounterKey,\n  isPausedOrMaxed)\n  local score = getPriorityScore(priority, priorityCounterKey)\n  rcall("ZADD", prioritizedKey, score, jobId)\n  addBaseMarkerIfNeeded(markerKey, isPausedOrMaxed)\nend\n--[[\n  Function to check for the meta.paused key to decide if we are paused or not\n  (since an empty list and !EXISTS are not really the same).\n]]\nlocal function isQueuePaused(queueMetaKey)\n  return rcall("HEXISTS", queueMetaKey, "paused") == 1\nend\n--[[\n  Function to store a job\n]]\nlocal function storeJob(eventsKey, jobIdKey, jobId, name, data, opts, timestamp,\n                        parentKey, parentData, repeatJobKey)\n    local jsonOpts = cjson.encode(opts)\n    local delay = opts[\'delay\'] or 0\n    local priority = opts[\'priority\'] or 0\n    local debounceId = opts[\'de\'] and opts[\'de\'][\'id\']\n    local optionalValues = {}\n    if parentKey ~= nil then\n        table.insert(optionalValues, "parentKey")\n        table.insert(optionalValues, parentKey)\n        table.insert(optionalValues, "parent")\n        table.insert(optionalValues, parentData)\n    end\n    if repeatJobKey then\n        table.insert(optionalValues, "rjk")\n        table.insert(optionalValues, repeatJobKey)\n    end\n    if debounceId then\n        table.insert(optionalValues, "deid")\n        table.insert(optionalValues, debounceId)\n    end\n    rcall("HMSET", jobIdKey, "name", name, "data", data, "opts", jsonOpts,\n          "timestamp", timestamp, "delay", delay, "priority", priority,\n          unpack(optionalValues))\n    rcall("XADD", eventsKey, "*", "event", "added", "jobId", jobId, "name", name)\n    return delay, priority\nend\n--[[\n  Function to check for the meta.paused key to decide if we are paused or not\n  (since an empty list and !EXISTS are not really the same).\n]]\nlocal function getTargetQueueList(queueMetaKey, activeKey, waitKey, pausedKey)\n  local queueAttributes = rcall("HMGET", queueMetaKey, "paused", "concurrency")\n  if queueAttributes[1] then\n    return pausedKey, true\n  else\n    if queueAttributes[2] then\n      local activeCount = rcall("LLEN", activeKey)\n      if activeCount >= tonumber(queueAttributes[2]) then\n        return waitKey, true\n      else\n        return waitKey, false\n      end\n    end\n  end\n  return waitKey, false\nend\n--[[\n  Function to add job in target list and add marker if needed.\n]]\n-- Includes\nlocal function addJobInTargetList(targetKey, markerKey, pushCmd, isPausedOrMaxed, jobId)\n  rcall(pushCmd, targetKey, jobId)\n  addBaseMarkerIfNeeded(markerKey, isPausedOrMaxed)\nend\nlocal function addJobFromScheduler(jobKey, jobId, rawOpts, waitKey, pausedKey, activeKey, metaKey, \n  prioritizedKey, priorityCounter, delayedKey, markerKey, eventsKey, name, maxEvents, timestamp,\n  data, jobSchedulerId)\n  local opts = cmsgpack.unpack(rawOpts)\n  local delay, priority = storeJob(eventsKey, jobKey, jobId, name, data,\n    opts, timestamp, nil, nil, jobSchedulerId)\n  if delay ~= 0 then\n    addDelayedJob(jobId, delayedKey, eventsKey, timestamp, maxEvents, markerKey, delay)\n  else\n    local target, isPausedOrMaxed = getTargetQueueList(metaKey, activeKey, waitKey, pausedKey)\n    -- Standard or priority add\n    if priority == 0 then\n      local pushCmd = opts[\'lifo\'] and \'RPUSH\' or \'LPUSH\'\n      addJobInTargetList(target, markerKey, pushCmd, isPausedOrMaxed, jobId)\n    else\n      -- Priority add\n      addJobWithPriority(markerKey, prioritizedKey, priority, jobId, priorityCounter, isPausedOrMaxed)\n    end\n    -- Emit waiting event\n    rcall("XADD", eventsKey, "MAXLEN", "~", maxEvents,  "*", "event", "waiting", "jobId", jobId)\n  end\nend\n--[[\n  Function to get max events value or set by default 10000.\n]]\nlocal function getOrSetMaxEvents(metaKey)\n  local maxEvents = rcall("HGET", metaKey, "opts.maxLenEvents")\n  if not maxEvents then\n    maxEvents = 10000\n    rcall("HSET", metaKey, "opts.maxLenEvents", maxEvents)\n  end\n  return maxEvents\nend\nlocal schedulerKey = repeatKey .. ":" .. jobSchedulerId\nlocal nextDelayedJobId = "repeat:" .. jobSchedulerId .. ":" .. nextMillis\nlocal nextDelayedJobKey = schedulerKey .. ":" .. nextMillis\n-- Validate that scheduler exists.\nlocal prevMillis = rcall("ZSCORE", repeatKey, jobSchedulerId)\nif prevMillis then\n    local currentDelayedJobId = "repeat:" .. jobSchedulerId .. ":" .. prevMillis\n    if producerId == currentDelayedJobId then\n        local eventsKey = KEYS[9]\n        local maxEvents = getOrSetMaxEvents(metaKey)\n        if rcall("EXISTS", nextDelayedJobKey) ~= 1 then\n            local schedulerAttributes = rcall("HMGET", schedulerKey, "name", "data")\n            rcall("ZADD", repeatKey, nextMillis, jobSchedulerId)\n            rcall("HINCRBY", schedulerKey, "ic", 1)\n            rcall("INCR", KEYS[8])\n            -- TODO: remove this workaround in next breaking change,\n            -- all job-schedulers must save job data\n            local templateData = schedulerAttributes[2] or ARGV[3]\n            if templateData and templateData ~= \'{}\' then\n                rcall("HSET", schedulerKey, "data", templateData)\n            end\n            addJobFromScheduler(nextDelayedJobKey, nextDelayedJobId, ARGV[4], waitKey, pausedKey, \n                KEYS[12], metaKey, prioritizedKey, KEYS[10], delayedKey, KEYS[7], eventsKey, \n                schedulerAttributes[1], maxEvents, ARGV[5], templateData or \'{}\', jobSchedulerId)\n            -- TODO: remove this workaround in next breaking change\n            if KEYS[11] ~= "" then\n                rcall("HSET", KEYS[11], "nrjid", nextDelayedJobId)\n            end\n            return nextDelayedJobId .. "" -- convert to string\n        else\n            rcall("XADD", eventsKey, "MAXLEN", "~", maxEvents, "*", "event",\n                "duplicated", "jobId", nextDelayedJobId)\n        end\n    end\nend\n',keys:12}},(e,t,n)=>{"use strict";n.r(t),n.d(t,{updateProgress:()=>r});const r={name:"updateProgress",content:'--[[\n  Update job progress\n  Input:\n    KEYS[1] Job id key\n    KEYS[2] event stream key\n    KEYS[3] meta key\n    ARGV[1] id\n    ARGV[2] progress\n  Output:\n     0 - OK\n    -1 - Missing job.\n  Event:\n    progress(jobId, progress)\n]]\nlocal rcall = redis.call\n-- Includes\n--[[\n  Function to get max events value or set by default 10000.\n]]\nlocal function getOrSetMaxEvents(metaKey)\n  local maxEvents = rcall("HGET", metaKey, "opts.maxLenEvents")\n  if not maxEvents then\n    maxEvents = 10000\n    rcall("HSET", metaKey, "opts.maxLenEvents", maxEvents)\n  end\n  return maxEvents\nend\nif rcall("EXISTS", KEYS[1]) == 1 then -- // Make sure job exists\n    local maxEvents = getOrSetMaxEvents(KEYS[3])\n    rcall("HSET", KEYS[1], "progress", ARGV[2])\n    rcall("XADD", KEYS[2], "MAXLEN", "~", maxEvents, "*", "event", "progress",\n          "jobId", ARGV[1], "data", ARGV[2]);\n    return 0\nelse\n    return -1\nend\n',keys:3}},(e,t,n)=>{"use strict";n.r(t),n.d(t,{updateRepeatableJobMillis:()=>r});const r={name:"updateRepeatableJobMillis",content:'--[[\n  Adds a repeatable job\n    Input:\n      KEYS[1] \'repeat\' key\n      ARGV[1] next milliseconds\n      ARGV[2] custom key\n      ARGV[3] legacy custom key TODO: remove this logic in next breaking change\n      Output:\n        repeatableKey  - OK\n]]\nlocal rcall = redis.call\nlocal repeatKey = KEYS[1]\nlocal nextMillis = ARGV[1]\nlocal customKey = ARGV[2]\nlocal legacyCustomKey = ARGV[3]\nif rcall("ZSCORE", repeatKey, customKey) then\n    rcall("ZADD", repeatKey, nextMillis, customKey)\n    return customKey\nelseif rcall("ZSCORE", repeatKey, legacyCustomKey) ~= false then\n    rcall("ZADD", repeatKey, nextMillis, legacyCustomKey)\n    return legacyCustomKey\nend\nreturn \'\'\n',keys:1}},(e,t,n)=>{"use strict";n.r(t),n.d(t,{default:()=>s});var r=n(201),i=n(202),a=n(203);const s=function(e,t,n){if(r.default.randomUUID&&!t&&!e)return r.default.randomUUID();const s=(e=e||{}).random||(e.rng||i.default)();if(s[6]=15&s[6]|64,s[8]=63&s[8]|128,t){n=n||0;for(let e=0;e<16;++e)t[n+e]=s[e];return t}return(0,a.unsafeStringify)(s)}},(e,t,n)=>{"use strict";n.r(t),n.d(t,{default:()=>r});const r={randomUUID:"undefined"!=typeof crypto&&crypto.randomUUID&&crypto.randomUUID.bind(crypto)}},(e,t,n)=>{"use strict";let r;n.r(t),n.d(t,{default:()=>a});const i=new Uint8Array(16);function a(){if(!r&&(r="undefined"!=typeof crypto&&crypto.getRandomValues&&crypto.getRandomValues.bind(crypto),!r))throw new Error("crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported");return r(i)}},(e,t,n)=>{"use strict";n.r(t),n.d(t,{default:()=>s,unsafeStringify:()=>a});var r=n(204);const i=[];for(let e=0;e<256;++e)i.push((e+256).toString(16).slice(1));function a(e,t=0){return i[e[t+0]]+i[e[t+1]]+i[e[t+2]]+i[e[t+3]]+"-"+i[e[t+4]]+i[e[t+5]]+"-"+i[e[t+6]]+i[e[t+7]]+"-"+i[e[t+8]]+i[e[t+9]]+"-"+i[e[t+10]]+i[e[t+11]]+i[e[t+12]]+i[e[t+13]]+i[e[t+14]]+i[e[t+15]]}const s=function(e,t=0){const n=a(e,t);if(!(0,r.default)(n))throw TypeError("Stringified UUID is invalid");return n}},(e,t,n)=>{"use strict";n.r(t),n.d(t,{default:()=>i});var r=n(205);const i=function(e){return"string"==typeof e&&r.default.test(e)}},(e,t,n)=>{"use strict";n.r(t),n.d(t,{default:()=>r});const r=/^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i},(e,t,n)=>{"use strict";n.r(t),n.d(t,{JobScheduler:()=>d,defaultRepeatStrategy:()=>c});var r=n(148),i=n(207),a=n(147),s=n(216),o=n(8),l=n(18);class d extends s.QueueBase{constructor(e,t,n){super(e,t,n),this.repeatStrategy=t.settings&&t.settings.repeatStrategy||c}async upsertJobScheduler(e,t,n,i,s,{override:l,producerId:d}){const{every:c,limit:u,pattern:p,offset:h}=t;if(p&&c)throw new Error("Both .pattern and .every options are defined for this repeatable job");if(!p&&!c)throw new Error("Either .pattern or .every options must be defined for this repeatable job");if(t.immediately&&t.startDate)throw new Error("Both .immediately and .startDate options are defined for this repeatable job");t.immediately&&t.every&&console.warn("Using option immediately with every does not affect the job's schedule. Job will run immediately anyway.");const y=t.count?t.count+1:1;if(void 0!==t.limit&&y>t.limit)return;let m=Date.now();const{endDate:f}=t;if(f&&m>new Date(f).getTime())return;const b=s.prevMillis||0;m=b<m?m:b;const{startDate:g,immediately:v}=t,K=(0,r.__rest)(t,["startDate","immediately"]);let E,S=m;g&&(S=new Date(g).getTime(),S=S>m?S:m);let I=null;if(c){const e=Math.floor((S-(h||0))/c)*c;I="number"==typeof h?h:S-e;E=b||h?e+c:e}else p&&(E=await this.repeatStrategy(m,t,n),E<m&&(E=m));return E?this.trace(o.SpanKind.PRODUCER,"add",`${this.name}.${n}`,async(r,h)=>{var m,b;let g=s.telemetry;if(h){const e=null===(m=s.telemetry)||void 0===m?void 0:m.omitContext,t=(null===(b=s.telemetry)||void 0===b?void 0:b.metadata)||!e&&h;(t||e)&&(g={metadata:t,omitContext:e})}const v=this.getNextJobOpts(E,e,Object.assign(Object.assign({},s),{repeat:K,telemetry:g}),y,I);if(l){const l=await this.scripts.addJobScheduler(e,E,JSON.stringify(void 0===i?{}:i),a.Job.optsAsJSON(s),{name:n,endDate:f?new Date(f).getTime():void 0,tz:t.tz,pattern:p,every:c,limit:u,offset:I},a.Job.optsAsJSON(v),d),h=new this.Job(this,n,i,v,l);return h.id=l,null==r||r.setAttributes({[o.TelemetryAttributes.JobSchedulerId]:e,[o.TelemetryAttributes.JobId]:h.id}),h}{const t=await this.scripts.updateJobSchedulerNextMillis(e,E,JSON.stringify(void 0===i?{}:i),a.Job.optsAsJSON(v),d);if(t){const a=new this.Job(this,n,i,v,t);return a.id=t,null==r||r.setAttributes({[o.TelemetryAttributes.JobSchedulerId]:e,[o.TelemetryAttributes.JobId]:a.id}),a}}}):void 0}getNextJobOpts(e,t,n,r,i){var a;const s=this.getSchedulerNextJobId({jobSchedulerId:t,nextMillis:e}),o=Date.now(),l=e+i-o,d=Object.assign(Object.assign({},n),{jobId:s,delay:l<0?0:l,timestamp:o,prevMillis:e,repeatJobKey:t});return d.repeat=Object.assign(Object.assign({},n.repeat),{offset:i,count:r,endDate:(null===(a=n.repeat)||void 0===a?void 0:a.endDate)?new Date(n.repeat.endDate).getTime():void 0}),d}async removeJobScheduler(e){return this.scripts.removeJobScheduler(e)}async getSchedulerData(e,t,n){const r=await e.hgetall(this.toKey("repeat:"+t));return this.transformSchedulerData(t,r,n)}transformSchedulerData(e,t,n){if(t){const r={key:e,name:t.name,next:n};return t.ic&&(r.iterationCount=parseInt(t.ic)),t.limit&&(r.limit=parseInt(t.limit)),t.endDate&&(r.endDate=parseInt(t.endDate)),t.tz&&(r.tz=t.tz),t.pattern&&(r.pattern=t.pattern),t.every&&(r.every=parseInt(t.every)),t.offset&&(r.offset=parseInt(t.offset)),(t.data||t.opts)&&(r.template=this.getTemplateFromJSON(t.data,t.opts)),r}if(e.includes(":"))return this.keyToData(e,n)}keyToData(e,t){const n=e.split(":"),r=n.slice(4).join(":")||null;return{key:e,name:n[0],id:n[1]||null,endDate:parseInt(n[2])||null,tz:n[3]||null,pattern:r,next:t}}async getScheduler(e){const[t,n]=await this.scripts.getJobScheduler(e);return this.transformSchedulerData(e,t?(0,l.array2obj)(t):null,n?parseInt(n):null)}getTemplateFromJSON(e,t){const n={};return e&&(n.data=JSON.parse(e)),t&&(n.opts=a.Job.optsFromJSON(t)),n}async getJobSchedulers(e=0,t=-1,n=!1){const r=await this.client,i=this.keys.repeat,a=n?await r.zrange(i,e,t,"WITHSCORES"):await r.zrevrange(i,e,t,"WITHSCORES"),s=[];for(let e=0;e<a.length;e+=2)s.push(this.getSchedulerData(r,a[e],parseInt(a[e+1])));return Promise.all(s)}async getSchedulersCount(){const e=this.keys.repeat;return(await this.client).zcard(e)}getSchedulerNextJobId({nextMillis:e,jobSchedulerId:t}){return`repeat:${t}:${e}`}}const c=(e,t)=>{const{pattern:n}=t,r=new Date(e),a=(0,i.parseExpression)(n,Object.assign(Object.assign({},t),{currentDate:r}));try{return t.immediately?(new Date).getTime():a.next().getTime()}catch(e){}}},(e,t,n)=>{"use strict";var r=n(208);function i(){}i._parseEntry=function(e){var t=e.split(" ");if(6===t.length)return{interval:r.parse(e)};if(t.length>6)return{interval:r.parse(t.slice(0,6).join(" ")),command:t.slice(6,t.length)};throw new Error("Invalid entry: "+e)},i.parseExpression=function(e,t){return r.parse(e,t)},i.fieldsToExpression=function(e,t){return r.fieldsToExpression(e,t)},i.parseString=function(e){for(var t=e.split("\n"),n={variables:{},expressions:[],errors:{}},r=0,a=t.length;r<a;r++){var s=null,o=t[r].trim();if(o.length>0){if(o.match(/^#/))continue;if(s=o.match(/^(.*)=(.*)$/))n.variables[s[1]]=s[2];else{var l=null;try{l=i._parseEntry("0 "+o),n.expressions.push(l.interval)}catch(e){n.errors[o]=e}}}}return n},i.parseFile=function(e,t){n(215).readFile(e,function(e,n){if(!e)return t(null,i.parseString(n.toString()));t(e)})},e.exports=i},(e,t,n)=>{"use strict";var r=n(209),i=n(213);function a(e,t){this._options=t,this._utc=t.utc||!1,this._tz=this._utc?"UTC":t.tz,this._currentDate=new r(t.currentDate,this._tz),this._startDate=t.startDate?new r(t.startDate,this._tz):null,this._endDate=t.endDate?new r(t.endDate,this._tz):null,this._isIterator=t.iterator||!1,this._hasIterated=!1,this._nthDayOfWeek=t.nthDayOfWeek||0,this.fields=a._freezeFields(e)}a.map=["second","minute","hour","dayOfMonth","month","dayOfWeek"],a.predefined={"@yearly":"0 0 1 1 *","@monthly":"0 0 1 * *","@weekly":"0 0 * * 0","@daily":"0 0 * * *","@hourly":"0 * * * *"},a.constraints=[{min:0,max:59,chars:[]},{min:0,max:59,chars:[]},{min:0,max:23,chars:[]},{min:1,max:31,chars:["L"]},{min:1,max:12,chars:[]},{min:0,max:7,chars:["L"]}],a.daysInMonth=[31,29,31,30,31,30,31,31,30,31,30,31],a.aliases={month:{jan:1,feb:2,mar:3,apr:4,may:5,jun:6,jul:7,aug:8,sep:9,oct:10,nov:11,dec:12},dayOfWeek:{sun:0,mon:1,tue:2,wed:3,thu:4,fri:5,sat:6}},a.parseDefaults=["0","*","*","*","*","*"],a.standardValidCharacters=/^[,*\d/-]+$/,a.dayOfWeekValidCharacters=/^[?,*\dL#/-]+$/,a.dayOfMonthValidCharacters=/^[?,*\dL/-]+$/,a.validCharacters={second:a.standardValidCharacters,minute:a.standardValidCharacters,hour:a.standardValidCharacters,dayOfMonth:a.dayOfMonthValidCharacters,month:a.standardValidCharacters,dayOfWeek:a.dayOfWeekValidCharacters},a._isValidConstraintChar=function(e,t){return"string"==typeof t&&e.chars.some(function(e){return t.indexOf(e)>-1})},a._parseField=function(e,t,n){switch(e){case"month":case"dayOfWeek":var r=a.aliases[e];t=t.replace(/[a-z]{3}/gi,function(e){if(e=e.toLowerCase(),void 0!==r[e])return r[e];throw new Error('Validation error, cannot resolve alias "'+e+'"')})}if(!a.validCharacters[e].test(t))throw new Error("Invalid characters, got value: "+t);function i(e){var t=e.split("/");if(t.length>2)throw new Error("Invalid repeat: "+e);return t.length>1?(t[0]==+t[0]&&(t=[t[0]+"-"+n.max,t[1]]),s(t[0],t[t.length-1])):s(e,1)}function s(t,r){var i=[],a=t.split("-");if(a.length>1){if(a.length<2)return+t;if(!a[0].length){if(!a[1].length)throw new Error("Invalid range: "+t);return+t}var s=+a[0],o=+a[1];if(Number.isNaN(s)||Number.isNaN(o)||s<n.min||o>n.max)throw new Error("Constraint error, got range "+s+"-"+o+" expected range "+n.min+"-"+n.max);if(s>o)throw new Error("Invalid range: "+t);var l=+r;if(Number.isNaN(l)||l<=0)throw new Error("Constraint error, cannot repeat at every "+l+" time.");"dayOfWeek"===e&&o%7==0&&i.push(0);for(var d=s,c=o;d<=c;d++){!(-1!==i.indexOf(d))&&l>0&&l%r===0?(l=1,i.push(d)):l++}return i}return Number.isNaN(+t)?t:+t}return-1!==t.indexOf("*")?t=t.replace(/\*/g,n.min+"-"+n.max):-1!==t.indexOf("?")&&(t=t.replace(/\?/g,n.min+"-"+n.max)),function(t){var r=[];function s(t){if(t instanceof Array)for(var i=0,s=t.length;i<s;i++){var o=t[i];if(a._isValidConstraintChar(n,o))r.push(o);else{if("number"!=typeof o||Number.isNaN(o)||o<n.min||o>n.max)throw new Error("Constraint error, got value "+o+" expected range "+n.min+"-"+n.max);r.push(o)}}else{if(a._isValidConstraintChar(n,t))return void r.push(t);var l=+t;if(Number.isNaN(l)||l<n.min||l>n.max)throw new Error("Constraint error, got value "+t+" expected range "+n.min+"-"+n.max);"dayOfWeek"===e&&(l%=7),r.push(l)}}var o=t.split(",");if(!o.every(function(e){return e.length>0}))throw new Error("Invalid list value format");if(o.length>1)for(var l=0,d=o.length;l<d;l++)s(i(o[l]));else s(i(t));return r.sort(a._sortCompareFn),r}(t)},a._sortCompareFn=function(e,t){var n="number"==typeof e,r="number"==typeof t;return n&&r?e-t:!n&&r?1:n&&!r?-1:e.localeCompare(t)},a._handleMaxDaysInMonth=function(e){if(1===e.month.length){var t=a.daysInMonth[e.month[0]-1];if(e.dayOfMonth[0]>t)throw new Error("Invalid explicit day of month definition");return e.dayOfMonth.filter(function(e){return"L"===e||e<=t}).sort(a._sortCompareFn)}},a._freezeFields=function(e){for(var t=0,n=a.map.length;t<n;++t){var r=a.map[t],i=e[r];e[r]=Object.freeze(i)}return Object.freeze(e)},a.prototype._applyTimezoneShift=function(e,t,n){if("Month"===n||"Day"===n){var r=e.getTime();e[t+n](),r===e.getTime()&&(0===e.getMinutes()&&0===e.getSeconds()?e.addHour():59===e.getMinutes()&&59===e.getSeconds()&&e.subtractHour())}else{var i=e.getHours();e[t+n]();var a=e.getHours(),s=a-i;2===s?24!==this.fields.hour.length&&(this._dstStart=a):0===s&&0===e.getMinutes()&&0===e.getSeconds()&&24!==this.fields.hour.length&&(this._dstEnd=a)}},a.prototype._findSchedule=function(e){function t(e,t){for(var n=0,r=t.length;n<r;n++)if(t[n]>=e)return t[n]===e;return t[0]===e}function n(e,t){if(t<6){if(e.getDate()<8&&1===t)return!0;var n=e.getDate()%7?1:0,r=e.getDate()-e.getDate()%7;return Math.floor(r/7)+n===t}return!1}function i(e){return e.length>0&&e.some(function(e){return"string"==typeof e&&e.indexOf("L")>=0})}var s=(e=e||!1)?"subtract":"add",o=new r(this._currentDate,this._tz),l=this._startDate,d=this._endDate,c=o.getTime(),u=0;function p(e){return e.some(function(e){if(!i([e]))return!1;var t=Number.parseInt(e[0])%7;if(Number.isNaN(t))throw new Error("Invalid last weekday of the month expression: "+e);return o.getDay()===t&&o.isLastWeekdayOfMonth()})}for(;u<1e4;){if(u++,e){if(l&&o.getTime()-l.getTime()<0)throw new Error("Out of the timespan range")}else if(d&&d.getTime()-o.getTime()<0)throw new Error("Out of the timespan range");var h=t(o.getDate(),this.fields.dayOfMonth);i(this.fields.dayOfMonth)&&(h=h||o.isLastDayOfMonth());var y=t(o.getDay(),this.fields.dayOfWeek);i(this.fields.dayOfWeek)&&(y=y||p(this.fields.dayOfWeek));var m=this.fields.dayOfMonth.length>=a.daysInMonth[o.getMonth()],f=this.fields.dayOfWeek.length===a.constraints[5].max-a.constraints[5].min+1,b=o.getHours();if(h||y&&!f)if(m||!f||h)if(!m||f||y)if(this._nthDayOfWeek>0&&!n(o,this._nthDayOfWeek))this._applyTimezoneShift(o,s,"Day");else if(t(o.getMonth()+1,this.fields.month)){if(t(b,this.fields.hour)){if(this._dstEnd===b&&!e){this._dstEnd=null,this._applyTimezoneShift(o,"add","Hour");continue}}else{if(this._dstStart!==b){this._dstStart=null,this._applyTimezoneShift(o,s,"Hour");continue}if(!t(b-1,this.fields.hour)){o[s+"Hour"]();continue}}if(t(o.getMinutes(),this.fields.minute))if(t(o.getSeconds(),this.fields.second)){if(c!==o.getTime())break;"add"===s||0===o.getMilliseconds()?this._applyTimezoneShift(o,s,"Second"):o.setMilliseconds(0)}else this._applyTimezoneShift(o,s,"Second");else this._applyTimezoneShift(o,s,"Minute")}else this._applyTimezoneShift(o,s,"Month");else this._applyTimezoneShift(o,s,"Day");else this._applyTimezoneShift(o,s,"Day");else this._applyTimezoneShift(o,s,"Day")}if(u>=1e4)throw new Error("Invalid expression, loop limit exceeded");return this._currentDate=new r(o,this._tz),this._hasIterated=!0,o},a.prototype.next=function(){var e=this._findSchedule();return this._isIterator?{value:e,done:!this.hasNext()}:e},a.prototype.prev=function(){var e=this._findSchedule(!0);return this._isIterator?{value:e,done:!this.hasPrev()}:e},a.prototype.hasNext=function(){var e=this._currentDate,t=this._hasIterated;try{return this._findSchedule(),!0}catch(e){return!1}finally{this._currentDate=e,this._hasIterated=t}},a.prototype.hasPrev=function(){var e=this._currentDate,t=this._hasIterated;try{return this._findSchedule(!0),!0}catch(e){return!1}finally{this._currentDate=e,this._hasIterated=t}},a.prototype.iterate=function(e,t){var n=[];if(e>=0)for(var r=0,i=e;r<i;r++)try{var a=this.next();n.push(a),t&&t(a,r)}catch(e){break}else for(r=0,i=e;r>i;r--)try{a=this.prev();n.push(a),t&&t(a,r)}catch(e){break}return n},a.prototype.reset=function(e){this._currentDate=new r(e||this._options.currentDate)},a.prototype.stringify=function(e){for(var t=[],n=e?0:1,r=a.map.length;n<r;++n){var s=a.map[n],o=this.fields[s],l=a.constraints[n];"dayOfMonth"===s&&1===this.fields.month.length?l={min:1,max:a.daysInMonth[this.fields.month[0]-1]}:"dayOfWeek"===s&&(l={min:0,max:6},o=7===o[o.length-1]?o.slice(0,-1):o),t.push(i(o,l.min,l.max))}return t.join(" ")},a.parse=function(e,t){var n=this;function i(e,t){t||(t={}),void 0===t.currentDate&&(t.currentDate=new r(void 0,n._tz)),a.predefined[e]&&(e=a.predefined[e]);var i=[],s=(e+"").trim().split(/\s+/);if(s.length>6)throw new Error("Invalid cron expression");for(var o=a.map.length-s.length,l=0,d=a.map.length;l<d;++l){var c=a.map[l],u=s[s.length>d?l:l-o];if(l<o||!u)i.push(a._parseField(c,a.parseDefaults[l],a.constraints[l]));else{var p="dayOfWeek"===c?m(u):u;i.push(a._parseField(c,p,a.constraints[l]))}}var h={};for(l=0,d=a.map.length;l<d;l++){h[a.map[l]]=i[l]}var y=a._handleMaxDaysInMonth(h);return h.dayOfMonth=y||h.dayOfMonth,new a(h,t);function m(e){var n=e.split("#");if(n.length>1){var r=+n[n.length-1];if(/,/.test(e))throw new Error("Constraint error, invalid dayOfWeek `#` and `,` special characters are incompatible");if(/\//.test(e))throw new Error("Constraint error, invalid dayOfWeek `#` and `/` special characters are incompatible");if(/-/.test(e))throw new Error("Constraint error, invalid dayOfWeek `#` and `-` special characters are incompatible");if(n.length>2||Number.isNaN(r)||r<1||r>5)throw new Error("Constraint error, invalid dayOfWeek occurrence number (#)");return t.nthDayOfWeek=r,n[0]}return e}}return"function"==typeof t&&(t={}),i(e,t)},a.fieldsToExpression=function(e,t){function n(e,t,n){if(!t)throw new Error("Validation error, Field "+e+" is missing");if(0===t.length)throw new Error("Validation error, Field "+e+" contains no values");for(var r=0,i=t.length;r<i;r++){var s=t[r];if(!a._isValidConstraintChar(n,s)&&("number"!=typeof s||Number.isNaN(s)||s<n.min||s>n.max))throw new Error("Constraint error, got value "+s+" expected range "+n.min+"-"+n.max)}}for(var r={},i=0,s=a.map.length;i<s;++i){var o=a.map[i],l=e[o];n(o,l,a.constraints[i]);for(var d=[],c=-1;++c<l.length;)d[c]=l[c];if((l=d.sort(a._sortCompareFn).filter(function(e,t,n){return!t||e!==n[t-1]})).length!==d.length)throw new Error("Validation error, Field "+o+" contains duplicate values");r[o]=l}var u=a._handleMaxDaysInMonth(r);return r.dayOfMonth=u||r.dayOfMonth,new a(r,t||{})},e.exports=a},(e,t,n)=>{"use strict";var r=n(210);function i(e,t){var n={zone:t};if(e?e instanceof i?this._date=e._date:e instanceof Date?this._date=r.DateTime.fromJSDate(e,n):"number"==typeof e?this._date=r.DateTime.fromMillis(e,n):"string"==typeof e&&(this._date=r.DateTime.fromISO(e,n),this._date.isValid||(this._date=r.DateTime.fromRFC2822(e,n)),this._date.isValid||(this._date=r.DateTime.fromSQL(e,n)),this._date.isValid||(this._date=r.DateTime.fromFormat(e,"EEE, d MMM yyyy HH:mm:ss",n))):this._date=r.DateTime.local(),!this._date||!this._date.isValid)throw new Error("CronDate: unhandled timestamp: "+JSON.stringify(e));t&&t!==this._date.zoneName&&(this._date=this._date.setZone(t))}i.prototype.addYear=function(){this._date=this._date.plus({years:1})},i.prototype.addMonth=function(){this._date=this._date.plus({months:1}).startOf("month")},i.prototype.addDay=function(){this._date=this._date.plus({days:1}).startOf("day")},i.prototype.addHour=function(){var e=this._date;this._date=this._date.plus({hours:1}).startOf("hour"),this._date<=e&&(this._date=this._date.plus({hours:1}))},i.prototype.addMinute=function(){var e=this._date;this._date=this._date.plus({minutes:1}).startOf("minute"),this._date<e&&(this._date=this._date.plus({hours:1}))},i.prototype.addSecond=function(){var e=this._date;this._date=this._date.plus({seconds:1}).startOf("second"),this._date<e&&(this._date=this._date.plus({hours:1}))},i.prototype.subtractYear=function(){this._date=this._date.minus({years:1})},i.prototype.subtractMonth=function(){this._date=this._date.minus({months:1}).endOf("month").startOf("second")},i.prototype.subtractDay=function(){this._date=this._date.minus({days:1}).endOf("day").startOf("second")},i.prototype.subtractHour=function(){var e=this._date;this._date=this._date.minus({hours:1}).endOf("hour").startOf("second"),this._date>=e&&(this._date=this._date.minus({hours:1}))},i.prototype.subtractMinute=function(){var e=this._date;this._date=this._date.minus({minutes:1}).endOf("minute").startOf("second"),this._date>e&&(this._date=this._date.minus({hours:1}))},i.prototype.subtractSecond=function(){var e=this._date;this._date=this._date.minus({seconds:1}).startOf("second"),this._date>e&&(this._date=this._date.minus({hours:1}))},i.prototype.getDate=function(){return this._date.day},i.prototype.getFullYear=function(){return this._date.year},i.prototype.getDay=function(){var e=this._date.weekday;return 7==e?0:e},i.prototype.getMonth=function(){return this._date.month-1},i.prototype.getHours=function(){return this._date.hour},i.prototype.getMinutes=function(){return this._date.minute},i.prototype.getSeconds=function(){return this._date.second},i.prototype.getMilliseconds=function(){return this._date.millisecond},i.prototype.getTime=function(){return this._date.valueOf()},i.prototype.getUTCDate=function(){return this._getUTC().day},i.prototype.getUTCFullYear=function(){return this._getUTC().year},i.prototype.getUTCDay=function(){var e=this._getUTC().weekday;return 7==e?0:e},i.prototype.getUTCMonth=function(){return this._getUTC().month-1},i.prototype.getUTCHours=function(){return this._getUTC().hour},i.prototype.getUTCMinutes=function(){return this._getUTC().minute},i.prototype.getUTCSeconds=function(){return this._getUTC().second},i.prototype.toISOString=function(){return this._date.toUTC().toISO()},i.prototype.toJSON=function(){return this._date.toJSON()},i.prototype.setDate=function(e){this._date=this._date.set({day:e})},i.prototype.setFullYear=function(e){this._date=this._date.set({year:e})},i.prototype.setDay=function(e){this._date=this._date.set({weekday:e})},i.prototype.setMonth=function(e){this._date=this._date.set({month:e+1})},i.prototype.setHours=function(e){this._date=this._date.set({hour:e})},i.prototype.setMinutes=function(e){this._date=this._date.set({minute:e})},i.prototype.setSeconds=function(e){this._date=this._date.set({second:e})},i.prototype.setMilliseconds=function(e){this._date=this._date.set({millisecond:e})},i.prototype._getUTC=function(){return this._date.toUTC()},i.prototype.toString=function(){return this.toDate().toString()},i.prototype.toDate=function(){return this._date.toJSDate()},i.prototype.isLastDayOfMonth=function(){var e=this._date.plus({days:1}).startOf("day");return this._date.month!==e.month},i.prototype.isLastWeekdayOfMonth=function(){var e=this._date.plus({days:7}).startOf("day");return this._date.month!==e.month},e.exports=i},(e,t,n)=>{"use strict";var r=n(21),i=n(211);const a=["base"],s=["padTo","floor"];function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter(function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable})),n.push.apply(n,r)}return n}function l(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach(function(t){r(e,t,n[t])}):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach(function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))})}return e}Object.defineProperty(t,"__esModule",{value:!0});class d extends Error{}class c extends d{constructor(e){super(`Invalid DateTime: ${e.toMessage()}`)}}class u extends d{constructor(e){super(`Invalid Interval: ${e.toMessage()}`)}}class p extends d{constructor(e){super(`Invalid Duration: ${e.toMessage()}`)}}class h extends d{}class y extends d{constructor(e){super(`Invalid unit ${e}`)}}class m extends d{}class f extends d{constructor(){super("Zone is an abstract class")}}const b="numeric",g="short",v="long",K={year:b,month:b,day:b},E={year:b,month:g,day:b},S={year:b,month:g,day:b,weekday:g},I={year:b,month:v,day:b},w={year:b,month:v,day:b,weekday:v},k={hour:b,minute:b},j={hour:b,minute:b,second:b},x={hour:b,minute:b,second:b,timeZoneName:g},T={hour:b,minute:b,second:b,timeZoneName:v},A={hour:b,minute:b,hourCycle:"h23"},O={hour:b,minute:b,second:b,hourCycle:"h23"},D={hour:b,minute:b,second:b,hourCycle:"h23",timeZoneName:g},C={hour:b,minute:b,second:b,hourCycle:"h23",timeZoneName:v},R={year:b,month:b,day:b,hour:b,minute:b},P={year:b,month:b,day:b,hour:b,minute:b,second:b},M={year:b,month:g,day:b,hour:b,minute:b},N={year:b,month:g,day:b,hour:b,minute:b,second:b},L={year:b,month:g,day:b,weekday:g,hour:b,minute:b},J={year:b,month:v,day:b,hour:b,minute:b,timeZoneName:g},_={year:b,month:v,day:b,hour:b,minute:b,second:b,timeZoneName:g},F={year:b,month:v,day:b,weekday:v,hour:b,minute:b,timeZoneName:v},V={year:b,month:v,day:b,weekday:v,hour:b,minute:b,second:b,timeZoneName:v};class G{get type(){throw new f}get name(){throw new f}get ianaName(){return this.name}get isUniversal(){throw new f}offsetName(e,t){throw new f}formatOffset(e,t){throw new f}offset(e){throw new f}equals(e){throw new f}get isValid(){throw new f}}let q=null;class Y extends G{static get instance(){return null===q&&(q=new Y),q}get type(){return"system"}get name(){return(new Intl.DateTimeFormat).resolvedOptions().timeZone}get isUniversal(){return!1}offsetName(e,{format:t,locale:n}){return ct(e,t,n)}formatOffset(e,t){return yt(this.offset(e),t)}offset(e){return-new Date(e).getTimezoneOffset()}equals(e){return"system"===e.type}get isValid(){return!0}}const U=new Map;const B={year:0,month:1,day:2,era:3,hour:4,minute:5,second:6};const W=new Map;class z extends G{static create(e){let t=W.get(e);return void 0===t&&W.set(e,t=new z(e)),t}static resetCache(){W.clear(),U.clear()}static isValidSpecifier(e){return this.isValidZone(e)}static isValidZone(e){if(!e)return!1;try{return new Intl.DateTimeFormat("en-US",{timeZone:e}).format(),!0}catch(e){return!1}}constructor(e){super(),this.zoneName=e,this.valid=z.isValidZone(e)}get type(){return"iana"}get name(){return this.zoneName}get isUniversal(){return!1}offsetName(e,{format:t,locale:n}){return ct(e,t,n,this.name)}formatOffset(e,t){return yt(this.offset(e),t)}offset(e){if(!this.valid)return NaN;const t=new Date(e);if(isNaN(t))return NaN;const n=function(e){let t=U.get(e);return void 0===t&&(t=new Intl.DateTimeFormat("en-US",{hour12:!1,timeZone:e,year:"numeric",month:"2-digit",day:"2-digit",hour:"2-digit",minute:"2-digit",second:"2-digit",era:"short"}),U.set(e,t)),t}(this.name);let[r,i,a,s,o,l,d]=n.formatToParts?function(e,t){const n=e.formatToParts(t),r=[];for(let e=0;e<n.length;e++){const{type:t,value:i}=n[e],a=B[t];"era"===t?r[a]=i:qe(a)||(r[a]=parseInt(i,10))}return r}(n,t):function(e,t){const n=e.format(t).replace(/\u200E/g,""),r=/(\d+)\/(\d+)\/(\d+) (AD|BC),? (\d+):(\d+):(\d+)/.exec(n),[,i,a,s,o,l,d,c]=r;return[s,i,a,o,l,d,c]}(n,t);"BC"===s&&(r=1-Math.abs(r));let c=+t;const u=c%1e3;return c-=u>=0?u:1e3+u,(st({year:r,month:i,day:a,hour:24===o?0:o,minute:l,second:d,millisecond:0})-c)/6e4}equals(e){return"iana"===e.type&&e.name===this.name}get isValid(){return this.valid}}let Q={};const $=new Map;function Z(e,t={}){const n=JSON.stringify([e,t]);let r=$.get(n);return void 0===r&&(r=new Intl.DateTimeFormat(e,t),$.set(n,r)),r}const H=new Map;const X=new Map;let ee=null;const te=new Map;function ne(e){let t=te.get(e);return void 0===t&&(t=new Intl.DateTimeFormat(e).resolvedOptions(),te.set(e,t)),t}const re=new Map;function ie(e,t,n,r){const i=e.listingMode();return"error"===i?null:"en"===i?n(t):r(t)}class ae{constructor(e,t,n){this.padTo=n.padTo||0,this.floor=n.floor||!1;const{padTo:r,floor:a}=n,o=i(n,s);if(!t||Object.keys(o).length>0){const t=l({useGrouping:!1},n);n.padTo>0&&(t.minimumIntegerDigits=n.padTo),this.inf=function(e,t={}){const n=JSON.stringify([e,t]);let r=H.get(n);return void 0===r&&(r=new Intl.NumberFormat(e,t),H.set(n,r)),r}(e,t)}}format(e){if(this.inf){const t=this.floor?Math.floor(e):e;return this.inf.format(t)}return He(this.floor?Math.floor(e):nt(e,3),this.padTo)}}class se{constructor(e,t,n){let r;if(this.opts=n,this.originalZone=void 0,this.opts.timeZone)this.dt=e;else if("fixed"===e.zone.type){const t=e.offset/60*-1,n=t>=0?`Etc/GMT+${t}`:`Etc/GMT${t}`;0!==e.offset&&z.create(n).valid?(r=n,this.dt=e):(r="UTC",this.dt=0===e.offset?e:e.setZone("UTC").plus({minutes:e.offset}),this.originalZone=e.zone)}else"system"===e.zone.type?this.dt=e:"iana"===e.zone.type?(this.dt=e,r=e.zone.name):(r="UTC",this.dt=e.setZone("UTC").plus({minutes:e.offset}),this.originalZone=e.zone);const i=l({},this.opts);i.timeZone=i.timeZone||r,this.dtf=Z(t,i)}format(){return this.originalZone?this.formatToParts().map(({value:e})=>e).join(""):this.dtf.format(this.dt.toJSDate())}formatToParts(){const e=this.dtf.formatToParts(this.dt.toJSDate());return this.originalZone?e.map(e=>{if("timeZoneName"===e.type){const t=this.originalZone.offsetName(this.dt.ts,{locale:this.dt.locale,format:this.opts.timeZoneName});return l(l({},e),{},{value:t})}return e}):e}resolvedOptions(){return this.dtf.resolvedOptions()}}class oe{constructor(e,t,n){this.opts=l({style:"long"},n),!t&&Be()&&(this.rtf=function(e,t={}){const{base:n}=t,r=i(t,a),s=JSON.stringify([e,r]);let o=X.get(s);return void 0===o&&(o=new Intl.RelativeTimeFormat(e,t),X.set(s,o)),o}(e,n))}format(e,t){return this.rtf?this.rtf.format(e,t):function(e,t,n="always",r=!1){const i={years:["year","yr."],quarters:["quarter","qtr."],months:["month","mo."],weeks:["week","wk."],days:["day","day","days"],hours:["hour","hr."],minutes:["minute","min."],seconds:["second","sec."]},a=-1===["hours","minutes","seconds"].indexOf(e);if("auto"===n&&a){const n="days"===e;switch(t){case 1:return n?"tomorrow":`next ${i[e][0]}`;case-1:return n?"yesterday":`last ${i[e][0]}`;case 0:return n?"today":`this ${i[e][0]}`}}const s=Object.is(t,-0)||t<0,o=Math.abs(t),l=1===o,d=i[e],c=r?l?d[1]:d[2]||d[1]:l?i[e][0]:e;return s?`${o} ${c} ago`:`in ${o} ${c}`}(t,e,this.opts.numeric,"long"!==this.opts.style)}formatToParts(e,t){return this.rtf?this.rtf.formatToParts(e,t):[]}}const le={firstDay:1,minimalDays:4,weekend:[6,7]};class de{static fromOpts(e){return de.create(e.locale,e.numberingSystem,e.outputCalendar,e.weekSettings,e.defaultToEN)}static create(e,t,n,r,i=!1){const a=e||xe.defaultLocale,s=a||(i?"en-US":ee||(ee=(new Intl.DateTimeFormat).resolvedOptions().locale,ee)),o=t||xe.defaultNumberingSystem,l=n||xe.defaultOutputCalendar,d=$e(r)||xe.defaultWeekSettings;return new de(s,o,l,d,a)}static resetCache(){ee=null,$.clear(),H.clear(),X.clear(),te.clear(),re.clear()}static fromObject({locale:e,numberingSystem:t,outputCalendar:n,weekSettings:r}={}){return de.create(e,t,n,r)}constructor(e,t,n,r,i){const[a,s,o]=function(e){const t=e.indexOf("-x-");-1!==t&&(e=e.substring(0,t));const n=e.indexOf("-u-");if(-1===n)return[e];{let t,r;try{t=Z(e).resolvedOptions(),r=e}catch(i){const a=e.substring(0,n);t=Z(a).resolvedOptions(),r=a}const{numberingSystem:i,calendar:a}=t;return[r,i,a]}}(e);this.locale=a,this.numberingSystem=t||s||null,this.outputCalendar=n||o||null,this.weekSettings=r,this.intl=function(e,t,n){return n||t?(e.includes("-u-")||(e+="-u"),n&&(e+=`-ca-${n}`),t&&(e+=`-nu-${t}`),e):e}(this.locale,this.numberingSystem,this.outputCalendar),this.weekdaysCache={format:{},standalone:{}},this.monthsCache={format:{},standalone:{}},this.meridiemCache=null,this.eraCache={},this.specifiedLocale=i,this.fastNumbersCached=null}get fastNumbers(){var e;return null==this.fastNumbersCached&&(this.fastNumbersCached=(!(e=this).numberingSystem||"latn"===e.numberingSystem)&&("latn"===e.numberingSystem||!e.locale||e.locale.startsWith("en")||"latn"===ne(e.locale).numberingSystem)),this.fastNumbersCached}listingMode(){const e=this.isEnglish(),t=!(null!==this.numberingSystem&&"latn"!==this.numberingSystem||null!==this.outputCalendar&&"gregory"!==this.outputCalendar);return e&&t?"en":"intl"}clone(e){return e&&0!==Object.getOwnPropertyNames(e).length?de.create(e.locale||this.specifiedLocale,e.numberingSystem||this.numberingSystem,e.outputCalendar||this.outputCalendar,$e(e.weekSettings)||this.weekSettings,e.defaultToEN||!1):this}redefaultToEN(e={}){return this.clone(l(l({},e),{},{defaultToEN:!0}))}redefaultToSystem(e={}){return this.clone(l(l({},e),{},{defaultToEN:!1}))}months(e,t=!1){return ie(this,e,vt,()=>{const n=t?{month:e,day:"numeric"}:{month:e},r=t?"format":"standalone";return this.monthsCache[r][e]||(this.monthsCache[r][e]=function(e){const t=[];for(let n=1;n<=12;n++){const r=Ir.utc(2009,n,1);t.push(e(r))}return t}(e=>this.extract(e,n,"month"))),this.monthsCache[r][e]})}weekdays(e,t=!1){return ie(this,e,It,()=>{const n=t?{weekday:e,year:"numeric",month:"long",day:"numeric"}:{weekday:e},r=t?"format":"standalone";return this.weekdaysCache[r][e]||(this.weekdaysCache[r][e]=function(e){const t=[];for(let n=1;n<=7;n++){const r=Ir.utc(2016,11,13+n);t.push(e(r))}return t}(e=>this.extract(e,n,"weekday"))),this.weekdaysCache[r][e]})}meridiems(){return ie(this,void 0,()=>wt,()=>{if(!this.meridiemCache){const e={hour:"numeric",hourCycle:"h12"};this.meridiemCache=[Ir.utc(2016,11,13,9),Ir.utc(2016,11,13,19)].map(t=>this.extract(t,e,"dayperiod"))}return this.meridiemCache})}eras(e){return ie(this,e,Tt,()=>{const t={era:e};return this.eraCache[e]||(this.eraCache[e]=[Ir.utc(-40,1,1),Ir.utc(2017,1,1)].map(e=>this.extract(e,t,"era"))),this.eraCache[e]})}extract(e,t,n){const r=this.dtFormatter(e,t).formatToParts().find(e=>e.type.toLowerCase()===n);return r?r.value:null}numberFormatter(e={}){return new ae(this.intl,e.forceSimple||this.fastNumbers,e)}dtFormatter(e,t={}){return new se(e,this.intl,t)}relFormatter(e={}){return new oe(this.intl,this.isEnglish(),e)}listFormatter(e={}){return function(e,t={}){const n=JSON.stringify([e,t]);let r=Q[n];return r||(r=new Intl.ListFormat(e,t),Q[n]=r),r}(this.intl,e)}isEnglish(){return"en"===this.locale||"en-us"===this.locale.toLowerCase()||ne(this.intl).locale.startsWith("en-us")}getWeekSettings(){return this.weekSettings?this.weekSettings:We()?function(e){let t=re.get(e);if(!t){const n=new Intl.Locale(e);t="getWeekInfo"in n?n.getWeekInfo():n.weekInfo,"minimalDays"in t||(t=l(l({},le),t)),re.set(e,t)}return t}(this.locale):le}getStartOfWeek(){return this.getWeekSettings().firstDay}getMinDaysInFirstWeek(){return this.getWeekSettings().minimalDays}getWeekendDays(){return this.getWeekSettings().weekend}equals(e){return this.locale===e.locale&&this.numberingSystem===e.numberingSystem&&this.outputCalendar===e.outputCalendar}toString(){return`Locale(${this.locale}, ${this.numberingSystem}, ${this.outputCalendar})`}}let ce=null;class ue extends G{static get utcInstance(){return null===ce&&(ce=new ue(0)),ce}static instance(e){return 0===e?ue.utcInstance:new ue(e)}static parseSpecifier(e){if(e){const t=e.match(/^utc(?:([+-]\d{1,2})(?::(\d{2}))?)?$/i);if(t)return new ue(ut(t[1],t[2]))}return null}constructor(e){super(),this.fixed=e}get type(){return"fixed"}get name(){return 0===this.fixed?"UTC":`UTC${yt(this.fixed,"narrow")}`}get ianaName(){return 0===this.fixed?"Etc/UTC":`Etc/GMT${yt(-this.fixed,"narrow")}`}offsetName(){return this.name}formatOffset(e,t){return yt(this.fixed,t)}get isUniversal(){return!0}offset(){return this.fixed}equals(e){return"fixed"===e.type&&e.fixed===this.fixed}get isValid(){return!0}}class pe extends G{constructor(e){super(),this.zoneName=e}get type(){return"invalid"}get name(){return this.zoneName}get isUniversal(){return!1}offsetName(){return null}formatOffset(){return""}offset(){return NaN}equals(){return!1}get isValid(){return!1}}function he(e,t){if(qe(e)||null===e)return t;if(e instanceof G)return e;if("string"==typeof e){const n=e.toLowerCase();return"default"===n?t:"local"===n||"system"===n?Y.instance:"utc"===n||"gmt"===n?ue.utcInstance:ue.parseSpecifier(n)||z.create(e)}return Ye(e)?ue.instance(e):"object"==typeof e&&"offset"in e&&"function"==typeof e.offset?e:new pe(e)}const ye={arab:"[-]",arabext:"[-]",bali:"[-]",beng:"[-]",deva:"[-]",fullwide:"[-]",gujr:"[-]",hanidec:"[|||||||||]",khmr:"[-]",knda:"[-]",laoo:"[-]",limb:"[-]",mlym:"[-]",mong:"[-]",mymr:"[-]",orya:"[-]",tamldec:"[-]",telu:"[-]",thai:"[-]",tibt:"[-]",latn:"\\d"},me={arab:[1632,1641],arabext:[1776,1785],bali:[6992,7001],beng:[2534,2543],deva:[2406,2415],fullwide:[65296,65303],gujr:[2790,2799],khmr:[6112,6121],knda:[3302,3311],laoo:[3792,3801],limb:[6470,6479],mlym:[3430,3439],mong:[6160,6169],mymr:[4160,4169],orya:[2918,2927],tamldec:[3046,3055],telu:[3174,3183],thai:[3664,3673],tibt:[3872,3881]},fe=ye.hanidec.replace(/[\[|\]]/g,"").split("");const be=new Map;function ge({numberingSystem:e},t=""){const n=e||"latn";let r=be.get(n);void 0===r&&(r=new Map,be.set(n,r));let i=r.get(t);return void 0===i&&(i=new RegExp(`${ye[n]}${t}`),r.set(t,i)),i}let ve,Ke=()=>Date.now(),Ee="system",Se=null,Ie=null,we=null,ke=60,je=null;class xe{static get now(){return Ke}static set now(e){Ke=e}static set defaultZone(e){Ee=e}static get defaultZone(){return he(Ee,Y.instance)}static get defaultLocale(){return Se}static set defaultLocale(e){Se=e}static get defaultNumberingSystem(){return Ie}static set defaultNumberingSystem(e){Ie=e}static get defaultOutputCalendar(){return we}static set defaultOutputCalendar(e){we=e}static get defaultWeekSettings(){return je}static set defaultWeekSettings(e){je=$e(e)}static get twoDigitCutoffYear(){return ke}static set twoDigitCutoffYear(e){ke=e%100}static get throwOnInvalid(){return ve}static set throwOnInvalid(e){ve=e}static resetCaches(){de.resetCache(),z.resetCache(),Ir.resetCache(),be.clear()}}class Te{constructor(e,t){this.reason=e,this.explanation=t}toMessage(){return this.explanation?`${this.reason}: ${this.explanation}`:this.reason}}const Ae=[0,31,59,90,120,151,181,212,243,273,304,334],Oe=[0,31,60,91,121,152,182,213,244,274,305,335];function De(e,t){return new Te("unit out of range",`you specified ${t} (of type ${typeof t}) as a ${e}, which is invalid`)}function Ce(e,t,n){const r=new Date(Date.UTC(e,t-1,n));e<100&&e>=0&&r.setUTCFullYear(r.getUTCFullYear()-1900);const i=r.getUTCDay();return 0===i?7:i}function Re(e,t,n){return n+(rt(e)?Oe:Ae)[t-1]}function Pe(e,t){const n=rt(e)?Oe:Ae,r=n.findIndex(e=>e<t);return{month:r+1,day:t-n[r]}}function Me(e,t){return(e-t+7)%7+1}function Ne(e,t=4,n=1){const{year:r,month:i,day:a}=e,s=Re(r,i,a),o=Me(Ce(r,i,a),n);let d,c=Math.floor((s-o+14-t)/7);return c<1?(d=r-1,c=lt(d,t,n)):c>lt(r,t,n)?(d=r+1,c=1):d=r,l({weekYear:d,weekNumber:c,weekday:o},mt(e))}function Le(e,t=4,n=1){const{weekYear:r,weekNumber:i,weekday:a}=e,s=Me(Ce(r,1,t),n),o=it(r);let d,c=7*i+a-s-7+t;c<1?(d=r-1,c+=it(d)):c>o?(d=r+1,c-=it(r)):d=r;const{month:u,day:p}=Pe(d,c);return l({year:d,month:u,day:p},mt(e))}function Je(e){const{year:t,month:n,day:r}=e;return l({year:t,ordinal:Re(t,n,r)},mt(e))}function _e(e){const{year:t,ordinal:n}=e,{month:r,day:i}=Pe(t,n);return l({year:t,month:r,day:i},mt(e))}function Fe(e,t){if(!qe(e.localWeekday)||!qe(e.localWeekNumber)||!qe(e.localWeekYear)){if(!qe(e.weekday)||!qe(e.weekNumber)||!qe(e.weekYear))throw new h("Cannot mix locale-based week fields with ISO-based week fields");return qe(e.localWeekday)||(e.weekday=e.localWeekday),qe(e.localWeekNumber)||(e.weekNumber=e.localWeekNumber),qe(e.localWeekYear)||(e.weekYear=e.localWeekYear),delete e.localWeekday,delete e.localWeekNumber,delete e.localWeekYear,{minDaysInFirstWeek:t.getMinDaysInFirstWeek(),startOfWeek:t.getStartOfWeek()}}return{minDaysInFirstWeek:4,startOfWeek:1}}function Ve(e){const t=Ue(e.year),n=Ze(e.month,1,12),r=Ze(e.day,1,at(e.year,e.month));return t?n?!r&&De("day",e.day):De("month",e.month):De("year",e.year)}function Ge(e){const{hour:t,minute:n,second:r,millisecond:i}=e,a=Ze(t,0,23)||24===t&&0===n&&0===r&&0===i,s=Ze(n,0,59),o=Ze(r,0,59),l=Ze(i,0,999);return a?s?o?!l&&De("millisecond",i):De("second",r):De("minute",n):De("hour",t)}function qe(e){return void 0===e}function Ye(e){return"number"==typeof e}function Ue(e){return"number"==typeof e&&e%1==0}function Be(){try{return"undefined"!=typeof Intl&&!!Intl.RelativeTimeFormat}catch(e){return!1}}function We(){try{return"undefined"!=typeof Intl&&!!Intl.Locale&&("weekInfo"in Intl.Locale.prototype||"getWeekInfo"in Intl.Locale.prototype)}catch(e){return!1}}function ze(e,t,n){if(0!==e.length)return e.reduce((e,r)=>{const i=[t(r),r];return e&&n(e[0],i[0])===e[0]?e:i},null)[1]}function Qe(e,t){return Object.prototype.hasOwnProperty.call(e,t)}function $e(e){if(null==e)return null;if("object"!=typeof e)throw new m("Week settings must be an object");if(!Ze(e.firstDay,1,7)||!Ze(e.minimalDays,1,7)||!Array.isArray(e.weekend)||e.weekend.some(e=>!Ze(e,1,7)))throw new m("Invalid week settings");return{firstDay:e.firstDay,minimalDays:e.minimalDays,weekend:Array.from(e.weekend)}}function Ze(e,t,n){return Ue(e)&&e>=t&&e<=n}function He(e,t=2){let n;return n=e<0?"-"+(""+-e).padStart(t,"0"):(""+e).padStart(t,"0"),n}function Xe(e){return qe(e)||null===e||""===e?void 0:parseInt(e,10)}function et(e){return qe(e)||null===e||""===e?void 0:parseFloat(e)}function tt(e){if(!qe(e)&&null!==e&&""!==e){const t=1e3*parseFloat("0."+e);return Math.floor(t)}}function nt(e,t,n=!1){const r=10**t;return(n?Math.trunc:Math.round)(e*r)/r}function rt(e){return e%4==0&&(e%100!=0||e%400==0)}function it(e){return rt(e)?366:365}function at(e,t){const n=function(e,t){return e-t*Math.floor(e/t)}(t-1,12)+1;return 2===n?rt(e+(t-n)/12)?29:28:[31,null,31,30,31,30,31,31,30,31,30,31][n-1]}function st(e){let t=Date.UTC(e.year,e.month-1,e.day,e.hour,e.minute,e.second,e.millisecond);return e.year<100&&e.year>=0&&(t=new Date(t),t.setUTCFullYear(e.year,e.month-1,e.day)),+t}function ot(e,t,n){return-Me(Ce(e,1,t),n)+t-1}function lt(e,t=4,n=1){const r=ot(e,t,n),i=ot(e+1,t,n);return(it(e)-r+i)/7}function dt(e){return e>99?e:e>xe.twoDigitCutoffYear?1900+e:2e3+e}function ct(e,t,n,r=null){const i=new Date(e),a={hourCycle:"h23",year:"numeric",month:"2-digit",day:"2-digit",hour:"2-digit",minute:"2-digit"};r&&(a.timeZone=r);const s=l({timeZoneName:t},a),o=new Intl.DateTimeFormat(n,s).formatToParts(i).find(e=>"timezonename"===e.type.toLowerCase());return o?o.value:null}function ut(e,t){let n=parseInt(e,10);Number.isNaN(n)&&(n=0);const r=parseInt(t,10)||0;return 60*n+(n<0||Object.is(n,-0)?-r:r)}function pt(e){const t=Number(e);if("boolean"==typeof e||""===e||Number.isNaN(t))throw new m(`Invalid unit value ${e}`);return t}function ht(e,t){const n={};for(const r in e)if(Qe(e,r)){const i=e[r];if(null==i)continue;n[t(r)]=pt(i)}return n}function yt(e,t){const n=Math.trunc(Math.abs(e/60)),r=Math.trunc(Math.abs(e%60)),i=e>=0?"+":"-";switch(t){case"short":return`${i}${He(n,2)}:${He(r,2)}`;case"narrow":return`${i}${n}${r>0?`:${r}`:""}`;case"techie":return`${i}${He(n,2)}${He(r,2)}`;default:throw new RangeError(`Value format ${t} is out of range for property format`)}}function mt(e){return function(e,t){return t.reduce((t,n)=>(t[n]=e[n],t),{})}(e,["hour","minute","second","millisecond"])}const ft=["January","February","March","April","May","June","July","August","September","October","November","December"],bt=["Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec"],gt=["J","F","M","A","M","J","J","A","S","O","N","D"];function vt(e){switch(e){case"narrow":return[...gt];case"short":return[...bt];case"long":return[...ft];case"numeric":return["1","2","3","4","5","6","7","8","9","10","11","12"];case"2-digit":return["01","02","03","04","05","06","07","08","09","10","11","12"];default:return null}}const Kt=["Monday","Tuesday","Wednesday","Thursday","Friday","Saturday","Sunday"],Et=["Mon","Tue","Wed","Thu","Fri","Sat","Sun"],St=["M","T","W","T","F","S","S"];function It(e){switch(e){case"narrow":return[...St];case"short":return[...Et];case"long":return[...Kt];case"numeric":return["1","2","3","4","5","6","7"];default:return null}}const wt=["AM","PM"],kt=["Before Christ","Anno Domini"],jt=["BC","AD"],xt=["B","A"];function Tt(e){switch(e){case"narrow":return[...xt];case"short":return[...jt];case"long":return[...kt];default:return null}}function At(e,t){let n="";for(const r of e)r.literal?n+=r.val:n+=t(r.val);return n}const Ot={D:K,DD:E,DDD:I,DDDD:w,t:k,tt:j,ttt:x,tttt:T,T:A,TT:O,TTT:D,TTTT:C,f:R,ff:M,fff:J,ffff:F,F:P,FF:N,FFF:_,FFFF:V};class Dt{static create(e,t={}){return new Dt(e,t)}static parseFormat(e){let t=null,n="",r=!1;const i=[];for(let a=0;a<e.length;a++){const s=e.charAt(a);"'"===s?(n.length>0&&i.push({literal:r||/^\s+$/.test(n),val:n}),t=null,n="",r=!r):r||s===t?n+=s:(n.length>0&&i.push({literal:/^\s+$/.test(n),val:n}),n=s,t=s)}return n.length>0&&i.push({literal:r||/^\s+$/.test(n),val:n}),i}static macroTokenToFormatOpts(e){return Ot[e]}constructor(e,t){this.opts=t,this.loc=e,this.systemLoc=null}formatWithSystemDefault(e,t){null===this.systemLoc&&(this.systemLoc=this.loc.redefaultToSystem());return this.systemLoc.dtFormatter(e,l(l({},this.opts),t)).format()}dtFormatter(e,t={}){return this.loc.dtFormatter(e,l(l({},this.opts),t))}formatDateTime(e,t){return this.dtFormatter(e,t).format()}formatDateTimeParts(e,t){return this.dtFormatter(e,t).formatToParts()}formatInterval(e,t){return this.dtFormatter(e.start,t).dtf.formatRange(e.start.toJSDate(),e.end.toJSDate())}resolvedOptions(e,t){return this.dtFormatter(e,t).resolvedOptions()}num(e,t=0){if(this.opts.forceSimple)return He(e,t);const n=l({},this.opts);return t>0&&(n.padTo=t),this.loc.numberFormatter(n).format(e)}formatDateTimeFromString(e,t){const n="en"===this.loc.listingMode(),r=this.loc.outputCalendar&&"gregory"!==this.loc.outputCalendar,i=(t,n)=>this.loc.extract(e,t,n),a=t=>e.isOffsetFixed&&0===e.offset&&t.allowZ?"Z":e.isValid?e.zone.formatOffset(e.ts,t.format):"",s=()=>n?function(e){return wt[e.hour<12?0:1]}(e):i({hour:"numeric",hourCycle:"h12"},"dayperiod"),o=(t,r)=>n?function(e,t){return vt(t)[e.month-1]}(e,t):i(r?{month:t}:{month:t,day:"numeric"},"month"),l=(t,r)=>n?function(e,t){return It(t)[e.weekday-1]}(e,t):i(r?{weekday:t}:{weekday:t,month:"long",day:"numeric"},"weekday"),d=t=>{const n=Dt.macroTokenToFormatOpts(t);return n?this.formatWithSystemDefault(e,n):t},c=t=>n?function(e,t){return Tt(t)[e.year<0?0:1]}(e,t):i({era:t},"era");return At(Dt.parseFormat(t),t=>{switch(t){case"S":return this.num(e.millisecond);case"u":case"SSS":return this.num(e.millisecond,3);case"s":return this.num(e.second);case"ss":return this.num(e.second,2);case"uu":return this.num(Math.floor(e.millisecond/10),2);case"uuu":return this.num(Math.floor(e.millisecond/100));case"m":return this.num(e.minute);case"mm":return this.num(e.minute,2);case"h":return this.num(e.hour%12==0?12:e.hour%12);case"hh":return this.num(e.hour%12==0?12:e.hour%12,2);case"H":return this.num(e.hour);case"HH":return this.num(e.hour,2);case"Z":return a({format:"narrow",allowZ:this.opts.allowZ});case"ZZ":return a({format:"short",allowZ:this.opts.allowZ});case"ZZZ":return a({format:"techie",allowZ:this.opts.allowZ});case"ZZZZ":return e.zone.offsetName(e.ts,{format:"short",locale:this.loc.locale});case"ZZZZZ":return e.zone.offsetName(e.ts,{format:"long",locale:this.loc.locale});case"z":return e.zoneName;case"a":return s();case"d":return r?i({day:"numeric"},"day"):this.num(e.day);case"dd":return r?i({day:"2-digit"},"day"):this.num(e.day,2);case"c":case"E":return this.num(e.weekday);case"ccc":return l("short",!0);case"cccc":return l("long",!0);case"ccccc":return l("narrow",!0);case"EEE":return l("short",!1);case"EEEE":return l("long",!1);case"EEEEE":return l("narrow",!1);case"L":return r?i({month:"numeric",day:"numeric"},"month"):this.num(e.month);case"LL":return r?i({month:"2-digit",day:"numeric"},"month"):this.num(e.month,2);case"LLL":return o("short",!0);case"LLLL":return o("long",!0);case"LLLLL":return o("narrow",!0);case"M":return r?i({month:"numeric"},"month"):this.num(e.month);case"MM":return r?i({month:"2-digit"},"month"):this.num(e.month,2);case"MMM":return o("short",!1);case"MMMM":return o("long",!1);case"MMMMM":return o("narrow",!1);case"y":return r?i({year:"numeric"},"year"):this.num(e.year);case"yy":return r?i({year:"2-digit"},"year"):this.num(e.year.toString().slice(-2),2);case"yyyy":return r?i({year:"numeric"},"year"):this.num(e.year,4);case"yyyyyy":return r?i({year:"numeric"},"year"):this.num(e.year,6);case"G":return c("short");case"GG":return c("long");case"GGGGG":return c("narrow");case"kk":return this.num(e.weekYear.toString().slice(-2),2);case"kkkk":return this.num(e.weekYear,4);case"W":return this.num(e.weekNumber);case"WW":return this.num(e.weekNumber,2);case"n":return this.num(e.localWeekNumber);case"nn":return this.num(e.localWeekNumber,2);case"ii":return this.num(e.localWeekYear.toString().slice(-2),2);case"iiii":return this.num(e.localWeekYear,4);case"o":return this.num(e.ordinal);case"ooo":return this.num(e.ordinal,3);case"q":return this.num(e.quarter);case"qq":return this.num(e.quarter,2);case"X":return this.num(Math.floor(e.ts/1e3));case"x":return this.num(e.ts);default:return d(t)}})}formatDurationFromString(e,t){const n=e=>{switch(e[0]){case"S":return"millisecond";case"s":return"second";case"m":return"minute";case"h":return"hour";case"d":return"day";case"w":return"week";case"M":return"month";case"y":return"year";default:return null}},r=Dt.parseFormat(t),i=r.reduce((e,{literal:t,val:n})=>t?e:e.concat(n),[]);return At(r,(e=>t=>{const r=n(t);return r?this.num(e.get(r),t.length):t})(e.shiftTo(...i.map(n).filter(e=>e))))}}const Ct=/[A-Za-z_+-]{1,256}(?::?\/[A-Za-z0-9_+-]{1,256}(?:\/[A-Za-z0-9_+-]{1,256})?)?/;function Rt(...e){const t=e.reduce((e,t)=>e+t.source,"");return RegExp(`^${t}$`)}function Pt(...e){return t=>e.reduce(([e,n,r],i)=>{const[a,s,o]=i(t,r);return[l(l({},e),a),s||n,o]},[{},null,1]).slice(0,2)}function Mt(e,...t){if(null==e)return[null,null];for(const[n,r]of t){const t=n.exec(e);if(t)return r(t)}return[null,null]}function Nt(...e){return(t,n)=>{const r={};let i;for(i=0;i<e.length;i++)r[e[i]]=Xe(t[n+i]);return[r,null,n+i]}}const Lt=/(?:(Z)|([+-]\d\d)(?::?(\d\d))?)/,Jt=/(\d\d)(?::?(\d\d)(?::?(\d\d)(?:[.,](\d{1,30}))?)?)?/,_t=RegExp(`${Jt.source}${`(?:${Lt.source}?(?:\\[(${Ct.source})\\])?)?`}`),Ft=RegExp(`(?:T${_t.source})?`),Vt=Nt("weekYear","weekNumber","weekDay"),Gt=Nt("year","ordinal"),qt=RegExp(`${Jt.source} ?(?:${Lt.source}|(${Ct.source}))?`),Yt=RegExp(`(?: ${qt.source})?`);function Ut(e,t,n){const r=e[t];return qe(r)?n:Xe(r)}function Bt(e,t){return[{hours:Ut(e,t,0),minutes:Ut(e,t+1,0),seconds:Ut(e,t+2,0),milliseconds:tt(e[t+3])},null,t+4]}function Wt(e,t){const n=!e[t]&&!e[t+1],r=ut(e[t+1],e[t+2]);return[{},n?null:ue.instance(r),t+3]}function zt(e,t){return[{},e[t]?z.create(e[t]):null,t+1]}const Qt=RegExp(`^T?${Jt.source}$`),$t=/^-?P(?:(?:(-?\d{1,20}(?:\.\d{1,20})?)Y)?(?:(-?\d{1,20}(?:\.\d{1,20})?)M)?(?:(-?\d{1,20}(?:\.\d{1,20})?)W)?(?:(-?\d{1,20}(?:\.\d{1,20})?)D)?(?:T(?:(-?\d{1,20}(?:\.\d{1,20})?)H)?(?:(-?\d{1,20}(?:\.\d{1,20})?)M)?(?:(-?\d{1,20})(?:[.,](-?\d{1,20}))?S)?)?)$/;function Zt(e){const[t,n,r,i,a,s,o,l,d]=e,c="-"===t[0],u=l&&"-"===l[0],p=(e,t=!1)=>void 0!==e&&(t||e&&c)?-e:e;return[{years:p(et(n)),months:p(et(r)),weeks:p(et(i)),days:p(et(a)),hours:p(et(s)),minutes:p(et(o)),seconds:p(et(l),"-0"===l),milliseconds:p(tt(d),u)}]}const Ht={GMT:0,EDT:-240,EST:-300,CDT:-300,CST:-360,MDT:-360,MST:-420,PDT:-420,PST:-480};function Xt(e,t,n,r,i,a,s){const o={year:2===t.length?dt(Xe(t)):Xe(t),month:bt.indexOf(n)+1,day:Xe(r),hour:Xe(i),minute:Xe(a)};return s&&(o.second=Xe(s)),e&&(o.weekday=e.length>3?Kt.indexOf(e)+1:Et.indexOf(e)+1),o}const en=/^(?:(Mon|Tue|Wed|Thu|Fri|Sat|Sun),\s)?(\d{1,2})\s(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)\s(\d{2,4})\s(\d\d):(\d\d)(?::(\d\d))?\s(?:(UT|GMT|[ECMP][SD]T)|([Zz])|(?:([+-]\d\d)(\d\d)))$/;function tn(e){const[,t,n,r,i,a,s,o,l,d,c,u]=e,p=Xt(t,i,r,n,a,s,o);let h;return h=l?Ht[l]:d?0:ut(c,u),[p,new ue(h)]}const nn=/^(Mon|Tue|Wed|Thu|Fri|Sat|Sun), (\d\d) (Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec) (\d{4}) (\d\d):(\d\d):(\d\d) GMT$/,rn=/^(Monday|Tuesday|Wednesday|Thursday|Friday|Saturday|Sunday), (\d\d)-(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)-(\d\d) (\d\d):(\d\d):(\d\d) GMT$/,an=/^(Mon|Tue|Wed|Thu|Fri|Sat|Sun) (Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec) ( \d|\d\d) (\d\d):(\d\d):(\d\d) (\d{4})$/;function sn(e){const[,t,n,r,i,a,s,o]=e;return[Xt(t,i,r,n,a,s,o),ue.utcInstance]}function on(e){const[,t,n,r,i,a,s,o]=e;return[Xt(t,o,n,r,i,a,s),ue.utcInstance]}const ln=Rt(/([+-]\d{6}|\d{4})(?:-?(\d\d)(?:-?(\d\d))?)?/,Ft),dn=Rt(/(\d{4})-?W(\d\d)(?:-?(\d))?/,Ft),cn=Rt(/(\d{4})-?(\d{3})/,Ft),un=Rt(_t),pn=Pt(function(e,t){return[{year:Ut(e,t),month:Ut(e,t+1,1),day:Ut(e,t+2,1)},null,t+3]},Bt,Wt,zt),hn=Pt(Vt,Bt,Wt,zt),yn=Pt(Gt,Bt,Wt,zt),mn=Pt(Bt,Wt,zt);const fn=Pt(Bt);const bn=Rt(/(\d{4})-(\d\d)-(\d\d)/,Yt),gn=Rt(qt),vn=Pt(Bt,Wt,zt);const Kn="Invalid Duration",En={weeks:{days:7,hours:168,minutes:10080,seconds:604800,milliseconds:6048e5},days:{hours:24,minutes:1440,seconds:86400,milliseconds:864e5},hours:{minutes:60,seconds:3600,milliseconds:36e5},minutes:{seconds:60,milliseconds:6e4},seconds:{milliseconds:1e3}},Sn=l({years:{quarters:4,months:12,weeks:52,days:365,hours:8760,minutes:525600,seconds:31536e3,milliseconds:31536e6},quarters:{months:3,weeks:13,days:91,hours:2184,minutes:131040,seconds:7862400,milliseconds:78624e5},months:{weeks:4,days:30,hours:720,minutes:43200,seconds:2592e3,milliseconds:2592e6}},En),In=365.2425,wn=30.436875,kn=l({years:{quarters:4,months:12,weeks:52.1775,days:In,hours:8765.82,minutes:525949.2,seconds:525949.2*60,milliseconds:525949.2*60*1e3},quarters:{months:3,weeks:13.044375,days:91.310625,hours:2191.455,minutes:131487.3,seconds:525949.2*60/4,milliseconds:7889237999.999999},months:{weeks:4.3481250000000005,days:wn,hours:730.485,minutes:43829.1,seconds:2629746,milliseconds:2629746e3}},En),jn=["years","quarters","months","weeks","days","hours","minutes","seconds","milliseconds"],xn=jn.slice(0).reverse();function Tn(e,t,n=!1){const r={values:n?t.values:l(l({},e.values),t.values||{}),loc:e.loc.clone(t.loc),conversionAccuracy:t.conversionAccuracy||e.conversionAccuracy,matrix:t.matrix||e.matrix};return new Dn(r)}function An(e,t){var n;let r=null!=(n=t.milliseconds)?n:0;for(const n of xn.slice(1))t[n]&&(r+=t[n]*e[n].milliseconds);return r}function On(e,t){const n=An(e,t)<0?-1:1;jn.reduceRight((r,i)=>{if(qe(t[i]))return r;if(r){const a=t[r]*n,s=e[i][r],o=Math.floor(a/s);t[i]+=o*n,t[r]-=o*s*n}return i},null),jn.reduce((n,r)=>{if(qe(t[r]))return n;if(n){const i=t[n]%1;t[n]-=i,t[r]+=i*e[n][r]}return r},null)}class Dn{constructor(e){const t="longterm"===e.conversionAccuracy||!1;let n=t?kn:Sn;e.matrix&&(n=e.matrix),this.values=e.values,this.loc=e.loc||de.create(),this.conversionAccuracy=t?"longterm":"casual",this.invalid=e.invalid||null,this.matrix=n,this.isLuxonDuration=!0}static fromMillis(e,t){return Dn.fromObject({milliseconds:e},t)}static fromObject(e,t={}){if(null==e||"object"!=typeof e)throw new m("Duration.fromObject: argument expected to be an object, got "+(null===e?"null":typeof e));return new Dn({values:ht(e,Dn.normalizeUnit),loc:de.fromObject(t),conversionAccuracy:t.conversionAccuracy,matrix:t.matrix})}static fromDurationLike(e){if(Ye(e))return Dn.fromMillis(e);if(Dn.isDuration(e))return e;if("object"==typeof e)return Dn.fromObject(e);throw new m(`Unknown duration argument ${e} of type ${typeof e}`)}static fromISO(e,t){const[n]=function(e){return Mt(e,[$t,Zt])}(e);return n?Dn.fromObject(n,t):Dn.invalid("unparsable",`the input "${e}" can't be parsed as ISO 8601`)}static fromISOTime(e,t){const[n]=function(e){return Mt(e,[Qt,fn])}(e);return n?Dn.fromObject(n,t):Dn.invalid("unparsable",`the input "${e}" can't be parsed as ISO 8601`)}static invalid(e,t=null){if(!e)throw new m("need to specify a reason the Duration is invalid");const n=e instanceof Te?e:new Te(e,t);if(xe.throwOnInvalid)throw new p(n);return new Dn({invalid:n})}static normalizeUnit(e){const t={year:"years",years:"years",quarter:"quarters",quarters:"quarters",month:"months",months:"months",week:"weeks",weeks:"weeks",day:"days",days:"days",hour:"hours",hours:"hours",minute:"minutes",minutes:"minutes",second:"seconds",seconds:"seconds",millisecond:"milliseconds",milliseconds:"milliseconds"}[e?e.toLowerCase():e];if(!t)throw new y(e);return t}static isDuration(e){return e&&e.isLuxonDuration||!1}get locale(){return this.isValid?this.loc.locale:null}get numberingSystem(){return this.isValid?this.loc.numberingSystem:null}toFormat(e,t={}){const n=l(l({},t),{},{floor:!1!==t.round&&!1!==t.floor});return this.isValid?Dt.create(this.loc,n).formatDurationFromString(this,e):Kn}toHuman(e={}){if(!this.isValid)return Kn;const t=jn.map(t=>{const n=this.values[t];return qe(n)?null:this.loc.numberFormatter(l(l({style:"unit",unitDisplay:"long"},e),{},{unit:t.slice(0,-1)})).format(n)}).filter(e=>e);return this.loc.listFormatter(l({type:"conjunction",style:e.listStyle||"narrow"},e)).format(t)}toObject(){return this.isValid?l({},this.values):{}}toISO(){if(!this.isValid)return null;let e="P";return 0!==this.years&&(e+=this.years+"Y"),0===this.months&&0===this.quarters||(e+=this.months+3*this.quarters+"M"),0!==this.weeks&&(e+=this.weeks+"W"),0!==this.days&&(e+=this.days+"D"),0===this.hours&&0===this.minutes&&0===this.seconds&&0===this.milliseconds||(e+="T"),0!==this.hours&&(e+=this.hours+"H"),0!==this.minutes&&(e+=this.minutes+"M"),0===this.seconds&&0===this.milliseconds||(e+=nt(this.seconds+this.milliseconds/1e3,3)+"S"),"P"===e&&(e+="T0S"),e}toISOTime(e={}){if(!this.isValid)return null;const t=this.toMillis();if(t<0||t>=864e5)return null;e=l(l({suppressMilliseconds:!1,suppressSeconds:!1,includePrefix:!1,format:"extended"},e),{},{includeOffset:!1});return Ir.fromMillis(t,{zone:"UTC"}).toISOTime(e)}toJSON(){return this.toISO()}toString(){return this.toISO()}[Symbol.for("nodejs.util.inspect.custom")](){return this.isValid?`Duration { values: ${JSON.stringify(this.values)} }`:`Duration { Invalid, reason: ${this.invalidReason} }`}toMillis(){return this.isValid?An(this.matrix,this.values):NaN}valueOf(){return this.toMillis()}plus(e){if(!this.isValid)return this;const t=Dn.fromDurationLike(e),n={};for(const e of jn)(Qe(t.values,e)||Qe(this.values,e))&&(n[e]=t.get(e)+this.get(e));return Tn(this,{values:n},!0)}minus(e){if(!this.isValid)return this;const t=Dn.fromDurationLike(e);return this.plus(t.negate())}mapUnits(e){if(!this.isValid)return this;const t={};for(const n of Object.keys(this.values))t[n]=pt(e(this.values[n],n));return Tn(this,{values:t},!0)}get(e){return this[Dn.normalizeUnit(e)]}set(e){if(!this.isValid)return this;return Tn(this,{values:l(l({},this.values),ht(e,Dn.normalizeUnit))})}reconfigure({locale:e,numberingSystem:t,conversionAccuracy:n,matrix:r}={}){return Tn(this,{loc:this.loc.clone({locale:e,numberingSystem:t}),matrix:r,conversionAccuracy:n})}as(e){return this.isValid?this.shiftTo(e).get(e):NaN}normalize(){if(!this.isValid)return this;const e=this.toObject();return On(this.matrix,e),Tn(this,{values:e},!0)}rescale(){if(!this.isValid)return this;return Tn(this,{values:function(e){const t={};for(const[n,r]of Object.entries(e))0!==r&&(t[n]=r);return t}(this.normalize().shiftToAll().toObject())},!0)}shiftTo(...e){if(!this.isValid)return this;if(0===e.length)return this;e=e.map(e=>Dn.normalizeUnit(e));const t={},n={},r=this.toObject();let i;for(const a of jn)if(e.indexOf(a)>=0){i=a;let e=0;for(const t in n)e+=this.matrix[t][a]*n[t],n[t]=0;Ye(r[a])&&(e+=r[a]);const s=Math.trunc(e);t[a]=s,n[a]=(1e3*e-1e3*s)/1e3}else Ye(r[a])&&(n[a]=r[a]);for(const e in n)0!==n[e]&&(t[i]+=e===i?n[e]:n[e]/this.matrix[i][e]);return On(this.matrix,t),Tn(this,{values:t},!0)}shiftToAll(){return this.isValid?this.shiftTo("years","months","weeks","days","hours","minutes","seconds","milliseconds"):this}negate(){if(!this.isValid)return this;const e={};for(const t of Object.keys(this.values))e[t]=0===this.values[t]?0:-this.values[t];return Tn(this,{values:e},!0)}get years(){return this.isValid?this.values.years||0:NaN}get quarters(){return this.isValid?this.values.quarters||0:NaN}get months(){return this.isValid?this.values.months||0:NaN}get weeks(){return this.isValid?this.values.weeks||0:NaN}get days(){return this.isValid?this.values.days||0:NaN}get hours(){return this.isValid?this.values.hours||0:NaN}get minutes(){return this.isValid?this.values.minutes||0:NaN}get seconds(){return this.isValid?this.values.seconds||0:NaN}get milliseconds(){return this.isValid?this.values.milliseconds||0:NaN}get isValid(){return null===this.invalid}get invalidReason(){return this.invalid?this.invalid.reason:null}get invalidExplanation(){return this.invalid?this.invalid.explanation:null}equals(e){if(!this.isValid||!e.isValid)return!1;if(!this.loc.equals(e.loc))return!1;function t(e,t){return void 0===e||0===e?void 0===t||0===t:e===t}for(const n of jn)if(!t(this.values[n],e.values[n]))return!1;return!0}}const Cn="Invalid Interval";class Rn{constructor(e){this.s=e.start,this.e=e.end,this.invalid=e.invalid||null,this.isLuxonInterval=!0}static invalid(e,t=null){if(!e)throw new m("need to specify a reason the Interval is invalid");const n=e instanceof Te?e:new Te(e,t);if(xe.throwOnInvalid)throw new u(n);return new Rn({invalid:n})}static fromDateTimes(e,t){const n=wr(e),r=wr(t),i=function(e,t){return e&&e.isValid?t&&t.isValid?t<e?Rn.invalid("end before start",`The end of an interval must be after its start, but you had start=${e.toISO()} and end=${t.toISO()}`):null:Rn.invalid("missing or invalid end"):Rn.invalid("missing or invalid start")}(n,r);return null==i?new Rn({start:n,end:r}):i}static after(e,t){const n=Dn.fromDurationLike(t),r=wr(e);return Rn.fromDateTimes(r,r.plus(n))}static before(e,t){const n=Dn.fromDurationLike(t),r=wr(e);return Rn.fromDateTimes(r.minus(n),r)}static fromISO(e,t){const[n,r]=(e||"").split("/",2);if(n&&r){let e,i,a,s;try{e=Ir.fromISO(n,t),i=e.isValid}catch(r){i=!1}try{a=Ir.fromISO(r,t),s=a.isValid}catch(r){s=!1}if(i&&s)return Rn.fromDateTimes(e,a);if(i){const n=Dn.fromISO(r,t);if(n.isValid)return Rn.after(e,n)}else if(s){const e=Dn.fromISO(n,t);if(e.isValid)return Rn.before(a,e)}}return Rn.invalid("unparsable",`the input "${e}" can't be parsed as ISO 8601`)}static isInterval(e){return e&&e.isLuxonInterval||!1}get start(){return this.isValid?this.s:null}get end(){return this.isValid?this.e:null}get lastDateTime(){return this.isValid&&this.e?this.e.minus(1):null}get isValid(){return null===this.invalidReason}get invalidReason(){return this.invalid?this.invalid.reason:null}get invalidExplanation(){return this.invalid?this.invalid.explanation:null}length(e="milliseconds"){return this.isValid?this.toDuration(e).get(e):NaN}count(e="milliseconds",t){if(!this.isValid)return NaN;const n=this.start.startOf(e,t);let r;return r=null!=t&&t.useLocaleWeeks?this.end.reconfigure({locale:n.locale}):this.end,r=r.startOf(e,t),Math.floor(r.diff(n,e).get(e))+(r.valueOf()!==this.end.valueOf())}hasSame(e){return!!this.isValid&&(this.isEmpty()||this.e.minus(1).hasSame(this.s,e))}isEmpty(){return this.s.valueOf()===this.e.valueOf()}isAfter(e){return!!this.isValid&&this.s>e}isBefore(e){return!!this.isValid&&this.e<=e}contains(e){return!!this.isValid&&(this.s<=e&&this.e>e)}set({start:e,end:t}={}){return this.isValid?Rn.fromDateTimes(e||this.s,t||this.e):this}splitAt(...e){if(!this.isValid)return[];const t=e.map(wr).filter(e=>this.contains(e)).sort((e,t)=>e.toMillis()-t.toMillis()),n=[];let{s:r}=this,i=0;for(;r<this.e;){const e=t[i]||this.e,a=+e>+this.e?this.e:e;n.push(Rn.fromDateTimes(r,a)),r=a,i+=1}return n}splitBy(e){const t=Dn.fromDurationLike(e);if(!this.isValid||!t.isValid||0===t.as("milliseconds"))return[];let n,{s:r}=this,i=1;const a=[];for(;r<this.e;){const e=this.start.plus(t.mapUnits(e=>e*i));n=+e>+this.e?this.e:e,a.push(Rn.fromDateTimes(r,n)),r=n,i+=1}return a}divideEqually(e){return this.isValid?this.splitBy(this.length()/e).slice(0,e):[]}overlaps(e){return this.e>e.s&&this.s<e.e}abutsStart(e){return!!this.isValid&&+this.e===+e.s}abutsEnd(e){return!!this.isValid&&+e.e===+this.s}engulfs(e){return!!this.isValid&&(this.s<=e.s&&this.e>=e.e)}equals(e){return!(!this.isValid||!e.isValid)&&(this.s.equals(e.s)&&this.e.equals(e.e))}intersection(e){if(!this.isValid)return this;const t=this.s>e.s?this.s:e.s,n=this.e<e.e?this.e:e.e;return t>=n?null:Rn.fromDateTimes(t,n)}union(e){if(!this.isValid)return this;const t=this.s<e.s?this.s:e.s,n=this.e>e.e?this.e:e.e;return Rn.fromDateTimes(t,n)}static merge(e){const[t,n]=e.sort((e,t)=>e.s-t.s).reduce(([e,t],n)=>t?t.overlaps(n)||t.abutsStart(n)?[e,t.union(n)]:[e.concat([t]),n]:[e,n],[[],null]);return n&&t.push(n),t}static xor(e){let t=null,n=0;const r=[],i=e.map(e=>[{time:e.s,type:"s"},{time:e.e,type:"e"}]),a=Array.prototype.concat(...i).sort((e,t)=>e.time-t.time);for(const e of a)n+="s"===e.type?1:-1,1===n?t=e.time:(t&&+t!==+e.time&&r.push(Rn.fromDateTimes(t,e.time)),t=null);return Rn.merge(r)}difference(...e){return Rn.xor([this].concat(e)).map(e=>this.intersection(e)).filter(e=>e&&!e.isEmpty())}toString(){return this.isValid?`[${this.s.toISO()}  ${this.e.toISO()})`:Cn}[Symbol.for("nodejs.util.inspect.custom")](){return this.isValid?`Interval { start: ${this.s.toISO()}, end: ${this.e.toISO()} }`:`Interval { Invalid, reason: ${this.invalidReason} }`}toLocaleString(e=K,t={}){return this.isValid?Dt.create(this.s.loc.clone(t),e).formatInterval(this):Cn}toISO(e){return this.isValid?`${this.s.toISO(e)}/${this.e.toISO(e)}`:Cn}toISODate(){return this.isValid?`${this.s.toISODate()}/${this.e.toISODate()}`:Cn}toISOTime(e){return this.isValid?`${this.s.toISOTime(e)}/${this.e.toISOTime(e)}`:Cn}toFormat(e,{separator:t="  "}={}){return this.isValid?`${this.s.toFormat(e)}${t}${this.e.toFormat(e)}`:Cn}toDuration(e,t){return this.isValid?this.e.diff(this.s,e,t):Dn.invalid(this.invalidReason)}mapEndpoints(e){return Rn.fromDateTimes(e(this.s),e(this.e))}}class Pn{static hasDST(e=xe.defaultZone){const t=Ir.now().setZone(e).set({month:12});return!e.isUniversal&&t.offset!==t.set({month:6}).offset}static isValidIANAZone(e){return z.isValidZone(e)}static normalizeZone(e){return he(e,xe.defaultZone)}static getStartOfWeek({locale:e=null,locObj:t=null}={}){return(t||de.create(e)).getStartOfWeek()}static getMinimumDaysInFirstWeek({locale:e=null,locObj:t=null}={}){return(t||de.create(e)).getMinDaysInFirstWeek()}static getWeekendWeekdays({locale:e=null,locObj:t=null}={}){return(t||de.create(e)).getWeekendDays().slice()}static months(e="long",{locale:t=null,numberingSystem:n=null,locObj:r=null,outputCalendar:i="gregory"}={}){return(r||de.create(t,n,i)).months(e)}static monthsFormat(e="long",{locale:t=null,numberingSystem:n=null,locObj:r=null,outputCalendar:i="gregory"}={}){return(r||de.create(t,n,i)).months(e,!0)}static weekdays(e="long",{locale:t=null,numberingSystem:n=null,locObj:r=null}={}){return(r||de.create(t,n,null)).weekdays(e)}static weekdaysFormat(e="long",{locale:t=null,numberingSystem:n=null,locObj:r=null}={}){return(r||de.create(t,n,null)).weekdays(e,!0)}static meridiems({locale:e=null}={}){return de.create(e).meridiems()}static eras(e="short",{locale:t=null}={}){return de.create(t,null,"gregory").eras(e)}static features(){return{relative:Be(),localeWeek:We()}}}function Mn(e,t){const n=e=>e.toUTC(0,{keepLocalTime:!0}).startOf("day").valueOf(),r=n(t)-n(e);return Math.floor(Dn.fromMillis(r).as("days"))}function Nn(e,t,n,r){let[i,a,s,o]=function(e,t,n){const r=[["years",(e,t)=>t.year-e.year],["quarters",(e,t)=>t.quarter-e.quarter+4*(t.year-e.year)],["months",(e,t)=>t.month-e.month+12*(t.year-e.year)],["weeks",(e,t)=>{const n=Mn(e,t);return(n-n%7)/7}],["days",Mn]],i={},a=e;let s,o;for(const[l,d]of r)n.indexOf(l)>=0&&(s=l,i[l]=d(e,t),o=a.plus(i),o>t?(i[l]--,(e=a.plus(i))>t&&(o=e,i[l]--,e=a.plus(i))):e=o);return[e,i,o,s]}(e,t,n);const l=t-i,d=n.filter(e=>["hours","minutes","seconds","milliseconds"].indexOf(e)>=0);0===d.length&&(s<t&&(s=i.plus({[o]:1})),s!==i&&(a[o]=(a[o]||0)+l/(s-i)));const c=Dn.fromObject(a,r);return d.length>0?Dn.fromMillis(l,r).shiftTo(...d).plus(c):c}function Ln(e,t=e=>e){return{regex:e,deser:([e])=>t(function(e){let t=parseInt(e,10);if(isNaN(t)){t="";for(let n=0;n<e.length;n++){const r=e.charCodeAt(n);if(-1!==e[n].search(ye.hanidec))t+=fe.indexOf(e[n]);else for(const e in me){const[n,i]=me[e];r>=n&&r<=i&&(t+=r-n)}}return parseInt(t,10)}return t}(e))}}const Jn=`[ ${String.fromCharCode(160)}]`,_n=new RegExp(Jn,"g");function Fn(e){return e.replace(/\./g,"\\.?").replace(_n,Jn)}function Vn(e){return e.replace(/\./g,"").replace(_n," ").toLowerCase()}function Gn(e,t){return null===e?null:{regex:RegExp(e.map(Fn).join("|")),deser:([n])=>e.findIndex(e=>Vn(n)===Vn(e))+t}}function qn(e,t){return{regex:e,deser:([,e,t])=>ut(e,t),groups:t}}function Yn(e){return{regex:e,deser:([e])=>e}}const Un={year:{"2-digit":"yy",numeric:"yyyyy"},month:{numeric:"M","2-digit":"MM",short:"MMM",long:"MMMM"},day:{numeric:"d","2-digit":"dd"},weekday:{short:"EEE",long:"EEEE"},dayperiod:"a",dayPeriod:"a",hour12:{numeric:"h","2-digit":"hh"},hour24:{numeric:"H","2-digit":"HH"},minute:{numeric:"m","2-digit":"mm"},second:{numeric:"s","2-digit":"ss"},timeZoneName:{long:"ZZZZZ",short:"ZZZ"}};let Bn=null;function Wn(e,t){return Array.prototype.concat(...e.map(e=>function(e,t){if(e.literal)return e;const n=$n(Dt.macroTokenToFormatOpts(e.val),t);return null==n||n.includes(void 0)?e:n}(e,t)))}class zn{constructor(e,t){if(this.locale=e,this.format=t,this.tokens=Wn(Dt.parseFormat(t),e),this.units=this.tokens.map(t=>function(e,t){const n=ge(t),r=ge(t,"{2}"),i=ge(t,"{3}"),a=ge(t,"{4}"),s=ge(t,"{6}"),o=ge(t,"{1,2}"),l=ge(t,"{1,3}"),d=ge(t,"{1,6}"),c=ge(t,"{1,9}"),u=ge(t,"{2,4}"),p=ge(t,"{4,6}"),h=e=>{return{regex:RegExp((t=e.val,t.replace(/[\-\[\]{}()*+?.,\\\^$|#\s]/g,"\\$&"))),deser:([e])=>e,literal:!0};var t},y=(y=>{if(e.literal)return h(y);switch(y.val){case"G":return Gn(t.eras("short"),0);case"GG":return Gn(t.eras("long"),0);case"y":return Ln(d);case"yy":case"kk":return Ln(u,dt);case"yyyy":case"kkkk":return Ln(a);case"yyyyy":return Ln(p);case"yyyyyy":return Ln(s);case"M":case"L":case"d":case"H":case"h":case"m":case"q":case"s":case"W":return Ln(o);case"MM":case"LL":case"dd":case"HH":case"hh":case"mm":case"qq":case"ss":case"WW":return Ln(r);case"MMM":return Gn(t.months("short",!0),1);case"MMMM":return Gn(t.months("long",!0),1);case"LLL":return Gn(t.months("short",!1),1);case"LLLL":return Gn(t.months("long",!1),1);case"o":case"S":return Ln(l);case"ooo":case"SSS":return Ln(i);case"u":return Yn(c);case"uu":return Yn(o);case"uuu":case"E":case"c":return Ln(n);case"a":return Gn(t.meridiems(),0);case"EEE":return Gn(t.weekdays("short",!1),1);case"EEEE":return Gn(t.weekdays("long",!1),1);case"ccc":return Gn(t.weekdays("short",!0),1);case"cccc":return Gn(t.weekdays("long",!0),1);case"Z":case"ZZ":return qn(new RegExp(`([+-]${o.source})(?::(${r.source}))?`),2);case"ZZZ":return qn(new RegExp(`([+-]${o.source})(${r.source})?`),2);case"z":return Yn(/[a-z_+-/]{1,256}?/i);case" ":return Yn(/[^\S\n\r]/);default:return h(y)}})(e)||{invalidReason:"missing Intl.DateTimeFormat.formatToParts support"};return y.token=e,y}(t,e)),this.disqualifyingUnit=this.units.find(e=>e.invalidReason),!this.disqualifyingUnit){const[e,t]=[`^${(n=this.units).map(e=>e.regex).reduce((e,t)=>`${e}(${t.source})`,"")}$`,n];this.regex=RegExp(e,"i"),this.handlers=t}var n}explainFromTokens(e){if(this.isValid){const[t,n]=function(e,t,n){const r=e.match(t);if(r){const e={};let t=1;for(const i in n)if(Qe(n,i)){const a=n[i],s=a.groups?a.groups+1:1;!a.literal&&a.token&&(e[a.token.val[0]]=a.deser(r.slice(t,t+s))),t+=s}return[r,e]}return[r,{}]}(e,this.regex,this.handlers),[r,i,a]=n?function(e){let t,n=null;return qe(e.z)||(n=z.create(e.z)),qe(e.Z)||(n||(n=new ue(e.Z)),t=e.Z),qe(e.q)||(e.M=3*(e.q-1)+1),qe(e.h)||(e.h<12&&1===e.a?e.h+=12:12===e.h&&0===e.a&&(e.h=0)),0===e.G&&e.y&&(e.y=-e.y),qe(e.u)||(e.S=tt(e.u)),[Object.keys(e).reduce((t,n)=>{const r=(e=>{switch(e){case"S":return"millisecond";case"s":return"second";case"m":return"minute";case"h":case"H":return"hour";case"d":return"day";case"o":return"ordinal";case"L":case"M":return"month";case"y":return"year";case"E":case"c":return"weekday";case"W":return"weekNumber";case"k":return"weekYear";case"q":return"quarter";default:return null}})(n);return r&&(t[r]=e[n]),t},{}),n,t]}(n):[null,null,void 0];if(Qe(n,"a")&&Qe(n,"H"))throw new h("Can't include meridiem when specifying 24-hour format");return{input:e,tokens:this.tokens,regex:this.regex,rawMatches:t,matches:n,result:r,zone:i,specificOffset:a}}return{input:e,tokens:this.tokens,invalidReason:this.invalidReason}}get isValid(){return!this.disqualifyingUnit}get invalidReason(){return this.disqualifyingUnit?this.disqualifyingUnit.invalidReason:null}}function Qn(e,t,n){return new zn(e,n).explainFromTokens(t)}function $n(e,t){if(!e)return null;const n=Dt.create(t,e).dtFormatter((Bn||(Bn=Ir.fromMillis(1555555555555)),Bn)),r=n.formatToParts(),i=n.resolvedOptions();return r.map(t=>function(e,t,n){const{type:r,value:i}=e;if("literal"===r){const e=/^\s+$/.test(i);return{literal:!e,val:e?" ":i}}const a=t[r];let s=r;"hour"===r&&(s=null!=t.hour12?t.hour12?"hour12":"hour24":null!=t.hourCycle?"h11"===t.hourCycle||"h12"===t.hourCycle?"hour12":"hour24":n.hour12?"hour12":"hour24");let o=Un[s];if("object"==typeof o&&(o=o[a]),o)return{literal:!1,val:o}}(t,e,i))}const Zn="Invalid DateTime",Hn=864e13;function Xn(e){return new Te("unsupported zone",`the zone "${e.name}" is not supported`)}function er(e){return null===e.weekData&&(e.weekData=Ne(e.c)),e.weekData}function tr(e){return null===e.localWeekData&&(e.localWeekData=Ne(e.c,e.loc.getMinDaysInFirstWeek(),e.loc.getStartOfWeek())),e.localWeekData}function nr(e,t){const n={ts:e.ts,zone:e.zone,c:e.c,o:e.o,loc:e.loc,invalid:e.invalid};return new Ir(l(l(l({},n),t),{},{old:n}))}function rr(e,t,n){let r=e-60*t*1e3;const i=n.offset(r);if(t===i)return[r,t];r-=60*(i-t)*1e3;const a=n.offset(r);return i===a?[r,i]:[e-60*Math.min(i,a)*1e3,Math.max(i,a)]}function ir(e,t){const n=new Date(e+=60*t*1e3);return{year:n.getUTCFullYear(),month:n.getUTCMonth()+1,day:n.getUTCDate(),hour:n.getUTCHours(),minute:n.getUTCMinutes(),second:n.getUTCSeconds(),millisecond:n.getUTCMilliseconds()}}function ar(e,t,n){return rr(st(e),t,n)}function sr(e,t){const n=e.o,r=e.c.year+Math.trunc(t.years),i=e.c.month+Math.trunc(t.months)+3*Math.trunc(t.quarters),a=l(l({},e.c),{},{year:r,month:i,day:Math.min(e.c.day,at(r,i))+Math.trunc(t.days)+7*Math.trunc(t.weeks)}),s=Dn.fromObject({years:t.years-Math.trunc(t.years),quarters:t.quarters-Math.trunc(t.quarters),months:t.months-Math.trunc(t.months),weeks:t.weeks-Math.trunc(t.weeks),days:t.days-Math.trunc(t.days),hours:t.hours,minutes:t.minutes,seconds:t.seconds,milliseconds:t.milliseconds}).as("milliseconds"),o=st(a);let[d,c]=rr(o,n,e.zone);return 0!==s&&(d+=s,c=e.zone.offset(d)),{ts:d,o:c}}function or(e,t,n,r,i,a){const{setZone:s,zone:o}=n;if(e&&0!==Object.keys(e).length||t){const r=t||o,i=Ir.fromObject(e,l(l({},n),{},{zone:r,specificOffset:a}));return s?i:i.setZone(o)}return Ir.invalid(new Te("unparsable",`the input "${i}" can't be parsed as ${r}`))}function lr(e,t,n=!0){return e.isValid?Dt.create(de.create("en-US"),{allowZ:n,forceSimple:!0}).formatDateTimeFromString(e,t):null}function dr(e,t){const n=e.c.year>9999||e.c.year<0;let r="";return n&&e.c.year>=0&&(r+="+"),r+=He(e.c.year,n?6:4),t?(r+="-",r+=He(e.c.month),r+="-",r+=He(e.c.day)):(r+=He(e.c.month),r+=He(e.c.day)),r}function cr(e,t,n,r,i,a){let s=He(e.c.hour);return t?(s+=":",s+=He(e.c.minute),0===e.c.millisecond&&0===e.c.second&&n||(s+=":")):s+=He(e.c.minute),0===e.c.millisecond&&0===e.c.second&&n||(s+=He(e.c.second),0===e.c.millisecond&&r||(s+=".",s+=He(e.c.millisecond,3))),i&&(e.isOffsetFixed&&0===e.offset&&!a?s+="Z":e.o<0?(s+="-",s+=He(Math.trunc(-e.o/60)),s+=":",s+=He(Math.trunc(-e.o%60))):(s+="+",s+=He(Math.trunc(e.o/60)),s+=":",s+=He(Math.trunc(e.o%60)))),a&&(s+="["+e.zone.ianaName+"]"),s}const ur={month:1,day:1,hour:0,minute:0,second:0,millisecond:0},pr={weekNumber:1,weekday:1,hour:0,minute:0,second:0,millisecond:0},hr={ordinal:1,hour:0,minute:0,second:0,millisecond:0},yr=["year","month","day","hour","minute","second","millisecond"],mr=["weekYear","weekNumber","weekday","hour","minute","second","millisecond"],fr=["year","ordinal","hour","minute","second","millisecond"];function br(e){switch(e.toLowerCase()){case"localweekday":case"localweekdays":return"localWeekday";case"localweeknumber":case"localweeknumbers":return"localWeekNumber";case"localweekyear":case"localweekyears":return"localWeekYear";default:return function(e){const t={year:"year",years:"year",month:"month",months:"month",day:"day",days:"day",hour:"hour",hours:"hour",minute:"minute",minutes:"minute",quarter:"quarter",quarters:"quarter",second:"second",seconds:"second",millisecond:"millisecond",milliseconds:"millisecond",weekday:"weekday",weekdays:"weekday",weeknumber:"weekNumber",weeksnumber:"weekNumber",weeknumbers:"weekNumber",weekyear:"weekYear",weekyears:"weekYear",ordinal:"ordinal"}[e.toLowerCase()];if(!t)throw new y(e);return t}(e)}}function gr(e,t){const n=he(t.zone,xe.defaultZone);if(!n.isValid)return Ir.invalid(Xn(n));const r=de.fromObject(t);let i,a;if(qe(e.year))i=xe.now();else{for(const t of yr)qe(e[t])&&(e[t]=ur[t]);const t=Ve(e)||Ge(e);if(t)return Ir.invalid(t);const r=function(e){if(void 0===Er&&(Er=xe.now()),"iana"!==e.type)return e.offset(Er);const t=e.name;let n=Sr.get(t);return void 0===n&&(n=e.offset(Er),Sr.set(t,n)),n}(n);[i,a]=ar(e,r,n)}return new Ir({ts:i,zone:n,loc:r,o:a})}function vr(e,t,n){const r=!!qe(n.round)||n.round,i=(e,i)=>{e=nt(e,r||n.calendary?0:2,!0);return t.loc.clone(n).relFormatter(n).format(e,i)},a=r=>n.calendary?t.hasSame(e,r)?0:t.startOf(r).diff(e.startOf(r),r).get(r):t.diff(e,r).get(r);if(n.unit)return i(a(n.unit),n.unit);for(const e of n.units){const t=a(e);if(Math.abs(t)>=1)return i(t,e)}return i(e>t?-0:0,n.units[n.units.length-1])}function Kr(e){let t,n={};return e.length>0&&"object"==typeof e[e.length-1]?(n=e[e.length-1],t=Array.from(e).slice(0,e.length-1)):t=Array.from(e),[n,t]}let Er;const Sr=new Map;class Ir{constructor(e){const t=e.zone||xe.defaultZone;let n=e.invalid||(Number.isNaN(e.ts)?new Te("invalid input"):null)||(t.isValid?null:Xn(t));this.ts=qe(e.ts)?xe.now():e.ts;let r=null,i=null;if(!n){if(e.old&&e.old.ts===this.ts&&e.old.zone.equals(t))[r,i]=[e.old.c,e.old.o];else{const a=Ye(e.o)&&!e.old?e.o:t.offset(this.ts);r=ir(this.ts,a),n=Number.isNaN(r.year)?new Te("invalid input"):null,r=n?null:r,i=n?null:a}}this._zone=t,this.loc=e.loc||de.create(),this.invalid=n,this.weekData=null,this.localWeekData=null,this.c=r,this.o=i,this.isLuxonDateTime=!0}static now(){return new Ir({})}static local(){const[e,t]=Kr(arguments),[n,r,i,a,s,o,l]=t;return gr({year:n,month:r,day:i,hour:a,minute:s,second:o,millisecond:l},e)}static utc(){const[e,t]=Kr(arguments),[n,r,i,a,s,o,l]=t;return e.zone=ue.utcInstance,gr({year:n,month:r,day:i,hour:a,minute:s,second:o,millisecond:l},e)}static fromJSDate(e,t={}){const n=(r=e,"[object Date]"===Object.prototype.toString.call(r)?e.valueOf():NaN);var r;if(Number.isNaN(n))return Ir.invalid("invalid input");const i=he(t.zone,xe.defaultZone);return i.isValid?new Ir({ts:n,zone:i,loc:de.fromObject(t)}):Ir.invalid(Xn(i))}static fromMillis(e,t={}){if(Ye(e))return e<-Hn||e>Hn?Ir.invalid("Timestamp out of range"):new Ir({ts:e,zone:he(t.zone,xe.defaultZone),loc:de.fromObject(t)});throw new m(`fromMillis requires a numerical input, but received a ${typeof e} with value ${e}`)}static fromSeconds(e,t={}){if(Ye(e))return new Ir({ts:1e3*e,zone:he(t.zone,xe.defaultZone),loc:de.fromObject(t)});throw new m("fromSeconds requires a numerical input")}static fromObject(e,t={}){e=e||{};const n=he(t.zone,xe.defaultZone);if(!n.isValid)return Ir.invalid(Xn(n));const r=de.fromObject(t),i=ht(e,br),{minDaysInFirstWeek:a,startOfWeek:s}=Fe(i,r),o=xe.now(),l=qe(t.specificOffset)?n.offset(o):t.specificOffset,d=!qe(i.ordinal),c=!qe(i.year),u=!qe(i.month)||!qe(i.day),p=c||u,y=i.weekYear||i.weekNumber;if((p||d)&&y)throw new h("Can't mix weekYear/weekNumber units with year/month/day or ordinals");if(u&&d)throw new h("Can't mix ordinal dates with month/day");const m=y||i.weekday&&!p;let f,b,g=ir(o,l);m?(f=mr,b=pr,g=Ne(g,a,s)):d?(f=fr,b=hr,g=Je(g)):(f=yr,b=ur);let v=!1;for(const e of f){qe(i[e])?i[e]=v?b[e]:g[e]:v=!0}const K=m?function(e,t=4,n=1){const r=Ue(e.weekYear),i=Ze(e.weekNumber,1,lt(e.weekYear,t,n)),a=Ze(e.weekday,1,7);return r?i?!a&&De("weekday",e.weekday):De("week",e.weekNumber):De("weekYear",e.weekYear)}(i,a,s):d?function(e){const t=Ue(e.year),n=Ze(e.ordinal,1,it(e.year));return t?!n&&De("ordinal",e.ordinal):De("year",e.year)}(i):Ve(i),E=K||Ge(i);if(E)return Ir.invalid(E);const S=m?Le(i,a,s):d?_e(i):i,[I,w]=ar(S,l,n),k=new Ir({ts:I,zone:n,o:w,loc:r});return i.weekday&&p&&e.weekday!==k.weekday?Ir.invalid("mismatched weekday",`you can't specify both a weekday of ${i.weekday} and a date of ${k.toISO()}`):k.isValid?k:Ir.invalid(k.invalid)}static fromISO(e,t={}){const[n,r]=function(e){return Mt(e,[ln,pn],[dn,hn],[cn,yn],[un,mn])}(e);return or(n,r,t,"ISO 8601",e)}static fromRFC2822(e,t={}){const[n,r]=function(e){return Mt(function(e){return e.replace(/\([^()]*\)|[\n\t]/g," ").replace(/(\s\s+)/g," ").trim()}(e),[en,tn])}(e);return or(n,r,t,"RFC 2822",e)}static fromHTTP(e,t={}){const[n,r]=function(e){return Mt(e,[nn,sn],[rn,sn],[an,on])}(e);return or(n,r,t,"HTTP",t)}static fromFormat(e,t,n={}){if(qe(e)||qe(t))throw new m("fromFormat requires an input string and a format");const{locale:r=null,numberingSystem:i=null}=n,a=de.fromOpts({locale:r,numberingSystem:i,defaultToEN:!0}),[s,o,l,d]=function(e,t,n){const{result:r,zone:i,specificOffset:a,invalidReason:s}=Qn(e,t,n);return[r,i,a,s]}(a,e,t);return d?Ir.invalid(d):or(s,o,n,`format ${t}`,e,l)}static fromString(e,t,n={}){return Ir.fromFormat(e,t,n)}static fromSQL(e,t={}){const[n,r]=function(e){return Mt(e,[bn,pn],[gn,vn])}(e);return or(n,r,t,"SQL",e)}static invalid(e,t=null){if(!e)throw new m("need to specify a reason the DateTime is invalid");const n=e instanceof Te?e:new Te(e,t);if(xe.throwOnInvalid)throw new c(n);return new Ir({invalid:n})}static isDateTime(e){return e&&e.isLuxonDateTime||!1}static parseFormatForOpts(e,t={}){const n=$n(e,de.fromObject(t));return n?n.map(e=>e?e.val:null).join(""):null}static expandFormat(e,t={}){return Wn(Dt.parseFormat(e),de.fromObject(t)).map(e=>e.val).join("")}static resetCache(){Er=void 0,Sr.clear()}get(e){return this[e]}get isValid(){return null===this.invalid}get invalidReason(){return this.invalid?this.invalid.reason:null}get invalidExplanation(){return this.invalid?this.invalid.explanation:null}get locale(){return this.isValid?this.loc.locale:null}get numberingSystem(){return this.isValid?this.loc.numberingSystem:null}get outputCalendar(){return this.isValid?this.loc.outputCalendar:null}get zone(){return this._zone}get zoneName(){return this.isValid?this.zone.name:null}get year(){return this.isValid?this.c.year:NaN}get quarter(){return this.isValid?Math.ceil(this.c.month/3):NaN}get month(){return this.isValid?this.c.month:NaN}get day(){return this.isValid?this.c.day:NaN}get hour(){return this.isValid?this.c.hour:NaN}get minute(){return this.isValid?this.c.minute:NaN}get second(){return this.isValid?this.c.second:NaN}get millisecond(){return this.isValid?this.c.millisecond:NaN}get weekYear(){return this.isValid?er(this).weekYear:NaN}get weekNumber(){return this.isValid?er(this).weekNumber:NaN}get weekday(){return this.isValid?er(this).weekday:NaN}get isWeekend(){return this.isValid&&this.loc.getWeekendDays().includes(this.weekday)}get localWeekday(){return this.isValid?tr(this).weekday:NaN}get localWeekNumber(){return this.isValid?tr(this).weekNumber:NaN}get localWeekYear(){return this.isValid?tr(this).weekYear:NaN}get ordinal(){return this.isValid?Je(this.c).ordinal:NaN}get monthShort(){return this.isValid?Pn.months("short",{locObj:this.loc})[this.month-1]:null}get monthLong(){return this.isValid?Pn.months("long",{locObj:this.loc})[this.month-1]:null}get weekdayShort(){return this.isValid?Pn.weekdays("short",{locObj:this.loc})[this.weekday-1]:null}get weekdayLong(){return this.isValid?Pn.weekdays("long",{locObj:this.loc})[this.weekday-1]:null}get offset(){return this.isValid?+this.o:NaN}get offsetNameShort(){return this.isValid?this.zone.offsetName(this.ts,{format:"short",locale:this.locale}):null}get offsetNameLong(){return this.isValid?this.zone.offsetName(this.ts,{format:"long",locale:this.locale}):null}get isOffsetFixed(){return this.isValid?this.zone.isUniversal:null}get isInDST(){return!this.isOffsetFixed&&(this.offset>this.set({month:1,day:1}).offset||this.offset>this.set({month:5}).offset)}getPossibleOffsets(){if(!this.isValid||this.isOffsetFixed)return[this];const e=864e5,t=6e4,n=st(this.c),r=this.zone.offset(n-e),i=this.zone.offset(n+e),a=this.zone.offset(n-r*t),s=this.zone.offset(n-i*t);if(a===s)return[this];const o=n-a*t,l=n-s*t,d=ir(o,a),c=ir(l,s);return d.hour===c.hour&&d.minute===c.minute&&d.second===c.second&&d.millisecond===c.millisecond?[nr(this,{ts:o}),nr(this,{ts:l})]:[this]}get isInLeapYear(){return rt(this.year)}get daysInMonth(){return at(this.year,this.month)}get daysInYear(){return this.isValid?it(this.year):NaN}get weeksInWeekYear(){return this.isValid?lt(this.weekYear):NaN}get weeksInLocalWeekYear(){return this.isValid?lt(this.localWeekYear,this.loc.getMinDaysInFirstWeek(),this.loc.getStartOfWeek()):NaN}resolvedLocaleOptions(e={}){const{locale:t,numberingSystem:n,calendar:r}=Dt.create(this.loc.clone(e),e).resolvedOptions(this);return{locale:t,numberingSystem:n,outputCalendar:r}}toUTC(e=0,t={}){return this.setZone(ue.instance(e),t)}toLocal(){return this.setZone(xe.defaultZone)}setZone(e,{keepLocalTime:t=!1,keepCalendarTime:n=!1}={}){if((e=he(e,xe.defaultZone)).equals(this.zone))return this;if(e.isValid){let r=this.ts;if(t||n){const t=e.offset(this.ts),n=this.toObject();[r]=ar(n,t,e)}return nr(this,{ts:r,zone:e})}return Ir.invalid(Xn(e))}reconfigure({locale:e,numberingSystem:t,outputCalendar:n}={}){return nr(this,{loc:this.loc.clone({locale:e,numberingSystem:t,outputCalendar:n})})}setLocale(e){return this.reconfigure({locale:e})}set(e){if(!this.isValid)return this;const t=ht(e,br),{minDaysInFirstWeek:n,startOfWeek:r}=Fe(t,this.loc),i=!qe(t.weekYear)||!qe(t.weekNumber)||!qe(t.weekday),a=!qe(t.ordinal),s=!qe(t.year),o=!qe(t.month)||!qe(t.day),d=s||o,c=t.weekYear||t.weekNumber;if((d||a)&&c)throw new h("Can't mix weekYear/weekNumber units with year/month/day or ordinals");if(o&&a)throw new h("Can't mix ordinal dates with month/day");let u;i?u=Le(l(l({},Ne(this.c,n,r)),t),n,r):qe(t.ordinal)?(u=l(l({},this.toObject()),t),qe(t.day)&&(u.day=Math.min(at(u.year,u.month),u.day))):u=_e(l(l({},Je(this.c)),t));const[p,y]=ar(u,this.o,this.zone);return nr(this,{ts:p,o:y})}plus(e){if(!this.isValid)return this;return nr(this,sr(this,Dn.fromDurationLike(e)))}minus(e){if(!this.isValid)return this;return nr(this,sr(this,Dn.fromDurationLike(e).negate()))}startOf(e,{useLocaleWeeks:t=!1}={}){if(!this.isValid)return this;const n={},r=Dn.normalizeUnit(e);switch(r){case"years":n.month=1;case"quarters":case"months":n.day=1;case"weeks":case"days":n.hour=0;case"hours":n.minute=0;case"minutes":n.second=0;case"seconds":n.millisecond=0}if("weeks"===r)if(t){const e=this.loc.getStartOfWeek(),{weekday:t}=this;t<e&&(n.weekNumber=this.weekNumber-1),n.weekday=e}else n.weekday=1;if("quarters"===r){const e=Math.ceil(this.month/3);n.month=3*(e-1)+1}return this.set(n)}endOf(e,t){return this.isValid?this.plus({[e]:1}).startOf(e,t).minus(1):this}toFormat(e,t={}){return this.isValid?Dt.create(this.loc.redefaultToEN(t)).formatDateTimeFromString(this,e):Zn}toLocaleString(e=K,t={}){return this.isValid?Dt.create(this.loc.clone(t),e).formatDateTime(this):Zn}toLocaleParts(e={}){return this.isValid?Dt.create(this.loc.clone(e),e).formatDateTimeParts(this):[]}toISO({format:e="extended",suppressSeconds:t=!1,suppressMilliseconds:n=!1,includeOffset:r=!0,extendedZone:i=!1}={}){if(!this.isValid)return null;const a="extended"===e;let s=dr(this,a);return s+="T",s+=cr(this,a,t,n,r,i),s}toISODate({format:e="extended"}={}){return this.isValid?dr(this,"extended"===e):null}toISOWeekDate(){return lr(this,"kkkk-'W'WW-c")}toISOTime({suppressMilliseconds:e=!1,suppressSeconds:t=!1,includeOffset:n=!0,includePrefix:r=!1,extendedZone:i=!1,format:a="extended"}={}){if(!this.isValid)return null;return(r?"T":"")+cr(this,"extended"===a,t,e,n,i)}toRFC2822(){return lr(this,"EEE, dd LLL yyyy HH:mm:ss ZZZ",!1)}toHTTP(){return lr(this.toUTC(),"EEE, dd LLL yyyy HH:mm:ss 'GMT'")}toSQLDate(){return this.isValid?dr(this,!0):null}toSQLTime({includeOffset:e=!0,includeZone:t=!1,includeOffsetSpace:n=!0}={}){let r="HH:mm:ss.SSS";return(t||e)&&(n&&(r+=" "),t?r+="z":e&&(r+="ZZ")),lr(this,r,!0)}toSQL(e={}){return this.isValid?`${this.toSQLDate()} ${this.toSQLTime(e)}`:null}toString(){return this.isValid?this.toISO():Zn}[Symbol.for("nodejs.util.inspect.custom")](){return this.isValid?`DateTime { ts: ${this.toISO()}, zone: ${this.zone.name}, locale: ${this.locale} }`:`DateTime { Invalid, reason: ${this.invalidReason} }`}valueOf(){return this.toMillis()}toMillis(){return this.isValid?this.ts:NaN}toSeconds(){return this.isValid?this.ts/1e3:NaN}toUnixInteger(){return this.isValid?Math.floor(this.ts/1e3):NaN}toJSON(){return this.toISO()}toBSON(){return this.toJSDate()}toObject(e={}){if(!this.isValid)return{};const t=l({},this.c);return e.includeConfig&&(t.outputCalendar=this.outputCalendar,t.numberingSystem=this.loc.numberingSystem,t.locale=this.loc.locale),t}toJSDate(){return new Date(this.isValid?this.ts:NaN)}diff(e,t="milliseconds",n={}){if(!this.isValid||!e.isValid)return Dn.invalid("created by diffing an invalid DateTime");const r=l({locale:this.locale,numberingSystem:this.numberingSystem},n),i=(o=t,Array.isArray(o)?o:[o]).map(Dn.normalizeUnit),a=e.valueOf()>this.valueOf(),s=Nn(a?this:e,a?e:this,i,r);var o;return a?s.negate():s}diffNow(e="milliseconds",t={}){return this.diff(Ir.now(),e,t)}until(e){return this.isValid?Rn.fromDateTimes(this,e):this}hasSame(e,t,n){if(!this.isValid)return!1;const r=e.valueOf(),i=this.setZone(e.zone,{keepLocalTime:!0});return i.startOf(t,n)<=r&&r<=i.endOf(t,n)}equals(e){return this.isValid&&e.isValid&&this.valueOf()===e.valueOf()&&this.zone.equals(e.zone)&&this.loc.equals(e.loc)}toRelative(e={}){if(!this.isValid)return null;const t=e.base||Ir.fromObject({},{zone:this.zone}),n=e.padding?this<t?-e.padding:e.padding:0;let r=["years","months","days","hours","minutes","seconds"],i=e.unit;return Array.isArray(e.unit)&&(r=e.unit,i=void 0),vr(t,this.plus(n),l(l({},e),{},{numeric:"always",units:r,unit:i}))}toRelativeCalendar(e={}){return this.isValid?vr(e.base||Ir.fromObject({},{zone:this.zone}),this,l(l({},e),{},{numeric:"auto",units:["years","months","days"],calendary:!0})):null}static min(...e){if(!e.every(Ir.isDateTime))throw new m("min requires all arguments be DateTimes");return ze(e,e=>e.valueOf(),Math.min)}static max(...e){if(!e.every(Ir.isDateTime))throw new m("max requires all arguments be DateTimes");return ze(e,e=>e.valueOf(),Math.max)}static fromFormatExplain(e,t,n={}){const{locale:r=null,numberingSystem:i=null}=n;return Qn(de.fromOpts({locale:r,numberingSystem:i,defaultToEN:!0}),e,t)}static fromStringExplain(e,t,n={}){return Ir.fromFormatExplain(e,t,n)}static buildFormatParser(e,t={}){const{locale:n=null,numberingSystem:r=null}=t,i=de.fromOpts({locale:n,numberingSystem:r,defaultToEN:!0});return new zn(i,e)}static fromFormatParser(e,t,n={}){if(qe(e)||qe(t))throw new m("fromFormatParser requires an input string and a format parser");const{locale:r=null,numberingSystem:i=null}=n,a=de.fromOpts({locale:r,numberingSystem:i,defaultToEN:!0});if(!a.equals(t.locale))throw new m(`fromFormatParser called with a locale of ${a}, but the format parser was created for ${t.locale}`);const{result:s,zone:o,specificOffset:l,invalidReason:d}=t.explainFromTokens(e);return d?Ir.invalid(d):or(s,o,n,`format ${t.format}`,e,l)}static get DATE_SHORT(){return K}static get DATE_MED(){return E}static get DATE_MED_WITH_WEEKDAY(){return S}static get DATE_FULL(){return I}static get DATE_HUGE(){return w}static get TIME_SIMPLE(){return k}static get TIME_WITH_SECONDS(){return j}static get TIME_WITH_SHORT_OFFSET(){return x}static get TIME_WITH_LONG_OFFSET(){return T}static get TIME_24_SIMPLE(){return A}static get TIME_24_WITH_SECONDS(){return O}static get TIME_24_WITH_SHORT_OFFSET(){return D}static get TIME_24_WITH_LONG_OFFSET(){return C}static get DATETIME_SHORT(){return R}static get DATETIME_SHORT_WITH_SECONDS(){return P}static get DATETIME_MED(){return M}static get DATETIME_MED_WITH_SECONDS(){return N}static get DATETIME_MED_WITH_WEEKDAY(){return L}static get DATETIME_FULL(){return J}static get DATETIME_FULL_WITH_SECONDS(){return _}static get DATETIME_HUGE(){return F}static get DATETIME_HUGE_WITH_SECONDS(){return V}}function wr(e){if(Ir.isDateTime(e))return e;if(e&&e.valueOf&&Ye(e.valueOf()))return Ir.fromJSDate(e);if(e&&"object"==typeof e)return Ir.fromObject(e);throw new m(`Unknown datetime argument: ${e}, of type ${typeof e}`)}t.DateTime=Ir,t.Duration=Dn,t.FixedOffsetZone=ue,t.IANAZone=z,t.Info=Pn,t.Interval=Rn,t.InvalidZone=pe,t.Settings=xe,t.SystemZone=Y,t.VERSION="3.6.1",t.Zone=G},(e,t,n)=>{var r=n(212);e.exports=function(e,t){if(null==e)return{};var n,i,a=r(e,t);if(Object.getOwnPropertySymbols){var s=Object.getOwnPropertySymbols(e);for(i=0;i<s.length;i++)n=s[i],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(a[n]=e[n])}return a},e.exports.__esModule=!0,e.exports.default=e.exports},e=>{e.exports=function(e,t){if(null==e)return{};var n,r,i={},a=Object.keys(e);for(r=0;r<a.length;r++)n=a[r],t.indexOf(n)>=0||(i[n]=e[n]);return i},e.exports.__esModule=!0,e.exports.default=e.exports},(e,t,n)=>{"use strict";var r=n(214);e.exports=function(e,t,n){var i=r(e);if(1===i.length){var a=i[0];if(1===(c=a.step)&&a.start===t&&a.end===n)return"*";if(1!==c&&a.start===t&&a.end===n-c+1)return"*/"+c}for(var s=[],o=0,l=i.length;o<l;++o){var d=i[o];if(1!==d.count){var c=d.step;if(1!==d.step){var u=0==d.start?d.count-1:d.count;d.step*u>d.end?s=s.concat(Array.from({length:d.end-d.start+1}).map(function(e,t){var n=d.start+t;return(n-d.start)%d.step===0?n:null}).filter(function(e){return null!=e})):d.end===n-d.step+1?s.push(d.start+"/"+d.step):s.push(d.start+"-"+d.end+"/"+d.step)}else s.push(d.start+"-"+d.end)}else s.push(d.start)}return s.join(",")}},e=>{"use strict";function t(e){return{start:e,count:1}}function n(e,t){e.end=t,e.step=t-e.start,e.count=2}function r(e,n,r){n&&(2===n.count?(e.push(t(n.start)),e.push(t(n.end))):e.push(n)),r&&e.push(r)}e.exports=function(e){for(var i=[],a=void 0,s=0;s<e.length;s++){var o=e[s];"number"!=typeof o?(r(i,a,t(o)),a=void 0):a?1===a.count?n(a,o):a.step===o-a.end?(a.count++,a.end=o):2===a.count?(i.push(t(a.start)),n(a=t(a.end),o)):(r(i,a),a=t(o)):a=t(o)}return r(i,a),i}},()=>{},(e,t,n)=>{"use strict";n.r(t),n.d(t,{QueueBase:()=>l});var r=n(14),i=n(18),a=n(150),s=n(147),o=n(149);class l extends r.EventEmitter{constructor(e,t={connection:{}},n=a.RedisConnection,r=!1){if(super(),this.name=e,this.opts=t,this.closed=!1,this.hasBlockingConnection=!1,this.hasBlockingConnection=r,this.opts=Object.assign({prefix:"bull"},t),!e)throw new Error("Queue name must be provided");if(e.includes(":"))throw new Error("Queue name cannot contain :");this.connection=new n(t.connection,{shared:(0,i.isRedisInstance)(t.connection),blocking:r,skipVersionCheck:t.skipVersionCheck,skipWaitingForReady:t.skipWaitingForReady}),this.connection.on("error",e=>this.emit("error",e)),this.connection.on("close",()=>{this.closing||this.emit("ioredis:close")});const s=new o.QueueKeys(t.prefix);this.qualifiedName=s.getQueueQualifiedName(e),this.keys=s.getKeys(e),this.toKey=t=>s.toKey(e,t),this.createScripts()}get client(){return this.connection.client}createScripts(){this.scripts=(0,i.createScripts)(this)}get redisVersion(){return this.connection.redisVersion}get Job(){return s.Job}emit(e,...t){try{return super.emit(e,...t)}catch(e){try{return super.emit("error",e)}catch(e){return console.error(e),!1}}}waitUntilReady(){return this.client}base64Name(){return Buffer.from(this.name).toString("base64")}clientName(e=""){const t=this.base64Name();return`${this.opts.prefix}:${t}${e}`}async close(){this.closing||(this.closing=this.connection.close()),await this.closing,this.closed=!0}disconnect(){return this.connection.disconnect()}async checkConnectionError(e,t=i.DELAY_TIME_5){try{return await e()}catch(e){if((0,i.isNotConnectionError)(e)&&this.emit("error",e),this.closing||!t)return;await(0,i.delay)(t)}}trace(e,t,n,r,a){return(0,i.trace)(this.opts.telemetry,e,this.name,t,n,r,a)}}},(e,t,n)=>{"use strict";n.r(t),n.d(t,{QueueEvents:()=>s});var r=n(148),i=n(18),a=n(216);class s extends a.QueueBase{constructor(e,t={connection:{}},n){var{connection:a,autorun:s=!0}=t,o=(0,r.__rest)(t,["connection","autorun"]);super(e,Object.assign(Object.assign({},o),{connection:(0,i.isRedisInstance)(a)?a.duplicate():a}),n,!0),this.running=!1,this.opts=Object.assign({blockingTimeout:1e4},this.opts),s&&this.run().catch(e=>this.emit("error",e))}emit(e,...t){return super.emit(e,...t)}off(e,t){return super.off(e,t),this}on(e,t){return super.on(e,t),this}once(e,t){return super.once(e,t),this}async run(){if(this.running)throw new Error("Queue Events is already running.");try{this.running=!0;const e=await this.client;try{await e.client("SETNAME",this.clientName(i.QUEUE_EVENT_SUFFIX))}catch(e){if(!i.clientCommandMessageReg.test(e.message))throw e}await this.consumeEvents(e)}catch(e){throw this.running=!1,e}}async consumeEvents(e){const t=this.opts,n=this.keys.events;let a=t.lastEventId||"$";for(;!this.closing;){const s=await this.checkConnectionError(()=>e.xread("BLOCK",t.blockingTimeout,"STREAMS",n,a));if(s){const e=s[0][1];for(let t=0;t<e.length;t++){a=e[t][0];const n=(0,i.array2obj)(e[t][1]);switch(n.event){case"progress":n.data=JSON.parse(n.data);break;case"completed":n.returnvalue=JSON.parse(n.returnvalue)}const{event:s}=n,o=(0,r.__rest)(n,["event"]);"drained"===s?this.emit(s,a):(this.emit(s,o,a),o.jobId&&this.emit(`${s}:${o.jobId}`,o,a))}}}}close(){return this.closing||(this.closing=this.disconnect()),this.closing}}},(e,t,n)=>{"use strict";n.r(t),n.d(t,{QueueEventsProducer:()=>a});var r=n(148),i=n(216);class a extends i.QueueBase{constructor(e,t={connection:{}},n){super(e,Object.assign({blockingConnection:!1},t),n),this.opts=t}async publishEvent(e,t=1e3){const n=await this.client,i=this.keys.events,{eventName:a}=e,s=(0,r.__rest)(e,["eventName"]),o=["MAXLEN","~",t,"*","event",a];for(const[e,t]of Object.entries(s))o.push(e,t);await n.xadd(i,...o)}async close(){this.closing||(this.closing=this.connection.close()),await this.closing}}},(e,t,n)=>{"use strict";n.r(t),n.d(t,{QueueGetters:()=>a});var r=n(216),i=n(18);class a extends r.QueueBase{getJob(e){return this.Job.fromId(this,e)}commandByType(e,t,n){return e.map(e=>{e="waiting"===e?"wait":e;const r=this.toKey(e);switch(e){case"completed":case"failed":case"delayed":case"prioritized":case"repeat":case"waiting-children":return n(r,t?"zcard":"zrange");case"active":case"wait":case"paused":return n(r,t?"llen":"lrange")}})}sanitizeJobTypes(e){const t="string"==typeof e?[e]:e;if(Array.isArray(t)&&t.length>0){const e=[...t];return-1!==e.indexOf("waiting")&&e.push("paused"),[...new Set(e)]}return["active","completed","delayed","failed","paused","prioritized","waiting","waiting-children"]}async count(){return await this.getJobCountByTypes("waiting","paused","delayed","prioritized","waiting-children")}async getRateLimitTtl(e){return this.scripts.getRateLimitTtl(e)}async getDebounceJobId(e){return(await this.client).get(`${this.keys.de}:${e}`)}async getDeduplicationJobId(e){return(await this.client).get(`${this.keys.de}:${e}`)}async getJobCountByTypes(...e){const t=await this.getJobCounts(...e);return Object.values(t).reduce((e,t)=>e+t,0)}async getJobCounts(...e){const t=this.sanitizeJobTypes(e),n=await this.scripts.getCounts(t),r={};return n.forEach((e,n)=>{r[t[n]]=e||0}),r}getJobState(e){return this.scripts.getState(e)}getCompletedCount(){return this.getJobCountByTypes("completed")}getFailedCount(){return this.getJobCountByTypes("failed")}getDelayedCount(){return this.getJobCountByTypes("delayed")}getActiveCount(){return this.getJobCountByTypes("active")}getPrioritizedCount(){return this.getJobCountByTypes("prioritized")}async getCountsPerPriority(e){const t=[...new Set(e)],n=await this.scripts.getCountsPerPriority(t),r={};return n.forEach((e,n)=>{r[`${t[n]}`]=e||0}),r}getWaitingCount(){return this.getJobCountByTypes("waiting")}getWaitingChildrenCount(){return this.getJobCountByTypes("waiting-children")}getWaiting(e=0,t=-1){return this.getJobs(["waiting"],e,t,!0)}getWaitingChildren(e=0,t=-1){return this.getJobs(["waiting-children"],e,t,!0)}getActive(e=0,t=-1){return this.getJobs(["active"],e,t,!0)}getDelayed(e=0,t=-1){return this.getJobs(["delayed"],e,t,!0)}getPrioritized(e=0,t=-1){return this.getJobs(["prioritized"],e,t,!0)}getCompleted(e=0,t=-1){return this.getJobs(["completed"],e,t,!1)}getFailed(e=0,t=-1){return this.getJobs(["failed"],e,t,!1)}async getDependencies(e,t,n,r){const i=this.toKey("processed"==t?`${e}:processed`:`${e}:dependencies`),{items:a,total:s,jobs:o}=await this.scripts.paginate(i,{start:n,end:r,fetchJobs:!0});return{items:a,jobs:o,total:s}}async getRanges(e,t=0,n=1,r=!1){const i=[];this.commandByType(e,!1,(e,t)=>{switch(t){case"lrange":i.push("lrange");break;case"zrange":i.push("zrange")}});const a=await this.scripts.getRanges(e,t,n,r);let s=[];return a.forEach((e,t)=>{const n=e||[];s=r&&"lrange"===i[t]?s.concat(n.reverse()):s.concat(n)}),[...new Set(s)]}async getJobs(e,t=0,n=-1,r=!1){const i=this.sanitizeJobTypes(e),a=await this.getRanges(i,t,n,r);return Promise.all(a.map(e=>this.Job.fromId(this,e)))}async getJobLogs(e,t=0,n=-1,r=!0){const i=(await this.client).multi(),a=this.toKey(e+":logs");r?i.lrange(a,t,n):i.lrange(a,-(n+1),-(t+1)),i.llen(a);const s=await i.exec();return r||s[0][1].reverse(),{logs:s[0][1],count:s[1][1]}}async baseGetClients(e){const t=await this.client;try{const n=await t.client("LIST");return this.parseClientList(n,e)}catch(e){if(!i.clientCommandMessageReg.test(e.message))throw e;return[{name:"GCP does not support client list"}]}}getWorkers(){const e=`${this.clientName()}`,t=`${this.clientName()}:w:`;return this.baseGetClients(n=>n&&(n===e||n.startsWith(t)))}async getWorkersCount(){return(await this.getWorkers()).length}async getQueueEvents(){const e=`${this.clientName()}${i.QUEUE_EVENT_SUFFIX}`;return this.baseGetClients(t=>t===e)}async getMetrics(e,t=0,n=-1){const r=await this.client,i=this.toKey(`metrics:${e}`),a=`${i}:data`,s=r.multi();s.hmget(i,"count","prevTS","prevCount"),s.lrange(a,t,n),s.llen(a);const[o,l,d]=await s.exec(),[c,[u,p,h]]=o,[y,m]=l,[f,b]=d;if(c||y)throw c||y||f;return{meta:{count:parseInt(u||"0",10),prevTS:parseInt(p||"0",10),prevCount:parseInt(h||"0",10)},data:m,count:b}}parseClientList(e,t){const n=e.split(/\r?\n/),r=[];return n.forEach(e=>{const n={};e.split(" ").forEach(function(e){const t=e.indexOf("="),r=e.substring(0,t),i=e.substring(t+1);n[r]=i});const i=n.name;t(i)&&(n.name=this.name,n.rawname=i,r.push(n))}),r}async exportPrometheusMetrics(e){const t=await this.getJobCounts(),n=[];n.push("# HELP bullmq_job_count Number of jobs in the queue by state"),n.push("# TYPE bullmq_job_count gauge");const r=e?Object.keys(e).reduce((t,n)=>`${t}, ${n}="${e[n]}"`,""):"";for(const[e,i]of Object.entries(t))n.push(`bullmq_job_count{queue="${this.name}", state="${e}"${r}} ${i}`);return n.join("\n")}}},(e,t,n)=>{"use strict";n.r(t),n.d(t,{Queue:()=>c});var r=n(200),i=n(147),a=n(219),s=n(221),o=n(8),l=n(206),d=n(93);class c extends a.QueueGetters{constructor(e,t,n){var i;super(e,Object.assign({},t),n),this.token=(0,r.default)(),this.libName="bullmq",this.jobsOpts=null!==(i=null==t?void 0:t.defaultJobOptions)&&void 0!==i?i:{},this.waitUntilReady().then(e=>{if(!this.closing&&!(null==t?void 0:t.skipMetasUpdate))return e.hmset(this.keys.meta,this.metaValues)}).catch(e=>{})}emit(e,...t){return super.emit(e,...t)}off(e,t){return super.off(e,t),this}on(e,t){return super.on(e,t),this}once(e,t){return super.once(e,t),this}get defaultJobOptions(){return Object.assign({},this.jobsOpts)}get metaValues(){var e,t,n,r;return{"opts.maxLenEvents":null!==(r=null===(n=null===(t=null===(e=this.opts)||void 0===e?void 0:e.streams)||void 0===t?void 0:t.events)||void 0===n?void 0:n.maxLen)&&void 0!==r?r:1e4,version:`${this.libName}:${d.version}`}}async getVersion(){const e=await this.client;return await e.hget(this.keys.meta,"version")}get repeat(){return new Promise(async e=>{this._repeat||(this._repeat=new s.Repeat(this.name,Object.assign(Object.assign({},this.opts),{connection:await this.client})),this._repeat.on("error",e=>this.emit.bind(this,e))),e(this._repeat)})}get jobScheduler(){return new Promise(async e=>{this._jobScheduler||(this._jobScheduler=new l.JobScheduler(this.name,Object.assign(Object.assign({},this.opts),{connection:await this.client})),this._jobScheduler.on("error",e=>this.emit.bind(this,e))),e(this._jobScheduler)})}async getGlobalConcurrency(){const e=await this.client,t=await e.hget(this.keys.meta,"concurrency");return t?Number(t):null}async setGlobalConcurrency(e){return(await this.client).hset(this.keys.meta,"concurrency",e)}async removeGlobalConcurrency(){return(await this.client).hdel(this.keys.meta,"concurrency")}async add(e,t,n){return this.trace(o.SpanKind.PRODUCER,"add",`${this.name}.${e}`,async(r,i)=>{var a;if(i&&!(null===(a=null==n?void 0:n.telemetry)||void 0===a?void 0:a.omitContext)){const e={metadata:i};n=Object.assign(Object.assign({},n),{telemetry:e})}const s=await this.addJob(e,t,n);return null==r||r.setAttributes({[o.TelemetryAttributes.JobName]:e,[o.TelemetryAttributes.JobId]:s.id}),s})}async addJob(e,t,n){if(n&&n.repeat){if(n.repeat.endDate&&+new Date(n.repeat.endDate)<Date.now())throw new Error("End date must be greater than current timestamp");return(await this.repeat).updateRepeatableJob(e,t,Object.assign(Object.assign({},this.jobsOpts),n),{override:!0})}{const r=null==n?void 0:n.jobId;if("0"==r||(null==r?void 0:r.startsWith("0:")))throw new Error("JobId cannot be '0' or start with 0:");const i=await this.Job.create(this,e,t,Object.assign(Object.assign(Object.assign({},this.jobsOpts),n),{jobId:r}));return this.emit("waiting",i),i}}async addBulk(e){return this.trace(o.SpanKind.PRODUCER,"addBulk",this.name,async(t,n)=>(t&&t.setAttributes({[o.TelemetryAttributes.BulkNames]:e.map(e=>e.name),[o.TelemetryAttributes.BulkCount]:e.length}),await this.Job.createBulk(this,e.map(e=>{var t,r,i,a,s,o;let l=null===(t=e.opts)||void 0===t?void 0:t.telemetry;if(n){const t=null===(i=null===(r=e.opts)||void 0===r?void 0:r.telemetry)||void 0===i?void 0:i.omitContext,o=(null===(s=null===(a=e.opts)||void 0===a?void 0:a.telemetry)||void 0===s?void 0:s.metadata)||!t&&n;(o||t)&&(l={metadata:o,omitContext:t})}return{name:e.name,data:e.data,opts:Object.assign(Object.assign(Object.assign({},this.jobsOpts),e.opts),{jobId:null===(o=e.opts)||void 0===o?void 0:o.jobId,telemetry:l})}}))))}async upsertJobScheduler(e,t,n){var r,i;if(t.endDate&&+new Date(t.endDate)<Date.now())throw new Error("End date must be greater than current timestamp");return(await this.jobScheduler).upsertJobScheduler(e,t,null!==(r=null==n?void 0:n.name)&&void 0!==r?r:e,null!==(i=null==n?void 0:n.data)&&void 0!==i?i:{},Object.assign(Object.assign({},this.jobsOpts),null==n?void 0:n.opts),{override:!0})}async pause(){await this.trace(o.SpanKind.INTERNAL,"pause",this.name,async()=>{await this.scripts.pause(!0),this.emit("paused")})}async close(){await this.trace(o.SpanKind.INTERNAL,"close",this.name,async()=>{this.closing||this._repeat&&await this._repeat.close(),await super.close()})}async rateLimit(e){await this.trace(o.SpanKind.INTERNAL,"rateLimit",this.name,async t=>{null==t||t.setAttributes({[o.TelemetryAttributes.QueueRateLimit]:e}),await this.client.then(t=>t.set(this.keys.limiter,Number.MAX_SAFE_INTEGER,"PX",e))})}async resume(){await this.trace(o.SpanKind.INTERNAL,"resume",this.name,async()=>{await this.scripts.pause(!1),this.emit("resumed")})}async isPaused(){const e=await this.client;return 1===await e.hexists(this.keys.meta,"paused")}isMaxed(){return this.scripts.isMaxed()}async getRepeatableJobs(e,t,n){return(await this.repeat).getRepeatableJobs(e,t,n)}async getJobScheduler(e){return(await this.jobScheduler).getScheduler(e)}async getJobSchedulers(e,t,n){return(await this.jobScheduler).getJobSchedulers(e,t,n)}async getJobSchedulersCount(){return(await this.jobScheduler).getSchedulersCount()}async removeRepeatable(e,t,n){return this.trace(o.SpanKind.INTERNAL,"removeRepeatable",`${this.name}.${e}`,async r=>{null==r||r.setAttributes({[o.TelemetryAttributes.JobName]:e,[o.TelemetryAttributes.JobId]:n});const i=await this.repeat;return!await i.removeRepeatable(e,t,n)})}async removeJobScheduler(e){const t=await this.jobScheduler;return!await t.removeJobScheduler(e)}async removeDebounceKey(e){return this.trace(o.SpanKind.INTERNAL,"removeDebounceKey",`${this.name}`,async t=>{null==t||t.setAttributes({[o.TelemetryAttributes.JobKey]:e});const n=await this.client;return await n.del(`${this.keys.de}:${e}`)})}async removeDeduplicationKey(e){return this.trace(o.SpanKind.INTERNAL,"removeDeduplicationKey",`${this.name}`,async t=>{null==t||t.setAttributes({[o.TelemetryAttributes.DeduplicationKey]:e});return(await this.client).del(`${this.keys.de}:${e}`)})}async removeRateLimitKey(){return(await this.client).del(this.keys.limiter)}async removeRepeatableByKey(e){return this.trace(o.SpanKind.INTERNAL,"removeRepeatableByKey",`${this.name}`,async t=>{null==t||t.setAttributes({[o.TelemetryAttributes.JobKey]:e});const n=await this.repeat;return!await n.removeRepeatableByKey(e)})}async remove(e,{removeChildren:t=!0}={}){return this.trace(o.SpanKind.INTERNAL,"remove",this.name,async n=>(null==n||n.setAttributes({[o.TelemetryAttributes.JobId]:e,[o.TelemetryAttributes.JobOptions]:JSON.stringify({removeChildren:t})}),await this.scripts.remove(e,t)))}async updateJobProgress(e,t){await this.trace(o.SpanKind.INTERNAL,"updateJobProgress",this.name,async n=>{null==n||n.setAttributes({[o.TelemetryAttributes.JobId]:e,[o.TelemetryAttributes.JobProgress]:JSON.stringify(t)}),await this.scripts.updateProgress(e,t)})}async addJobLog(e,t,n){return i.Job.addJobLog(this,e,t,n)}async drain(e=!1){await this.trace(o.SpanKind.INTERNAL,"drain",this.name,async t=>{null==t||t.setAttributes({[o.TelemetryAttributes.QueueDrainDelay]:e}),await this.scripts.drain(e)})}async clean(e,t,n="completed"){return this.trace(o.SpanKind.INTERNAL,"clean",this.name,async r=>{const i=t||1/0,a=Math.min(1e4,i),s=Date.now()-e;let l=0;const d=[];for(;l<i;){const e=await this.scripts.cleanJobsInSet(n,s,a);if(this.emit("cleaned",e,n),l+=e.length,d.push(...e),e.length<a)break}return null==r||r.setAttributes({[o.TelemetryAttributes.QueueGrace]:e,[o.TelemetryAttributes.JobType]:n,[o.TelemetryAttributes.QueueCleanLimit]:i,[o.TelemetryAttributes.JobIds]:d}),d})}async obliterate(e){await this.trace(o.SpanKind.INTERNAL,"obliterate",this.name,async()=>{await this.pause();let t=0;do{t=await this.scripts.obliterate(Object.assign({force:!1,count:1e3},e))}while(t)})}async retryJobs(e={}){await this.trace(o.SpanKind.PRODUCER,"retryJobs",this.name,async t=>{null==t||t.setAttributes({[o.TelemetryAttributes.QueueOptions]:JSON.stringify(e)});let n=0;do{n=await this.scripts.retryJobs(e.state,e.count,e.timestamp)}while(n)})}async promoteJobs(e={}){await this.trace(o.SpanKind.INTERNAL,"promoteJobs",this.name,async t=>{null==t||t.setAttributes({[o.TelemetryAttributes.QueueOptions]:JSON.stringify(e)});let n=0;do{n=await this.scripts.promoteJobs(e.count)}while(n)})}async trimEvents(e){return this.trace(o.SpanKind.INTERNAL,"trimEvents",this.name,async t=>{null==t||t.setAttributes({[o.TelemetryAttributes.QueueEventMaxLength]:e});const n=await this.client;return await n.xtrim(this.keys.events,"MAXLEN","~",e)})}async removeDeprecatedPriorityKey(){return(await this.client).del(this.toKey("priority"))}}},(e,t,n)=>{"use strict";n.r(t),n.d(t,{Repeat:()=>o,getNextMillis:()=>d});var r=n(148),i=n(207),a=n(222),s=n(216);class o extends s.QueueBase{constructor(e,t,n){super(e,t,n),this.repeatStrategy=t.settings&&t.settings.repeatStrategy||d,this.repeatKeyHashAlgorithm=t.settings&&t.settings.repeatKeyHashAlgorithm||"md5"}async updateRepeatableJob(e,t,n,{override:i}){var a,s;const o=Object.assign({},n.repeat);null!==(a=o.pattern)&&void 0!==a||(o.pattern=o.cron),delete o.cron;const d=o.count?o.count+1:1;if(void 0!==o.limit&&d>o.limit)return;let c=Date.now();const{endDate:u}=o;if(u&&c>new Date(u).getTime())return;const p=n.prevMillis||0;c=p<c?c:p;const h=await this.repeatStrategy(c,o,e),{every:y,pattern:m}=o,f=Boolean((y||m)&&o.immediately),b=f&&y?c-h:void 0;if(h){!p&&n.jobId&&(o.jobId=n.jobId);const a=l(e,o),c=null!==(s=n.repeat.key)&&void 0!==s?s:this.hash(a);let g;if(i)g=await this.scripts.addRepeatableJob(c,h,{name:e,endDate:u?new Date(u).getTime():void 0,tz:o.tz,pattern:m,every:y},a);else{const e=await this.client;g=await this.scripts.updateRepeatableJobMillis(e,c,h,a)}const{immediately:v}=o,K=(0,r.__rest)(o,["immediately"]);return this.createNextJob(e,h,g,Object.assign(Object.assign({},n),{repeat:Object.assign({offset:b},K)}),t,d,f)}}async createNextJob(e,t,n,r,i,a,s){const o=this.getRepeatJobKey(e,t,n,i),l=Date.now(),d=t+(r.repeat.offset?r.repeat.offset:0)-l,c=Object.assign(Object.assign({},r),{jobId:o,delay:d<0||s?0:d,timestamp:l,prevMillis:t,repeatJobKey:n});return c.repeat=Object.assign(Object.assign({},r.repeat),{count:a}),this.Job.create(this,e,i,c)}getRepeatJobKey(e,t,n,r){return n.split(":").length>2?this.getRepeatJobId({name:e,nextMillis:t,namespace:this.hash(n),jobId:null==r?void 0:r.id}):this.getRepeatDelayedJobId({customKey:n,nextMillis:t})}async removeRepeatable(e,t,n){var r;const i=l(e,Object.assign(Object.assign({},t),{jobId:n})),a=null!==(r=t.key)&&void 0!==r?r:this.hash(i),s=this.getRepeatJobId({name:e,nextMillis:"",namespace:this.hash(i),jobId:null!=n?n:t.jobId,key:t.key});return this.scripts.removeRepeatable(s,i,a)}async removeRepeatableByKey(e){const t=this.keyToData(e),n=this.getRepeatJobId({name:t.name,nextMillis:"",namespace:this.hash(e),jobId:t.id});return this.scripts.removeRepeatable(n,"",e)}async getRepeatableData(e,t,n){const r=await e.hgetall(this.toKey("repeat:"+t));return r?{key:t,name:r.name,endDate:parseInt(r.endDate)||null,tz:r.tz||null,pattern:r.pattern||null,every:r.every||null,next:n}:this.keyToData(t,n)}keyToData(e,t){const n=e.split(":"),r=n.slice(4).join(":")||null;return{key:e,name:n[0],id:n[1]||null,endDate:parseInt(n[2])||null,tz:n[3]||null,pattern:r,next:t}}async getRepeatableJobs(e=0,t=-1,n=!1){const r=await this.client,i=this.keys.repeat,a=n?await r.zrange(i,e,t,"WITHSCORES"):await r.zrevrange(i,e,t,"WITHSCORES"),s=[];for(let e=0;e<a.length;e+=2)s.push(this.getRepeatableData(r,a[e],parseInt(a[e+1])));return Promise.all(s)}async getRepeatableCount(){return(await this.client).zcard(this.toKey("repeat"))}hash(e){return(0,a.createHash)(this.repeatKeyHashAlgorithm).update(e).digest("hex")}getRepeatDelayedJobId({nextMillis:e,customKey:t}){return`repeat:${t}:${e}`}getRepeatJobId({name:e,nextMillis:t,namespace:n,jobId:r,key:i}){return`repeat:${null!=i?i:this.hash(`${e}${r||""}${n}`)}:${t}`}}function l(e,t){const n=t.endDate?new Date(t.endDate).getTime():"",r=t.tz||"",i=t.pattern,a=i||String(t.every)||"";return`${e}:${t.jobId?t.jobId:""}:${n}:${r}:${a}`}const d=(e,t)=>{const n=t.pattern;if(n&&t.every)throw new Error("Both .pattern and .every options are defined for this repeatable job");if(t.every)return Math.floor(e/t.every)*t.every+(t.immediately?0:t.every);const r=t.startDate&&new Date(t.startDate)>new Date(e)?new Date(t.startDate):new Date(e),a=(0,i.parseExpression)(n,Object.assign(Object.assign({},t),{currentDate:r}));try{return t.immediately?(new Date).getTime():a.next().getTime()}catch(e){}}},()=>{},(e,t,n)=>{"use strict";n.r(t),n.d(t,{default:()=>i});var r=n(8);const i=(e,t)=>async function(n,i){let a,s,o;try{const l=new Promise((l,d)=>{(async()=>{try{o=(e,t)=>{d(new Error("Unexpected exit code: "+e+" signal: "+t))},a=await t.retain(e),a.on("exit",o),s=async e=>{var t,i,s;try{switch(e.cmd){case r.ParentCommand.Completed:l(e.value);break;case r.ParentCommand.Failed:case r.ParentCommand.Error:{const t=new Error;Object.assign(t,e.value),d(t);break}case r.ParentCommand.Progress:await n.updateProgress(e.value);break;case r.ParentCommand.Log:await n.log(e.value);break;case r.ParentCommand.MoveToDelayed:await n.moveToDelayed(null===(t=e.value)||void 0===t?void 0:t.timestamp,null===(i=e.value)||void 0===i?void 0:i.token);break;case r.ParentCommand.MoveToWait:await n.moveToWait(null===(s=e.value)||void 0===s?void 0:s.token);break;case r.ParentCommand.Update:await n.updateData(e.value);break;case r.ParentCommand.GetChildrenValues:{const t=await n.getChildrenValues();a.send({requestId:e.requestId,cmd:r.ChildCommand.GetChildrenValuesResponse,value:t})}break;case r.ParentCommand.GetIgnoredChildrenFailures:{const t=await n.getIgnoredChildrenFailures();a.send({requestId:e.requestId,cmd:r.ChildCommand.GetIgnoredChildrenFailuresResponse,value:t})}}}catch(e){d(e)}},a.on("message",s),a.send({cmd:r.ChildCommand.Start,job:n.asJSONSandbox(),token:i})}catch(e){d(e)}})()});return await l,l}finally{a&&(a.off("message",s),a.off("exit",o),null===a.exitCode&&null===a.signalCode&&t.release(a))}}},(e,t,n)=>{"use strict";n.r(t),n.d(t,{Worker:()=>b});var r=n(225);Object(function(){var e=new Error("Cannot find module 'url'");throw e.code="MODULE_NOT_FOUND",e}());var i=n(16),a=n(200),s=n(226),o=n(18),l=n(216),d=n(221),c=n(15),u=n(150),p=n(223),h=n(3),y=n(140),m=n(8),f=n(206);e=n.hmd(e);class b extends l.QueueBase{static RateLimitError(){return new y.RateLimitError}constructor(t,n,s,l){if(super(t,Object.assign(Object.assign({drainDelay:5,concurrency:1,lockDuration:3e4,maxStalledCount:1,stalledInterval:3e4,autorun:!0,runRetryDelay:15e3},s),{blockingConnection:!0}),l),this.abortDelayController=null,this.blockUntil=0,this.drained=!1,this.extendLocksTimer=null,this.limitUntil=0,this.waiting=null,this.running=!1,this.mainLoopRunning=null,!s||!s.connection)throw new Error("Worker requires a connection");if("number"!=typeof this.opts.maxStalledCount||this.opts.maxStalledCount<0)throw new Error("maxStalledCount must be greater or equal than 0");if("number"!=typeof this.opts.stalledInterval||this.opts.stalledInterval<=0)throw new Error("stalledInterval must be greater than 0");if("number"!=typeof this.opts.drainDelay||this.opts.drainDelay<=0)throw new Error("drainDelay must be greater than 0");if(this.concurrency=this.opts.concurrency,this.opts.lockRenewTime=this.opts.lockRenewTime||this.opts.lockDuration/2,this.id=(0,a.default)(),n){if("function"==typeof n)this.processFn=n;else{if(n instanceof Object(function(){var e=new Error("Cannot find module 'url'");throw e.code="MODULE_NOT_FOUND",e}())){if(!r.existsSync(n))throw new Error(`URL ${n} does not exist in the local file system`);n=n.href}else{const e=n+([".js",".ts",".flow",".cjs"].includes(i.extname(n))?"":".js");if(!r.existsSync(e))throw new Error(`File ${e} does not exist`)}const t=i.dirname(e.filename||"/index.js"),a=i.join(t,"main-worker.js"),s=i.join(t,"main.js");let o=this.opts.useWorkerThreads?a:s;try{r.statSync(o)}catch(e){const t=this.opts.useWorkerThreads?"main-worker.js":"main.js";o=i.join(process.cwd(),`dist/cjs/classes/${t}`),r.statSync(o)}this.childPool=new c.ChildPool({mainFile:o,useWorkerThreads:this.opts.useWorkerThreads,workerForkOptions:this.opts.workerForkOptions,workerThreadsOptions:this.opts.workerThreadsOptions}),this.processFn=(0,p.default)(n,this.childPool).bind(this)}this.opts.autorun&&this.run().catch(e=>this.emit("error",e))}const d=this.clientName()+(this.opts.name?`:w:${this.opts.name}`:"");this.blockingConnection=new u.RedisConnection((0,o.isRedisInstance)(s.connection)?s.connection.duplicate({connectionName:d}):Object.assign(Object.assign({},s.connection),{connectionName:d}),{shared:!1,blocking:!0,skipVersionCheck:s.skipVersionCheck}),this.blockingConnection.on("error",e=>this.emit("error",e)),this.blockingConnection.on("ready",()=>setTimeout(()=>this.emit("ready"),0))}emit(e,...t){return super.emit(e,...t)}off(e,t){return super.off(e,t),this}on(e,t){return super.on(e,t),this}once(e,t){return super.once(e,t),this}callProcessJob(e,t){return this.processFn(e,t)}createJob(e,t){return this.Job.fromJSON(this,e,t)}async waitUntilReady(){return await super.waitUntilReady(),this.blockingConnection.client}set concurrency(e){if("number"!=typeof e||e<1||!isFinite(e))throw new Error("concurrency must be a finite number greater than 0");this._concurrency=e}get concurrency(){return this._concurrency}get repeat(){return new Promise(async e=>{if(!this._repeat){const e=await this.client;this._repeat=new d.Repeat(this.name,Object.assign(Object.assign({},this.opts),{connection:e})),this._repeat.on("error",e=>this.emit.bind(this,e))}e(this._repeat)})}get jobScheduler(){return new Promise(async e=>{if(!this._jobScheduler){const e=await this.client;this._jobScheduler=new f.JobScheduler(this.name,Object.assign(Object.assign({},this.opts),{connection:e})),this._jobScheduler.on("error",e=>this.emit.bind(this,e))}e(this._jobScheduler)})}async run(){if(!this.processFn)throw new Error("No process function is defined.");if(this.running)throw new Error("Worker is already running.");try{if(this.running=!0,this.closing||this.paused)return;await this.startStalledCheckTimer();const e=await this.client,t=await this.blockingConnection.client;this.mainLoopRunning=this.mainLoop(e,t),await this.mainLoopRunning}finally{this.running=!1}}async waitForRateLimit(){var e;const t=this.limitUntil;if(t>Date.now()){null===(e=this.abortDelayController)||void 0===e||e.abort(),this.abortDelayController=new s.AbortController;const n=this.getRateLimitDelay(t-Date.now());await this.delay(n,this.abortDelayController)}}async mainLoop(e,t){const n=new h.AsyncFifoQueue,r=new Set;this.startLockExtenderTimer(r);let i=0;for(;!this.closing&&!this.paused;){let a,s=n.numTotal();for(;!this.closing&&!this.paused&&!this.waiting&&s<this._concurrency&&!this.isRateLimited();){const r=`${this.id}:${i++}`,a=this.retryIfFailed(()=>this._getNextJob(e,t,r,{block:!0}),this.opts.runRetryDelay);if(n.add(a),s=n.numTotal(),this.waiting&&s>1)break;if(!await a&&s>1)break;if(this.blockUntil)break}do{a=await n.fetch()}while(!a&&n.numQueued()>0);if(a){const e=a.token;n.add(this.retryIfFailed(()=>this.processJob(a,e,()=>n.numTotal()<=this._concurrency,r),this.opts.runRetryDelay))}else n.numQueued()<1&&await this.waitForRateLimit()}return n.waitAll()}async getNextJob(e,{block:t=!0}={}){var n,r;const i=await this._getNextJob(await this.client,await this.blockingConnection.client,e,{block:t});return this.trace(m.SpanKind.INTERNAL,"getNextJob",this.name,async e=>(null==e||e.setAttributes({[m.TelemetryAttributes.WorkerId]:this.id,[m.TelemetryAttributes.QueueName]:this.name,[m.TelemetryAttributes.WorkerName]:this.opts.name,[m.TelemetryAttributes.WorkerOptions]:JSON.stringify({block:t}),[m.TelemetryAttributes.JobId]:null==i?void 0:i.id}),i),null===(r=null===(n=null==i?void 0:i.opts)||void 0===n?void 0:n.telemetry)||void 0===r?void 0:r.metadata)}async _getNextJob(e,t,n,{block:r=!0}={}){if(!this.paused&&!this.closing)if(this.drained&&r&&!this.limitUntil&&!this.waiting){this.waiting=this.waitForJob(t,this.blockUntil);try{if(this.blockUntil=await this.waiting,this.blockUntil<=0||this.blockUntil-Date.now()<1)return await this.moveToActive(e,n,this.opts.name)}catch(e){if(!this.paused&&!this.closing&&(0,o.isNotConnectionError)(e))throw e}finally{this.waiting=null}}else if(!this.isRateLimited())return this.moveToActive(e,n,this.opts.name)}async rateLimit(e){await this.trace(m.SpanKind.INTERNAL,"rateLimit",this.name,async t=>{null==t||t.setAttributes({[m.TelemetryAttributes.WorkerId]:this.id,[m.TelemetryAttributes.WorkerRateLimit]:e}),await this.client.then(t=>t.set(this.keys.limiter,Number.MAX_SAFE_INTEGER,"PX",e))})}get minimumBlockTimeout(){return this.blockingConnection.capabilities.canBlockFor1Ms?.001:.002}isRateLimited(){return this.limitUntil>Date.now()}async moveToActive(e,t,n){const[r,i,a,s]=await this.scripts.moveToActive(e,t,n);return this.updateDelays(a,s),this.nextJobFromJobData(r,i,t)}async waitForJob(e,t){if(this.paused)return 1/0;let n;try{if(!this.closing&&!this.isRateLimited()){let r=this.getBlockTimeout(t);if(r>0){r=this.blockingConnection.capabilities.canDoubleTimeout?r:Math.ceil(r),n=setTimeout(async()=>{e.disconnect(!this.closing)},1e3*r+1e3),this.updateDelays();const t=await e.bzpopmin(this.keys.marker,r);if(t){const[e,n,r]=t;if(n)return parseInt(r)}}return 0}}catch(e){(0,o.isNotConnectionError)(e)&&this.emit("error",e),this.closing||await this.delay()}finally{clearTimeout(n)}return 1/0}getBlockTimeout(e){const t=this.opts;if(e){const t=e-Date.now();return t<=0?t:t<1e3*this.minimumBlockTimeout?this.minimumBlockTimeout:Math.min(t/1e3,10)}return Math.max(t.drainDelay,this.minimumBlockTimeout)}getRateLimitDelay(e){return Math.min(e,3e4)}async delay(e,t){await(0,o.delay)(e||o.DELAY_TIME_1,t)}updateDelays(e=0,t=0){const n=Math.max(e,0);this.limitUntil=n>0?Date.now()+n:0,this.blockUntil=Math.max(t,0)||0}async nextJobFromJobData(e,t,n){if(e){this.drained=!1;const r=this.createJob(e,t);if(r.token=n,r.opts.repeat&&!r.nextRepeatableJobId)if(r.repeatJobKey){const e=await this.jobScheduler;await e.upsertJobScheduler(r.repeatJobKey,r.opts.repeat,r.name,r.data,r.opts,{override:!1,producerId:r.id})}else{const e=await this.repeat;await e.updateRepeatableJob(r.name,r.data,r.opts,{override:!1})}return r}this.drained||(this.emit("drained"),this.drained=!0)}async processJob(e,t,n=()=>!0,r){var i,a;const s=null===(a=null===(i=e.opts)||void 0===i?void 0:i.telemetry)||void 0===a?void 0:a.metadata;return this.trace(m.SpanKind.CONSUMER,"process",this.name,async i=>{null==i||i.setAttributes({[m.TelemetryAttributes.WorkerId]:this.id,[m.TelemetryAttributes.WorkerName]:this.opts.name,[m.TelemetryAttributes.JobId]:e.id}),this.emit("active",e,"waiting");const a=Date.now(),s={job:e,ts:a};try{if(e.deferredFailure){return await this.handleFailed(new y.UnrecoverableError(e.deferredFailure),e,t,n,r,s,i)}r.add(s);const a=await this.callProcessJob(e,t);return await this.handleCompleted(a,e,t,n,r,s,i)}catch(a){return await this.handleFailed(a,e,t,n,r,s,i)}finally{null==i||i.setAttributes({[m.TelemetryAttributes.JobFinishedTimestamp]:Date.now(),[m.TelemetryAttributes.JobProcessedTimestamp]:a})}},s)}async handleCompleted(e,t,n,r=()=>!0,i,a,s){if(i.delete(a),!this.connection.closing){const i=await t.moveToCompleted(e,n,r()&&!(this.closing||this.paused));this.emit("completed",t,e,"active"),null==s||s.addEvent("job completed",{[m.TelemetryAttributes.JobResult]:JSON.stringify(e)});const[a,o,l,d]=i||[];return this.updateDelays(l,d),this.nextJobFromJobData(a,o,n)}}async handleFailed(e,t,n,r=()=>!0,i,a,s){if(i.delete(a),!this.connection.closing)try{if(e.message==y.RATE_LIMIT_ERROR){const e=await this.moveLimitedBackToWait(t,n);return void(this.limitUntil=e>0?Date.now()+e:0)}if(e instanceof y.DelayedError||"DelayedError"==e.name||e instanceof y.WaitingError||"WaitingError"==e.name||e instanceof y.WaitingChildrenError||"WaitingChildrenError"==e.name)return;const i=await t.moveToFailed(e,n,r()&&!(this.closing||this.paused));if(this.emit("failed",t,e,"active"),null==s||s.addEvent("job failed",{[m.TelemetryAttributes.JobFailedReason]:e.message}),i){const[e,t,r,a]=i;return this.updateDelays(r,a),this.nextJobFromJobData(e,t,n)}}catch(e){this.emit("error",e),null==s||s.recordException(e.message)}}async pause(e){await this.trace(m.SpanKind.INTERNAL,"pause",this.name,async t=>{var n;null==t||t.setAttributes({[m.TelemetryAttributes.WorkerId]:this.id,[m.TelemetryAttributes.WorkerName]:this.opts.name,[m.TelemetryAttributes.WorkerDoNotWaitActive]:e}),this.paused||(this.paused=!0,await(!e&&this.whenCurrentJobsFinished()),null===(n=this.stalledCheckStopper)||void 0===n||n.call(this),this.emit("paused"))})}resume(){this.running||this.trace(m.SpanKind.INTERNAL,"resume",this.name,e=>{null==e||e.setAttributes({[m.TelemetryAttributes.WorkerId]:this.id,[m.TelemetryAttributes.WorkerName]:this.opts.name}),this.paused=!1,this.processFn&&this.run(),this.emit("resumed")})}isPaused(){return!!this.paused}isRunning(){return this.running}async close(e=!1){return this.closing?this.closing:(this.closing=(async()=>{await this.trace(m.SpanKind.INTERNAL,"close",this.name,async t=>{var n,r;null==t||t.setAttributes({[m.TelemetryAttributes.WorkerId]:this.id,[m.TelemetryAttributes.WorkerName]:this.opts.name,[m.TelemetryAttributes.WorkerForceClose]:e}),this.emit("closing","closing queue"),null===(n=this.abortDelayController)||void 0===n||n.abort();const i=[()=>e||this.whenCurrentJobsFinished(!1),()=>{var e;return null===(e=this.childPool)||void 0===e?void 0:e.clean()},()=>this.blockingConnection.close(e),()=>this.connection.close(e)];for(const e of i)try{await e()}catch(e){this.emit("error",e)}clearTimeout(this.extendLocksTimer),null===(r=this.stalledCheckStopper)||void 0===r||r.call(this),this.closed=!0,this.emit("closed")})})(),await this.closing)}async startStalledCheckTimer(){this.opts.skipStalledCheck||this.closing||await this.trace(m.SpanKind.INTERNAL,"startStalledCheckTimer",this.name,async e=>{null==e||e.setAttributes({[m.TelemetryAttributes.WorkerId]:this.id,[m.TelemetryAttributes.WorkerName]:this.opts.name}),this.stalledChecker().catch(e=>{this.emit("error",e)})})}async stalledChecker(){for(;!this.closing&&!this.paused;){try{await this.checkConnectionError(()=>this.moveStalledJobsToWait())}catch(e){this.emit("error",e)}await new Promise(e=>{const t=setTimeout(e,this.opts.stalledInterval);this.stalledCheckStopper=()=>{clearTimeout(t),e()}})}}startLockExtenderTimer(e){this.opts.skipLockRenewal||(clearTimeout(this.extendLocksTimer),this.closed||(this.extendLocksTimer=setTimeout(async()=>{const t=Date.now(),n=[];for(const r of e){const{job:e,ts:i}=r;i?i+this.opts.lockRenewTime/2<t&&(r.ts=t,n.push(e)):r.ts=t}try{n.length&&await this.extendLocks(n)}catch(e){this.emit("error",e)}this.startLockExtenderTimer(e)},this.opts.lockRenewTime/2)))}async whenCurrentJobsFinished(e=!0){this.waiting?await this.blockingConnection.disconnect(e):e=!1,this.mainLoopRunning&&await this.mainLoopRunning,e&&await this.blockingConnection.reconnect()}async retryIfFailed(e,t){for(;;)try{return await e()}catch(e){if(this.emit("error",e),!t)return;await this.delay(t)}}async extendLocks(e){await this.trace(m.SpanKind.INTERNAL,"extendLocks",this.name,async t=>{null==t||t.setAttributes({[m.TelemetryAttributes.WorkerId]:this.id,[m.TelemetryAttributes.WorkerName]:this.opts.name,[m.TelemetryAttributes.WorkerJobsToExtendLocks]:e.map(e=>e.id)});try{const t=await this.scripts.extendLocks(e.map(e=>e.id),e.map(e=>e.token),this.opts.lockDuration);for(const e of t)this.emit("error",new Error(`could not renew lock for job ${e}`))}catch(e){this.emit("error",e)}})}async moveStalledJobsToWait(){await this.trace(m.SpanKind.INTERNAL,"moveStalledJobsToWait",this.name,async e=>{const t=await this.scripts.moveStalledJobsToWait();null==e||e.setAttributes({[m.TelemetryAttributes.WorkerId]:this.id,[m.TelemetryAttributes.WorkerName]:this.opts.name,[m.TelemetryAttributes.WorkerStalledJobs]:t}),t.forEach(t=>{null==e||e.addEvent("job stalled",{[m.TelemetryAttributes.JobId]:t}),this.emit("stalled",t,"active")})})}moveLimitedBackToWait(e,t){return e.moveToWait(t)}}},()=>{},e=>{"use strict";const t="undefined"!=typeof self?self:"undefined"!=typeof window?window:void 0;if(!t)throw new Error("Unable to find global scope. Are you sure this is running in the browser?");if(!t.AbortController)throw new Error('Could not find "AbortController" in the global scope. You need to polyfill it first');e.exports.AbortController=t.AbortController},(e,t,n)=>{"use strict";n.r(t),n.d(t,{ClientType:()=>r.ClientType});n(228),n(229),n(230),n(231),n(232),n(233),n(234),n(235),n(236),n(237),n(238),n(239),n(240),n(241),n(242),n(243);var r=n(244);n(245),n(246),n(247),n(248),n(249),n(250),n(251),n(252),n(253),n(254),n(255),n(256)},(e,t,n)=>{"use strict";n.r(t)},(e,t,n)=>{"use strict";n.r(t)},(e,t,n)=>{"use strict";n.r(t)},(e,t,n)=>{"use strict";n.r(t)},(e,t,n)=>{"use strict";n.r(t)},(e,t,n)=>{"use strict";n.r(t)},(e,t,n)=>{"use strict";n.r(t)},(e,t,n)=>{"use strict";n.r(t)},(e,t,n)=>{"use strict";n.r(t)},(e,t,n)=>{"use strict";n.r(t)},(e,t,n)=>{"use strict";n.r(t)},(e,t,n)=>{"use strict";n.r(t)},(e,t,n)=>{"use strict";n.r(t)},(e,t,n)=>{"use strict";n.r(t)},(e,t,n)=>{"use strict";n.r(t)},(e,t,n)=>{"use strict";n.r(t)},(e,t,n)=>{"use strict";var r;n.r(t),n.d(t,{ClientType:()=>r}),function(e){e.blocking="blocking",e.normal="normal"}(r||(r={}))},(e,t,n)=>{"use strict";n.r(t)},(e,t,n)=>{"use strict";n.r(t)},(e,t,n)=>{"use strict";n.r(t)},(e,t,n)=>{"use strict";n.r(t)},(e,t,n)=>{"use strict";n.r(t)},(e,t,n)=>{"use strict";n.r(t)},(e,t,n)=>{"use strict";n.r(t)},(e,t,n)=>{"use strict";n.r(t)},(e,t,n)=>{"use strict";n.r(t)},(e,t,n)=>{"use strict";n.r(t)},(e,t,n)=>{"use strict";n.r(t)},(e,t,n)=>{"use strict";n.r(t)},(e,t,n)=>{"use strict";n.r(t);n(258),n(259),n(260),n(261),n(262),n(263),n(264),n(265),n(266),n(267),n(268)},(e,t,n)=>{"use strict";n.r(t)},(e,t,n)=>{"use strict";n.r(t)},(e,t,n)=>{"use strict";n.r(t)},(e,t,n)=>{"use strict";n.r(t)},(e,t,n)=>{"use strict";n.r(t)},(e,t,n)=>{"use strict";n.r(t)},(e,t,n)=>{"use strict";n.r(t)},(e,t,n)=>{"use strict";n.r(t)},(e,t,n)=>{"use strict";n.r(t)},(e,t,n)=>{"use strict";n.r(t)},(e,t,n)=>{"use strict";n.r(t)},(e,t,n)=>{var r=n(21);function i(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter(function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable})),n.push.apply(n,r)}return n}e.exports=function(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?i(Object(n),!0).forEach(function(t){r(e,t,n[t])}):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach(function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))})}return e}({},n(270))},(e,t,n)=>{var r=n(21);function i(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter(function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable})),n.push.apply(n,r)}return n}e.exports=function(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?i(Object(n),!0).forEach(function(t){r(e,t,n[t])}):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach(function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))})}return e}({},n(271))},(e,t,n)=>{Object.defineProperty(t,"__esModule",{value:!0});const{Decimal:r,objectEnumValues:i,makeStrictEnum:a,Public:s,getRuntime:o,skip:l}=n(272),d={};t.Prisma=d,t.$Enums={},d.prismaVersion={client:"6.10.1",engine:"9b628578b3b7cae625e8c927178f15a170e74a9c"},d.PrismaClientKnownRequestError=()=>{const e=o().prettyName;throw new Error(`PrismaClientKnownRequestError is unable to run in this browser environment, or has been bundled for the browser (running in ${e}).\nIn case this error is unexpected for you, please report it in https://pris.ly/prisma-prisma-bug-report`)},d.PrismaClientUnknownRequestError=()=>{const e=o().prettyName;throw new Error(`PrismaClientUnknownRequestError is unable to run in this browser environment, or has been bundled for the browser (running in ${e}).\nIn case this error is unexpected for you, please report it in https://pris.ly/prisma-prisma-bug-report`)},d.PrismaClientRustPanicError=()=>{const e=o().prettyName;throw new Error(`PrismaClientRustPanicError is unable to run in this browser environment, or has been bundled for the browser (running in ${e}).\nIn case this error is unexpected for you, please report it in https://pris.ly/prisma-prisma-bug-report`)},d.PrismaClientInitializationError=()=>{const e=o().prettyName;throw new Error(`PrismaClientInitializationError is unable to run in this browser environment, or has been bundled for the browser (running in ${e}).\nIn case this error is unexpected for you, please report it in https://pris.ly/prisma-prisma-bug-report`)},d.PrismaClientValidationError=()=>{const e=o().prettyName;throw new Error(`PrismaClientValidationError is unable to run in this browser environment, or has been bundled for the browser (running in ${e}).\nIn case this error is unexpected for you, please report it in https://pris.ly/prisma-prisma-bug-report`)},d.Decimal=r,d.sql=()=>{const e=o().prettyName;throw new Error(`sqltag is unable to run in this browser environment, or has been bundled for the browser (running in ${e}).\nIn case this error is unexpected for you, please report it in https://pris.ly/prisma-prisma-bug-report`)},d.empty=()=>{const e=o().prettyName;throw new Error(`empty is unable to run in this browser environment, or has been bundled for the browser (running in ${e}).\nIn case this error is unexpected for you, please report it in https://pris.ly/prisma-prisma-bug-report`)},d.join=()=>{const e=o().prettyName;throw new Error(`join is unable to run in this browser environment, or has been bundled for the browser (running in ${e}).\nIn case this error is unexpected for you, please report it in https://pris.ly/prisma-prisma-bug-report`)},d.raw=()=>{const e=o().prettyName;throw new Error(`raw is unable to run in this browser environment, or has been bundled for the browser (running in ${e}).\nIn case this error is unexpected for you, please report it in https://pris.ly/prisma-prisma-bug-report`)},d.validator=s.validator,d.getExtensionContext=()=>{const e=o().prettyName;throw new Error(`Extensions.getExtensionContext is unable to run in this browser environment, or has been bundled for the browser (running in ${e}).\nIn case this error is unexpected for you, please report it in https://pris.ly/prisma-prisma-bug-report`)},d.defineExtension=()=>{const e=o().prettyName;throw new Error(`Extensions.defineExtension is unable to run in this browser environment, or has been bundled for the browser (running in ${e}).\nIn case this error is unexpected for you, please report it in https://pris.ly/prisma-prisma-bug-report`)},d.DbNull=i.instances.DbNull,d.JsonNull=i.instances.JsonNull,d.AnyNull=i.instances.AnyNull,d.NullTypes={DbNull:i.classes.DbNull,JsonNull:i.classes.JsonNull,AnyNull:i.classes.AnyNull},t.Prisma.TransactionIsolationLevel=a({ReadUncommitted:"ReadUncommitted",ReadCommitted:"ReadCommitted",RepeatableRead:"RepeatableRead",Serializable:"Serializable"}),t.Prisma.UserScalarFieldEnum={id:"id",name:"name",email:"email",emailVerified:"emailVerified",passwordHash:"passwordHash",profilePicture:"profilePicture",coverPicture:"coverPicture",bio:"bio",createdAt:"createdAt",updatedAt:"updatedAt",publicProfile:"publicProfile",languagePreference:"languagePreference",socialLinks:"socialLinks",lastActiveDate:"lastActiveDate",familyId:"familyId",stripeCustomerId:"stripeCustomerId",stripeSubscriptionId:"stripeSubscriptionId",stripePriceId:"stripePriceId",stripeCurrentPeriodEnd:"stripeCurrentPeriodEnd",subscriptionTier:"subscriptionTier",creatorBalance:"creatorBalance",profileSpotlightEndsAt:"profileSpotlightEndsAt",monthlyExecutionLimit:"monthlyExecutionLimit",currentMonthExecutionCount:"currentMonthExecutionCount",bonusExecutionCredits:"bonusExecutionCredits",xp:"xp",level:"level",currentStreak:"currentStreak",role:"role",isBanned:"isBanned",banReason:"banReason",isAmbassador:"isAmbassador",referralCode:"referralCode"},t.Prisma.UserSettingsScalarFieldEnum={userId:"userId",notificationsOnLike:"notificationsOnLike",notificationsOnComment:"notificationsOnComment",notificationsOnMention:"notificationsOnMention",notificationsOnSystem:"notificationsOnSystem",theme:"theme"},t.Prisma.AccountScalarFieldEnum={id:"id",userId:"userId",type:"type",provider:"provider",providerAccountId:"providerAccountId",refresh_token:"refresh_token",access_token:"access_token",expires_at:"expires_at",token_type:"token_type",scope:"scope",id_token:"id_token",session_state:"session_state"},t.Prisma.SessionScalarFieldEnum={id:"id",sessionToken:"sessionToken",userId:"userId",expires:"expires"},t.Prisma.VerificationTokenScalarFieldEnum={identifier:"identifier",token:"token",expires:"expires"},t.Prisma.PostScalarFieldEnum={id:"id",content:"content",authorId:"authorId",createdAt:"createdAt",updatedAt:"updatedAt",type:"type",mediaUrls:"mediaUrls",metadata:"metadata",viewCount:"viewCount",isDeleted:"isDeleted",deletedAt:"deletedAt",commentsJson:"commentsJson",resharedFromId:"resharedFromId",newsArticleId:"newsArticleId"},t.Prisma.PostRevisionScalarFieldEnum={id:"id",postId:"postId",content:"content",reason:"reason",createdAt:"createdAt"},t.Prisma.PostLikeScalarFieldEnum={userId:"userId",postId:"postId",createdAt:"createdAt"},t.Prisma.CommentScalarFieldEnum={id:"id",content:"content",createdAt:"createdAt",authorId:"authorId",postId:"postId",isDeleted:"isDeleted",deletedAt:"deletedAt",parentId:"parentId"},t.Prisma.CommentLikeScalarFieldEnum={userId:"userId",commentId:"commentId",createdAt:"createdAt"},t.Prisma.NewsArticleScalarFieldEnum={id:"id",title:"title",link:"link",description:"description",imageUrl:"imageUrl",publishedAt:"publishedAt",sourceName:"sourceName",createdAt:"createdAt",category:"category",tags:"tags",content:"content"},t.Prisma.NewsArticleLikeScalarFieldEnum={userId:"userId",newsArticleId:"newsArticleId",createdAt:"createdAt"},t.Prisma.GenZContentScalarFieldEnum={id:"id",title:"title",description:"description",content:"content",sourceName:"sourceName",sourceUrl:"sourceUrl",imageUrl:"imageUrl",publishedAt:"publishedAt",category:"category",tags:"tags",engagement:"engagement",createdAt:"createdAt"},t.Prisma.DailyDigestScalarFieldEnum={id:"id",content:"content",createdAt:"createdAt"},t.Prisma.FriendshipScalarFieldEnum={requesterId:"requesterId",receiverId:"receiverId",status:"status",createdAt:"createdAt",updatedAt:"updatedAt"},t.Prisma.BlockScalarFieldEnum={blockerId:"blockerId",blockedId:"blockedId",createdAt:"createdAt"},t.Prisma.CircleScalarFieldEnum={id:"id",name:"name",ownerId:"ownerId"},t.Prisma.CircleMembershipScalarFieldEnum={circleId:"circleId",userId:"userId"},t.Prisma.PollScalarFieldEnum={id:"id",question:"question",postId:"postId"},t.Prisma.PollOptionScalarFieldEnum={id:"id",text:"text",pollId:"pollId"},t.Prisma.VoteScalarFieldEnum={userId:"userId",pollOptionId:"pollOptionId",createdAt:"createdAt"},t.Prisma.AchievementScalarFieldEnum={id:"id",name:"name",description:"description",icon:"icon",xpReward:"xpReward"},t.Prisma.UserAchievementScalarFieldEnum={userId:"userId",achievementId:"achievementId",earnedAt:"earnedAt"},t.Prisma.BadgeScalarFieldEnum={id:"id",name:"name",description:"description",imageUrl:"imageUrl"},t.Prisma.UserBadgeScalarFieldEnum={userId:"userId",badgeId:"badgeId",earnedAt:"earnedAt"},t.Prisma.TipScalarFieldEnum={id:"id",tipperId:"tipperId",creatorId:"creatorId",postId:"postId",amount:"amount",message:"message",createdAt:"createdAt"},t.Prisma.CompanyScalarFieldEnum={id:"id",name:"name",description:"description",websiteUrl:"websiteUrl",logoUrl:"logoUrl",ownerId:"ownerId"},t.Prisma.JobScalarFieldEnum={id:"id",title:"title",description:"description",location:"location",type:"type",salaryRange:"salaryRange",isActive:"isActive",companyId:"companyId",createdAt:"createdAt",externalUrl:"externalUrl",publishedAt:"publishedAt",source:"source",companyName:"companyName"},t.Prisma.JobApplicationScalarFieldEnum={id:"id",status:"status",appliedAt:"appliedAt",applicantId:"applicantId",jobId:"jobId"},t.Prisma.FamilyScalarFieldEnum={id:"id",name:"name",createdAt:"createdAt"},t.Prisma.EventScalarFieldEnum={id:"id",familyId:"familyId",createdById:"createdById",title:"title",description:"description",startTime:"startTime",endTime:"endTime",recurringRule:"recurringRule"},t.Prisma.EventAttendeeScalarFieldEnum={eventId:"eventId",userId:"userId"},t.Prisma.BudgetScalarFieldEnum={id:"id",userId:"userId",name:"name",limitAmount:"limitAmount",category:"category",createdAt:"createdAt"},t.Prisma.BillScalarFieldEnum={id:"id",userId:"userId",name:"name",amount:"amount",dueDate:"dueDate",isPaid:"isPaid",createdAt:"createdAt"},t.Prisma.SubscriptionScalarFieldEnum={id:"id",userId:"userId",name:"name",amount:"amount",renewalDate:"renewalDate",createdAt:"createdAt"},t.Prisma.TransactionScalarFieldEnum={id:"id",userId:"userId",budgetId:"budgetId",amount:"amount",description:"description",date:"date",createdAt:"createdAt"},t.Prisma.TaskScalarFieldEnum={id:"id",content:"content",details:"details",link:"link",isCompleted:"isCompleted",createdAt:"createdAt",completedAt:"completedAt",ownerId:"ownerId"},t.Prisma.ProductivityTipScalarFieldEnum={id:"id",text:"text"},t.Prisma.NotificationScalarFieldEnum={id:"id",recipientId:"recipientId",actorId:"actorId",type:"type",entityId:"entityId",isRead:"isRead",createdAt:"createdAt"},t.Prisma.ReportScalarFieldEnum={id:"id",reporterId:"reporterId",entityId:"entityId",entityType:"entityType",reason:"reason",status:"status",createdAt:"createdAt",moderatorNotes:"moderatorNotes"},t.Prisma.CustomPersonaScalarFieldEnum={id:"id",name:"name",prompt:"prompt",icon:"icon",createdAt:"createdAt",ownerId:"ownerId"},t.Prisma.ApiKeyScalarFieldEnum={id:"id",key:"key",createdAt:"createdAt",userId:"userId"},t.Prisma.AmbassadorMetricScalarFieldEnum={id:"id",ambassadorId:"ambassadorId",referredUserId:"referredUserId",createdAt:"createdAt"},t.Prisma.MoodLogScalarFieldEnum={id:"id",userId:"userId",mood:"mood",notes:"notes",createdAt:"createdAt"},t.Prisma.JournalPromptScalarFieldEnum={id:"id",promptText:"promptText",category:"category"},t.Prisma.JournalEntryScalarFieldEnum={id:"id",userId:"userId",promptId:"promptId",content:"content",createdAt:"createdAt"},t.Prisma.GuideScalarFieldEnum={id:"id",title:"title",slug:"slug",shortDescription:"shortDescription",coverImageUrl:"coverImageUrl",category:"category",content:"content",author:"author",publishedAt:"publishedAt"},t.Prisma.GuideViewScalarFieldEnum={id:"id",guideId:"guideId",userId:"userId",viewedAt:"viewedAt"},t.Prisma.GuideFavoriteScalarFieldEnum={id:"id",guideId:"guideId",userId:"userId",favoritedAt:"favoritedAt"},t.Prisma.DigitalDetoxPlanScalarFieldEnum={id:"id",title:"title",description:"description",coverImage:"coverImage",createdAt:"createdAt"},t.Prisma.DigitalDetoxTaskScalarFieldEnum={id:"id",planId:"planId",day:"day",title:"title",content:"content",order:"order"},t.Prisma.DigitalDetoxProgressScalarFieldEnum={id:"id",userId:"userId",taskId:"taskId",completedAt:"completedAt"},t.Prisma.ChangelogScalarFieldEnum={id:"id",title:"title",description:"description",publishedAt:"publishedAt",type:"type",version:"version"},t.Prisma.UserChangelogSeenScalarFieldEnum={userId:"userId",changelogId:"changelogId",seenAt:"seenAt"},t.Prisma.AgentMemoryScalarFieldEnum={id:"id",agentInstanceId:"agentInstanceId",key:"key",value:"value",createdAt:"createdAt",updatedAt:"updatedAt"},t.Prisma.AgentRunScalarFieldEnum={id:"id",userId:"userId",agentTemplateId:"agentTemplateId",status:"status",input:"input",output:"output",error:"error",pausedState:"pausedState",humanInputPrompt:"humanInputPrompt",createdAt:"createdAt",updatedAt:"updatedAt",webhookUrl:"webhookUrl"},t.Prisma.AgentTemplateScalarFieldEnum={id:"id",name:"name",description:"description",defaultPrompt:"defaultPrompt",defaultModel:"defaultModel",defaultTools:"defaultTools",isPublic:"isPublic",version:"version",isLatest:"isLatest",createdAt:"createdAt",updatedAt:"updatedAt"},t.Prisma.AgentInstanceScalarFieldEnum={id:"id",userId:"userId",templateId:"templateId",name:"name",configOverride:"configOverride",webhookUrl:"webhookUrl",nextAgentInstanceId:"nextAgentInstanceId"},t.Prisma.AgentConfigRevisionScalarFieldEnum={id:"id",agentInstanceId:"agentInstanceId",configSnapshot:"configSnapshot",revisionNumber:"revisionNumber",createdAt:"createdAt"},t.Prisma.AgentShareScalarFieldEnum={id:"id",agentInstanceId:"agentInstanceId",sharedWithUserId:"sharedWithUserId",createdAt:"createdAt"},t.Prisma.ToolScalarFieldEnum={id:"id",name:"name",description:"description",inputSchema:"inputSchema",outputSchema:"outputSchema",isPublic:"isPublic",createdAt:"createdAt",updatedAt:"updatedAt"},t.Prisma.AICacheScalarFieldEnum={id:"id",prompt:"prompt",content:"content",provider:"provider",createdAt:"createdAt"},t.Prisma.SortOrder={asc:"asc",desc:"desc"},t.Prisma.NullableJsonNullValueInput={DbNull:d.DbNull,JsonNull:d.JsonNull},t.Prisma.JsonNullValueInput={JsonNull:d.JsonNull},t.Prisma.QueryMode={default:"default",insensitive:"insensitive"},t.Prisma.JsonNullValueFilter={DbNull:d.DbNull,JsonNull:d.JsonNull,AnyNull:d.AnyNull},t.Prisma.NullsOrder={first:"first",last:"last"},t.SubscriptionTier=t.$Enums.SubscriptionTier={FREE:"FREE",PREMIUM:"PREMIUM",CREATOR:"CREATOR"},t.UserRole=t.$Enums.UserRole={USER:"USER",CREATOR:"CREATOR",ADMIN:"ADMIN"},t.PostType=t.$Enums.PostType={TEXT:"TEXT",POLL:"POLL",IMAGE:"IMAGE",VIDEO:"VIDEO",LINK:"LINK",PREDICTION:"PREDICTION"},t.FriendshipStatus=t.$Enums.FriendshipStatus={PENDING:"PENDING",ACCEPTED:"ACCEPTED",DECLINED:"DECLINED",BLOCKED:"BLOCKED"},t.NotificationType=t.$Enums.NotificationType={FRIEND_REQUEST:"FRIEND_REQUEST",FRIEND_ACCEPT:"FRIEND_ACCEPT",POST_LIKE:"POST_LIKE",COMMENT_LIKE:"COMMENT_LIKE",NEW_COMMENT:"NEW_COMMENT",REPLY:"REPLY",MENTION:"MENTION",ACHIEVEMENT:"ACHIEVEMENT",SYSTEM:"SYSTEM",NEW_POST:"NEW_POST",NEWS:"NEWS"},t.ReportEntityType=t.$Enums.ReportEntityType={POST:"POST",COMMENT:"COMMENT",USER:"USER"},t.ReportStatus=t.$Enums.ReportStatus={PENDING:"PENDING",REVIEWED:"REVIEWED",RESOLVED:"RESOLVED"},t.Mood=t.$Enums.Mood={GREAT:"GREAT",GOOD:"GOOD",MEH:"MEH",BAD:"BAD",AWFUL:"AWFUL"},t.JournalPromptCategory=t.$Enums.JournalPromptCategory={GRATITUDE:"GRATITUDE",REFLECTION:"REFLECTION",GOAL_SETTING:"GOAL_SETTING"},t.GuideCategory=t.$Enums.GuideCategory={FINANCE:"FINANCE",CAREER:"CAREER"},t.AgentRunStatus=t.$Enums.AgentRunStatus={RUNNING:"RUNNING",COMPLETED:"COMPLETED",FAILED:"FAILED",AWAITING_INPUT:"AWAITING_INPUT"},t.Prisma.ModelName={User:"User",UserSettings:"UserSettings",Account:"Account",Session:"Session",VerificationToken:"VerificationToken",Post:"Post",PostRevision:"PostRevision",PostLike:"PostLike",Comment:"Comment",CommentLike:"CommentLike",NewsArticle:"NewsArticle",NewsArticleLike:"NewsArticleLike",GenZContent:"GenZContent",DailyDigest:"DailyDigest",Friendship:"Friendship",Block:"Block",Circle:"Circle",CircleMembership:"CircleMembership",Poll:"Poll",PollOption:"PollOption",Vote:"Vote",Achievement:"Achievement",UserAchievement:"UserAchievement",Badge:"Badge",UserBadge:"UserBadge",Tip:"Tip",Company:"Company",Job:"Job",JobApplication:"JobApplication",Family:"Family",Event:"Event",EventAttendee:"EventAttendee",Budget:"Budget",Bill:"Bill",Subscription:"Subscription",Transaction:"Transaction",Task:"Task",ProductivityTip:"ProductivityTip",Notification:"Notification",Report:"Report",CustomPersona:"CustomPersona",ApiKey:"ApiKey",AmbassadorMetric:"AmbassadorMetric",MoodLog:"MoodLog",JournalPrompt:"JournalPrompt",JournalEntry:"JournalEntry",Guide:"Guide",GuideView:"GuideView",GuideFavorite:"GuideFavorite",DigitalDetoxPlan:"DigitalDetoxPlan",DigitalDetoxTask:"DigitalDetoxTask",DigitalDetoxProgress:"DigitalDetoxProgress",Changelog:"Changelog",UserChangelogSeen:"UserChangelogSeen",AgentMemory:"AgentMemory",AgentRun:"AgentRun",AgentTemplate:"AgentTemplate",AgentInstance:"AgentInstance",AgentConfigRevision:"AgentConfigRevision",AgentShare:"AgentShare",Tool:"Tool",AICache:"AICache"};t.PrismaClient=class{constructor(){return new Proxy(this,{get(e,t){let n;const r=o();throw n=r.isEdge?`PrismaClient is not configured to run in ${r.prettyName}. In order to run Prisma Client on edge runtime, either:\n- Use Prisma Accelerate: https://pris.ly/d/accelerate\n- Use Driver Adapters: https://pris.ly/d/driver-adapters\n`:"PrismaClient is unable to run in this browser environment, or has been bundled for the browser (running in `"+r.prettyName+"`).",n+="\nIf this is unexpected, please open an issue: https://pris.ly/prisma-prisma-bug-report",new Error(n)}})}},Object.assign(t,d)},e=>{"use strict";var t,n=Object.defineProperty,r=Object.getOwnPropertyDescriptor,i=Object.getOwnPropertyNames,a=Object.prototype.hasOwnProperty,s=(e,t)=>{for(var r in t)n(e,r,{get:t[r],enumerable:!0})},o=(e,t,n)=>t.has(e)?(e=>{throw TypeError(e)})("Cannot add the same private member more than once"):t instanceof WeakSet?t.add(e):t.set(e,n),l={};s(l,{Decimal:()=>yt,Public:()=>d,getRuntime:()=>C,makeStrictEnum:()=>w,objectEnumValues:()=>E}),e.exports=(t=l,((e,t,s,o)=>{if(t&&"object"==typeof t||"function"==typeof t)for(let l of i(t))!a.call(e,l)&&l!==s&&n(e,l,{get:()=>t[l],enumerable:!(o=r(t,l))||o.enumerable});return e})(n({},"__esModule",{value:!0}),t));var d={};function c(...e){return e=>e}s(d,{validator:()=>c});var u,p=Symbol(),h=new WeakMap,y=class{constructor(e){e===p?h.set(this,"Prisma.".concat(this._getName())):h.set(this,"new Prisma.".concat(this._getNamespace(),".").concat(this._getName(),"()"))}_getName(){return this.constructor.name}toString(){return h.get(this)}},m=class extends y{_getNamespace(){return"NullTypes"}},f=class extends m{constructor(){super(...arguments),o(this,u)}};u=new WeakMap,S(f,"DbNull");var b,g=class extends m{constructor(){super(...arguments),o(this,b)}};b=new WeakMap,S(g,"JsonNull");var v,K=class extends m{constructor(){super(...arguments),o(this,v)}};v=new WeakMap,S(K,"AnyNull");var E={classes:{DbNull:f,JsonNull:g,AnyNull:K},instances:{DbNull:new f(p),JsonNull:new g(p),AnyNull:new K(p)}};function S(e,t){Object.defineProperty(e,"name",{value:t,configurable:!0})}var I=new Set(["toJSON","$$typeof","asymmetricMatch",Symbol.iterator,Symbol.toStringTag,Symbol.isConcatSpreadable,Symbol.toPrimitive]);function w(e){return new Proxy(e,{get(e,t){if(t in e)return e[t];if(!I.has(t))throw new TypeError("Invalid enum value: ".concat(String(t)))}})}var k=()=>{var e,t;return"node"===(null==(t=null==(e=globalThis.process)?void 0:e.release)?void 0:t.name)},j=()=>{var e,t;return!!globalThis.Bun||!(null==(t=null==(e=globalThis.process)?void 0:e.versions)||!t.bun)},x=()=>!!globalThis.Deno,T=()=>"object"==typeof globalThis.Netlify,A=()=>"object"==typeof globalThis.EdgeRuntime,O=()=>{var e;return"Cloudflare-Workers"===(null==(e=globalThis.navigator)?void 0:e.userAgent)};var D={node:"Node.js",workerd:"Cloudflare Workers",deno:"Deno and Deno Deploy",netlify:"Netlify Edge Functions","edge-light":"Edge Runtime (Vercel Edge Functions, Vercel Edge Middleware, Next.js (Pages Router) Edge API Routes, Next.js (App Router) Edge Route Handlers or Next.js Middleware)"};function C(){let e=null!=(t=[[T,"netlify"],[A,"edge-light"],[O,"workerd"],[x,"deno"],[j,"bun"],[k,"node"]].flatMap(e=>e[0]()?[e[1]]:[]).at(0))?t:"";var t;return{id:e,prettyName:D[e]||e,isEdge:["workerd","deno","netlify","edge-light"].includes(e)}}var R,P,M=9e15,N=1e9,L="0123456789abcdef",J="2.3025850929940456840179914546843642076011014886287729760333279009675726096773524802359972050895982983419677840422862486334095254650828067566662873690987816894829072083255546808437998948262331985283935053089653777326288461633662222876982198867465436674744042432743651550489343149393914796194044002221051017141748003688084012647080685567743216228355220114804663715659121373450747856947683463616792101806445070648000277502684916746550586856935673420670581136429224554405758925724208241314695689016758940256776311356919292033376587141660230105703089634572075440370847469940168269282808481184289314848524948644871927809676271275775397027668605952496716674183485704422507197965004714951050492214776567636938662976979522110718264549734772662425709429322582798502585509785265383207606726317164309505995087807523710333101197857547331541421808427543863591778117054309827482385045648019095610299291824318237525357709750539565187697510374970888692180205189339507238539205144634197265287286965110862571492198849978748873771345686209167058",_="3.1415926535897932384626433832795028841971693993751058209749445923078164062862089986280348253421170679821480865132823066470938446095505822317253594081284811174502841027019385211055596446229489549303819644288109756659334461284756482337867831652712019091456485669234603486104543266482133936072602491412737245870066063155881748815209209628292540917153643678925903600113305305488204665213841469519415116094330572703657595919530921861173819326117931051185480744623799627495673518857527248912279381830119491298336733624406566430860213949463952247371907021798609437027705392171762931767523846748184676694051320005681271452635608277857713427577896091736371787214684409012249534301465495853710507922796892589235420199561121290219608640344181598136297747713099605187072113499999983729780499510597317328160963185950244594553469083026425223082533446850352619311881710100031378387528865875332083814206171776691473035982534904287554687311595628638823537875937519577818577805321712268066130019278766111959092164201989380952572010654858632789",F={precision:20,rounding:4,modulo:1,toExpNeg:-7,toExpPos:21,minE:-M,maxE:M,crypto:!1},V=!0,G="[DecimalError] ",q=G+"Invalid argument: ",Y=G+"Precision limit exceeded",U=G+"crypto unavailable",B="[object Decimal]",W=Math.floor,z=Math.pow,Q=/^0b([01]+(\.[01]*)?|\.[01]+)(p[+-]?\d+)?$/i,$=/^0x([0-9a-f]+(\.[0-9a-f]*)?|\.[0-9a-f]+)(p[+-]?\d+)?$/i,Z=/^0o([0-7]+(\.[0-7]*)?|\.[0-7]+)(p[+-]?\d+)?$/i,H=/^(\d+(\.\d*)?|\.\d+)(e[+-]?\d+)?$/i,X=1e7,ee=J.length-1,te=_.length-1,ne={toStringTag:B};function re(e){var t,n,r,i=e.length-1,a="",s=e[0];if(i>0){for(a+=s,t=1;t<i;t++)(n=7-(r=e[t]+"").length)&&(a+=ye(n)),a+=r;(n=7-(r=(s=e[t])+"").length)&&(a+=ye(n))}else if(0===s)return"0";for(;s%10==0;)s/=10;return a+s}function ie(e,t,n){if(e!==~~e||e<t||e>n)throw Error(q+e)}function ae(e,t,n,r){var i,a,s,o;for(a=e[0];a>=10;a/=10)--t;return--t<0?(t+=7,i=0):(i=Math.ceil((t+1)/7),t%=7),a=z(10,7-t),o=e[i]%a|0,null==r?t<3?(0==t?o=o/100|0:1==t&&(o=o/10|0),s=n<4&&99999==o||n>3&&49999==o||5e4==o||0==o):s=(n<4&&o+1==a||n>3&&o+1==a/2)&&(e[i+1]/a/100|0)==z(10,t-2)-1||(o==a/2||0==o)&&!(e[i+1]/a/100|0):t<4?(0==t?o=o/1e3|0:1==t?o=o/100|0:2==t&&(o=o/10|0),s=(r||n<4)&&9999==o||!r&&n>3&&4999==o):s=((r||n<4)&&o+1==a||!r&&n>3&&o+1==a/2)&&(e[i+1]/a/1e3|0)==z(10,t-3)-1,s}function se(e,t,n){for(var r,i,a=[0],s=0,o=e.length;s<o;){for(i=a.length;i--;)a[i]*=t;for(a[0]+=L.indexOf(e.charAt(s++)),r=0;r<a.length;r++)a[r]>n-1&&(void 0===a[r+1]&&(a[r+1]=0),a[r+1]+=a[r]/n|0,a[r]%=n)}return a.reverse()}ne.absoluteValue=ne.abs=function(){var e=new this.constructor(this);return e.s<0&&(e.s=1),le(e)},ne.ceil=function(){return le(new this.constructor(this),this.e+1,2)},ne.clampedTo=ne.clamp=function(e,t){var n=this,r=n.constructor;if(e=new r(e),t=new r(t),!e.s||!t.s)return new r(NaN);if(e.gt(t))throw Error(q+t);return n.cmp(e)<0?e:n.cmp(t)>0?t:new r(n)},ne.comparedTo=ne.cmp=function(e){var t,n,r,i,a=this,s=a.d,o=(e=new a.constructor(e)).d,l=a.s,d=e.s;if(!s||!o)return l&&d?l!==d?l:s===o?0:!s^l<0?1:-1:NaN;if(!s[0]||!o[0])return s[0]?l:o[0]?-d:0;if(l!==d)return l;if(a.e!==e.e)return a.e>e.e^l<0?1:-1;for(t=0,n=(r=s.length)<(i=o.length)?r:i;t<n;++t)if(s[t]!==o[t])return s[t]>o[t]^l<0?1:-1;return r===i?0:r>i^l<0?1:-1},ne.cosine=ne.cos=function(){var e,t,n=this,r=n.constructor;return n.d?n.d[0]?(e=r.precision,t=r.rounding,r.precision=e+Math.max(n.e,n.sd())+7,r.rounding=1,n=function(e,t){var n,r,i;if(t.isZero())return t;r=t.d.length,r<32?(n=Math.ceil(r/3),i=(1/Ie(4,n)).toString()):(n=16,i="2.3283064365386962890625e-10"),e.precision+=n,t=Se(e,1,t.times(i),new e(1));for(var a=n;a--;){var s=t.times(t);t=s.times(s).minus(s).times(8).plus(1)}return e.precision-=n,t}(r,we(r,n)),r.precision=e,r.rounding=t,le(2==P||3==P?n.neg():n,e,t,!0)):new r(1):new r(NaN)},ne.cubeRoot=ne.cbrt=function(){var e,t,n,r,i,a,s,o,l,d,c=this,u=c.constructor;if(!c.isFinite()||c.isZero())return new u(c);for(V=!1,(a=c.s*z(c.s*c,1/3))&&Math.abs(a)!=1/0?r=new u(a.toString()):(n=re(c.d),(a=((e=c.e)-n.length+1)%3)&&(n+=1==a||-2==a?"0":"00"),a=z(n,1/3),e=W((e+1)/3)-(e%3==(e<0?-1:2)),a==1/0?n="5e"+e:n=(n=a.toExponential()).slice(0,n.indexOf("e")+1)+e,(r=new u(n)).s=c.s),s=(e=u.precision)+3;;)if(d=(l=(o=r).times(o).times(o)).plus(c),r=oe(d.plus(c).times(o),d.plus(l),s+2,1),re(o.d).slice(0,s)===(n=re(r.d)).slice(0,s)){if("9999"!=(n=n.slice(s-3,s+1))&&(i||"4999"!=n)){(!+n||!+n.slice(1)&&"5"==n.charAt(0))&&(le(r,e+1,1),t=!r.times(r).times(r).eq(c));break}if(!i&&(le(o,e+1,0),o.times(o).times(o).eq(c))){r=o;break}s+=4,i=1}return V=!0,le(r,e,u.rounding,t)},ne.decimalPlaces=ne.dp=function(){var e,t=this.d,n=NaN;if(t){if(n=7*((e=t.length-1)-W(this.e/7)),e=t[e])for(;e%10==0;e/=10)n--;n<0&&(n=0)}return n},ne.dividedBy=ne.div=function(e){return oe(this,new this.constructor(e))},ne.dividedToIntegerBy=ne.divToInt=function(e){var t=this.constructor;return le(oe(this,new t(e),0,1,1),t.precision,t.rounding)},ne.equals=ne.eq=function(e){return 0===this.cmp(e)},ne.floor=function(){return le(new this.constructor(this),this.e+1,3)},ne.greaterThan=ne.gt=function(e){return this.cmp(e)>0},ne.greaterThanOrEqualTo=ne.gte=function(e){var t=this.cmp(e);return 1==t||0===t},ne.hyperbolicCosine=ne.cosh=function(){var e,t,n,r,i,a=this,s=a.constructor,o=new s(1);if(!a.isFinite())return new s(a.s?1/0:NaN);if(a.isZero())return o;n=s.precision,r=s.rounding,s.precision=n+Math.max(a.e,a.sd())+4,s.rounding=1,(i=a.d.length)<32?t=(1/Ie(4,e=Math.ceil(i/3))).toString():(e=16,t="2.3283064365386962890625e-10"),a=Se(s,1,a.times(t),new s(1),!0);for(var l,d=e,c=new s(8);d--;)l=a.times(a),a=o.minus(l.times(c.minus(l.times(c))));return le(a,s.precision=n,s.rounding=r,!0)},ne.hyperbolicSine=ne.sinh=function(){var e,t,n,r,i=this,a=i.constructor;if(!i.isFinite()||i.isZero())return new a(i);if(t=a.precision,n=a.rounding,a.precision=t+Math.max(i.e,i.sd())+4,a.rounding=1,(r=i.d.length)<3)i=Se(a,2,i,i,!0);else{e=(e=1.4*Math.sqrt(r))>16?16:0|e,i=Se(a,2,i=i.times(1/Ie(5,e)),i,!0);for(var s,o=new a(5),l=new a(16),d=new a(20);e--;)s=i.times(i),i=i.times(o.plus(s.times(l.times(s).plus(d))))}return a.precision=t,a.rounding=n,le(i,t,n,!0)},ne.hyperbolicTangent=ne.tanh=function(){var e,t,n=this,r=n.constructor;return n.isFinite()?n.isZero()?new r(n):(e=r.precision,t=r.rounding,r.precision=e+7,r.rounding=1,oe(n.sinh(),n.cosh(),r.precision=e,r.rounding=t)):new r(n.s)},ne.inverseCosine=ne.acos=function(){var e=this,t=e.constructor,n=e.abs().cmp(1),r=t.precision,i=t.rounding;return-1!==n?0===n?e.isNeg()?pe(t,r,i):new t(0):new t(NaN):e.isZero()?pe(t,r+4,i).times(.5):(t.precision=r+6,t.rounding=1,e=new t(1).minus(e).div(e.plus(1)).sqrt().atan(),t.precision=r,t.rounding=i,e.times(2))},ne.inverseHyperbolicCosine=ne.acosh=function(){var e,t,n=this,r=n.constructor;return n.lte(1)?new r(n.eq(1)?0:NaN):n.isFinite()?(e=r.precision,t=r.rounding,r.precision=e+Math.max(Math.abs(n.e),n.sd())+4,r.rounding=1,V=!1,n=n.times(n).minus(1).sqrt().plus(n),V=!0,r.precision=e,r.rounding=t,n.ln()):new r(n)},ne.inverseHyperbolicSine=ne.asinh=function(){var e,t,n=this,r=n.constructor;return!n.isFinite()||n.isZero()?new r(n):(e=r.precision,t=r.rounding,r.precision=e+2*Math.max(Math.abs(n.e),n.sd())+6,r.rounding=1,V=!1,n=n.times(n).plus(1).sqrt().plus(n),V=!0,r.precision=e,r.rounding=t,n.ln())},ne.inverseHyperbolicTangent=ne.atanh=function(){var e,t,n,r,i=this,a=i.constructor;return i.isFinite()?i.e>=0?new a(i.abs().eq(1)?i.s/0:i.isZero()?i:NaN):(e=a.precision,t=a.rounding,r=i.sd(),Math.max(r,e)<2*-i.e-1?le(new a(i),e,t,!0):(a.precision=n=r-i.e,i=oe(i.plus(1),new a(1).minus(i),n+e,1),a.precision=e+4,a.rounding=1,i=i.ln(),a.precision=e,a.rounding=t,i.times(.5))):new a(NaN)},ne.inverseSine=ne.asin=function(){var e,t,n,r,i=this,a=i.constructor;return i.isZero()?new a(i):(t=i.abs().cmp(1),n=a.precision,r=a.rounding,-1!==t?0===t?((e=pe(a,n+4,r).times(.5)).s=i.s,e):new a(NaN):(a.precision=n+6,a.rounding=1,i=i.div(new a(1).minus(i.times(i)).sqrt().plus(1)).atan(),a.precision=n,a.rounding=r,i.times(2)))},ne.inverseTangent=ne.atan=function(){var e,t,n,r,i,a,s,o,l,d=this,c=d.constructor,u=c.precision,p=c.rounding;if(d.isFinite()){if(d.isZero())return new c(d);if(d.abs().eq(1)&&u+4<=te)return(s=pe(c,u+4,p).times(.25)).s=d.s,s}else{if(!d.s)return new c(NaN);if(u+4<=te)return(s=pe(c,u+4,p).times(.5)).s=d.s,s}for(c.precision=o=u+10,c.rounding=1,e=n=Math.min(28,o/7+2|0);e;--e)d=d.div(d.times(d).plus(1).sqrt().plus(1));for(V=!1,t=Math.ceil(o/7),r=1,l=d.times(d),s=new c(d),i=d;-1!==e;)if(i=i.times(l),a=s.minus(i.div(r+=2)),i=i.times(l),void 0!==(s=a.plus(i.div(r+=2))).d[t])for(e=t;s.d[e]===a.d[e]&&e--;);return n&&(s=s.times(2<<n-1)),V=!0,le(s,c.precision=u,c.rounding=p,!0)},ne.isFinite=function(){return!!this.d},ne.isInteger=ne.isInt=function(){return!!this.d&&W(this.e/7)>this.d.length-2},ne.isNaN=function(){return!this.s},ne.isNegative=ne.isNeg=function(){return this.s<0},ne.isPositive=ne.isPos=function(){return this.s>0},ne.isZero=function(){return!!this.d&&0===this.d[0]},ne.lessThan=ne.lt=function(e){return this.cmp(e)<0},ne.lessThanOrEqualTo=ne.lte=function(e){return this.cmp(e)<1},ne.logarithm=ne.log=function(e){var t,n,r,i,a,s,o,l,d=this,c=d.constructor,u=c.precision,p=c.rounding;if(null==e)e=new c(10),t=!0;else{if(n=(e=new c(e)).d,e.s<0||!n||!n[0]||e.eq(1))return new c(NaN);t=e.eq(10)}if(n=d.d,d.s<0||!n||!n[0]||d.eq(1))return new c(n&&!n[0]?-1/0:1!=d.s?NaN:n?0:1/0);if(t)if(n.length>1)a=!0;else{for(i=n[0];i%10==0;)i/=10;a=1!==i}if(V=!1,s=ve(d,o=u+5),r=t?ue(c,o+10):ve(e,o),ae((l=oe(s,r,o,1)).d,i=u,p))do{if(s=ve(d,o+=10),r=t?ue(c,o+10):ve(e,o),l=oe(s,r,o,1),!a){+re(l.d).slice(i+1,i+15)+1==1e14&&(l=le(l,u+1,0));break}}while(ae(l.d,i+=10,p));return V=!0,le(l,u,p)},ne.minus=ne.sub=function(e){var t,n,r,i,a,s,o,l,d,c,u,p,h=this,y=h.constructor;if(e=new y(e),!h.d||!e.d)return h.s&&e.s?h.d?e.s=-e.s:e=new y(e.d||h.s!==e.s?h:NaN):e=new y(NaN),e;if(h.s!=e.s)return e.s=-e.s,h.plus(e);if(d=h.d,p=e.d,o=y.precision,l=y.rounding,!d[0]||!p[0]){if(p[0])e.s=-e.s;else{if(!d[0])return new y(3===l?-0:0);e=new y(h)}return V?le(e,o,l):e}if(n=W(e.e/7),c=W(h.e/7),d=d.slice(),a=c-n){for((u=a<0)?(t=d,a=-a,s=p.length):(t=p,n=c,s=d.length),a>(r=Math.max(Math.ceil(o/7),s)+2)&&(a=r,t.length=1),t.reverse(),r=a;r--;)t.push(0);t.reverse()}else{for((u=(r=d.length)<(s=p.length))&&(s=r),r=0;r<s;r++)if(d[r]!=p[r]){u=d[r]<p[r];break}a=0}for(u&&(t=d,d=p,p=t,e.s=-e.s),s=d.length,r=p.length-s;r>0;--r)d[s++]=0;for(r=p.length;r>a;){if(d[--r]<p[r]){for(i=r;i&&0===d[--i];)d[i]=X-1;--d[i],d[r]+=X}d[r]-=p[r]}for(;0===d[--s];)d.pop();for(;0===d[0];d.shift())--n;return d[0]?(e.d=d,e.e=ce(d,n),V?le(e,o,l):e):new y(3===l?-0:0)},ne.modulo=ne.mod=function(e){var t,n=this,r=n.constructor;return e=new r(e),!n.d||!e.s||e.d&&!e.d[0]?new r(NaN):!e.d||n.d&&!n.d[0]?le(new r(n),r.precision,r.rounding):(V=!1,9==r.modulo?(t=oe(n,e.abs(),0,3,1)).s*=e.s:t=oe(n,e,0,r.modulo,1),t=t.times(e),V=!0,n.minus(t))},ne.naturalExponential=ne.exp=function(){return ge(this)},ne.naturalLogarithm=ne.ln=function(){return ve(this)},ne.negated=ne.neg=function(){var e=new this.constructor(this);return e.s=-e.s,le(e)},ne.plus=ne.add=function(e){var t,n,r,i,a,s,o,l,d,c,u=this,p=u.constructor;if(e=new p(e),!u.d||!e.d)return u.s&&e.s?u.d||(e=new p(e.d||u.s===e.s?u:NaN)):e=new p(NaN),e;if(u.s!=e.s)return e.s=-e.s,u.minus(e);if(d=u.d,c=e.d,o=p.precision,l=p.rounding,!d[0]||!c[0])return c[0]||(e=new p(u)),V?le(e,o,l):e;if(a=W(u.e/7),r=W(e.e/7),d=d.slice(),i=a-r){for(i<0?(n=d,i=-i,s=c.length):(n=c,r=a,s=d.length),i>(s=(a=Math.ceil(o/7))>s?a+1:s+1)&&(i=s,n.length=1),n.reverse();i--;)n.push(0);n.reverse()}for((s=d.length)-(i=c.length)<0&&(i=s,n=c,c=d,d=n),t=0;i;)t=(d[--i]=d[i]+c[i]+t)/X|0,d[i]%=X;for(t&&(d.unshift(t),++r),s=d.length;0==d[--s];)d.pop();return e.d=d,e.e=ce(d,r),V?le(e,o,l):e},ne.precision=ne.sd=function(e){var t,n=this;if(void 0!==e&&e!==!!e&&1!==e&&0!==e)throw Error(q+e);return n.d?(t=he(n.d),e&&n.e+1>t&&(t=n.e+1)):t=NaN,t},ne.round=function(){var e=this,t=e.constructor;return le(new t(e),e.e+1,t.rounding)},ne.sine=ne.sin=function(){var e,t,n=this,r=n.constructor;return n.isFinite()?n.isZero()?new r(n):(e=r.precision,t=r.rounding,r.precision=e+Math.max(n.e,n.sd())+7,r.rounding=1,n=function(e,t){var n,r=t.d.length;if(r<3)return t.isZero()?t:Se(e,2,t,t);n=1.4*Math.sqrt(r),n=n>16?16:0|n,t=t.times(1/Ie(5,n)),t=Se(e,2,t,t);for(var i,a=new e(5),s=new e(16),o=new e(20);n--;)i=t.times(t),t=t.times(a.plus(i.times(s.times(i).minus(o))));return t}(r,we(r,n)),r.precision=e,r.rounding=t,le(P>2?n.neg():n,e,t,!0)):new r(NaN)},ne.squareRoot=ne.sqrt=function(){var e,t,n,r,i,a,s=this,o=s.d,l=s.e,d=s.s,c=s.constructor;if(1!==d||!o||!o[0])return new c(!d||d<0&&(!o||o[0])?NaN:o?s:1/0);for(V=!1,0==(d=Math.sqrt(+s))||d==1/0?(((t=re(o)).length+l)%2==0&&(t+="0"),d=Math.sqrt(t),l=W((l+1)/2)-(l<0||l%2),d==1/0?t="5e"+l:t=(t=d.toExponential()).slice(0,t.indexOf("e")+1)+l,r=new c(t)):r=new c(d.toString()),n=(l=c.precision)+3;;)if(r=(a=r).plus(oe(s,a,n+2,1)).times(.5),re(a.d).slice(0,n)===(t=re(r.d)).slice(0,n)){if("9999"!=(t=t.slice(n-3,n+1))&&(i||"4999"!=t)){(!+t||!+t.slice(1)&&"5"==t.charAt(0))&&(le(r,l+1,1),e=!r.times(r).eq(s));break}if(!i&&(le(a,l+1,0),a.times(a).eq(s))){r=a;break}n+=4,i=1}return V=!0,le(r,l,c.rounding,e)},ne.tangent=ne.tan=function(){var e,t,n=this,r=n.constructor;return n.isFinite()?n.isZero()?new r(n):(e=r.precision,t=r.rounding,r.precision=e+10,r.rounding=1,(n=n.sin()).s=1,n=oe(n,new r(1).minus(n.times(n)).sqrt(),e+10,0),r.precision=e,r.rounding=t,le(2==P||4==P?n.neg():n,e,t,!0)):new r(NaN)},ne.times=ne.mul=function(e){var t,n,r,i,a,s,o,l,d,c=this,u=c.constructor,p=c.d,h=(e=new u(e)).d;if(e.s*=c.s,!(p&&p[0]&&h&&h[0]))return new u(!e.s||p&&!p[0]&&!h||h&&!h[0]&&!p?NaN:p&&h?0*e.s:e.s/0);for(n=W(c.e/7)+W(e.e/7),(l=p.length)<(d=h.length)&&(a=p,p=h,h=a,s=l,l=d,d=s),a=[],r=s=l+d;r--;)a.push(0);for(r=d;--r>=0;){for(t=0,i=l+r;i>r;)o=a[i]+h[r]*p[i-r-1]+t,a[i--]=o%X|0,t=o/X|0;a[i]=(a[i]+t)%X|0}for(;!a[--s];)a.pop();return t?++n:a.shift(),e.d=a,e.e=ce(a,n),V?le(e,u.precision,u.rounding):e},ne.toBinary=function(e,t){return ke(this,2,e,t)},ne.toDecimalPlaces=ne.toDP=function(e,t){var n=this,r=n.constructor;return n=new r(n),void 0===e?n:(ie(e,0,N),void 0===t?t=r.rounding:ie(t,0,8),le(n,e+n.e+1,t))},ne.toExponential=function(e,t){var n,r=this,i=r.constructor;return void 0===e?n=de(r,!0):(ie(e,0,N),void 0===t?t=i.rounding:ie(t,0,8),n=de(r=le(new i(r),e+1,t),!0,e+1)),r.isNeg()&&!r.isZero()?"-"+n:n},ne.toFixed=function(e,t){var n,r,i=this,a=i.constructor;return void 0===e?n=de(i):(ie(e,0,N),void 0===t?t=a.rounding:ie(t,0,8),n=de(r=le(new a(i),e+i.e+1,t),!1,e+r.e+1)),i.isNeg()&&!i.isZero()?"-"+n:n},ne.toFraction=function(e){var t,n,r,i,a,s,o,l,d,c,u,p,h=this,y=h.d,m=h.constructor;if(!y)return new m(h);if(d=n=new m(1),r=l=new m(0),s=(a=(t=new m(r)).e=he(y)-h.e-1)%7,t.d[0]=z(10,s<0?7+s:s),null==e)e=a>0?t:d;else{if(!(o=new m(e)).isInt()||o.lt(d))throw Error(q+o);e=o.gt(t)?a>0?t:d:o}for(V=!1,o=new m(re(y)),c=m.precision,m.precision=a=7*y.length*2;u=oe(o,t,0,1,1),1!=(i=n.plus(u.times(r))).cmp(e);)n=r,r=i,i=d,d=l.plus(u.times(i)),l=i,i=t,t=o.minus(u.times(i)),o=i;return i=oe(e.minus(n),r,0,1,1),l=l.plus(i.times(d)),n=n.plus(i.times(r)),l.s=d.s=h.s,p=oe(d,r,a,1).minus(h).abs().cmp(oe(l,n,a,1).minus(h).abs())<1?[d,r]:[l,n],m.precision=c,V=!0,p},ne.toHexadecimal=ne.toHex=function(e,t){return ke(this,16,e,t)},ne.toNearest=function(e,t){var n=this,r=n.constructor;if(n=new r(n),null==e){if(!n.d)return n;e=new r(1),t=r.rounding}else{if(e=new r(e),void 0===t?t=r.rounding:ie(t,0,8),!n.d)return e.s?n:e;if(!e.d)return e.s&&(e.s=n.s),e}return e.d[0]?(V=!1,n=oe(n,e,0,t,1).times(e),V=!0,le(n)):(e.s=n.s,n=e),n},ne.toNumber=function(){return+this},ne.toOctal=function(e,t){return ke(this,8,e,t)},ne.toPower=ne.pow=function(e){var t,n,r,i,a,s,o=this,l=o.constructor,d=+(e=new l(e));if(!(o.d&&e.d&&o.d[0]&&e.d[0]))return new l(z(+o,d));if((o=new l(o)).eq(1))return o;if(r=l.precision,a=l.rounding,e.eq(1))return le(o,r,a);if((t=W(e.e/7))>=e.d.length-1&&(n=d<0?-d:d)<=9007199254740991)return i=me(l,o,n,r),e.s<0?new l(1).div(i):le(i,r,a);if((s=o.s)<0){if(t<e.d.length-1)return new l(NaN);if(!(1&e.d[t])&&(s=1),0==o.e&&1==o.d[0]&&1==o.d.length)return o.s=s,o}return(t=0!=(n=z(+o,d))&&isFinite(n)?new l(n+"").e:W(d*(Math.log("0."+re(o.d))/Math.LN10+o.e+1)))>l.maxE+1||t<l.minE-1?new l(t>0?s/0:0):(V=!1,l.rounding=o.s=1,n=Math.min(12,(t+"").length),(i=ge(e.times(ve(o,r+n)),r)).d&&(ae((i=le(i,r+5,1)).d,r,a)&&(t=r+10,+re((i=le(ge(e.times(ve(o,t+n)),t),t+5,1)).d).slice(r+1,r+15)+1==1e14&&(i=le(i,r+1,0)))),i.s=s,V=!0,l.rounding=a,le(i,r,a))},ne.toPrecision=function(e,t){var n,r=this,i=r.constructor;return void 0===e?n=de(r,r.e<=i.toExpNeg||r.e>=i.toExpPos):(ie(e,1,N),void 0===t?t=i.rounding:ie(t,0,8),n=de(r=le(new i(r),e,t),e<=r.e||r.e<=i.toExpNeg,e)),r.isNeg()&&!r.isZero()?"-"+n:n},ne.toSignificantDigits=ne.toSD=function(e,t){var n=this.constructor;return void 0===e?(e=n.precision,t=n.rounding):(ie(e,1,N),void 0===t?t=n.rounding:ie(t,0,8)),le(new n(this),e,t)},ne.toString=function(){var e=this,t=e.constructor,n=de(e,e.e<=t.toExpNeg||e.e>=t.toExpPos);return e.isNeg()&&!e.isZero()?"-"+n:n},ne.truncated=ne.trunc=function(){return le(new this.constructor(this),this.e+1,1)},ne.valueOf=ne.toJSON=function(){var e=this,t=e.constructor,n=de(e,e.e<=t.toExpNeg||e.e>=t.toExpPos);return e.isNeg()?"-"+n:n};var oe=function(){function e(e,t,n){var r,i=0,a=e.length;for(e=e.slice();a--;)r=e[a]*t+i,e[a]=r%n|0,i=r/n|0;return i&&e.unshift(i),e}function t(e,t,n,r){var i,a;if(n!=r)a=n>r?1:-1;else for(i=a=0;i<n;i++)if(e[i]!=t[i]){a=e[i]>t[i]?1:-1;break}return a}function n(e,t,n,r){for(var i=0;n--;)e[n]-=i,i=e[n]<t[n]?1:0,e[n]=i*r+e[n]-t[n];for(;!e[0]&&e.length>1;)e.shift()}return function(r,i,a,s,o,l){var d,c,u,p,h,y,m,f,b,g,v,K,E,S,I,w,k,j,x,T,A=r.constructor,O=r.s==i.s?1:-1,D=r.d,C=i.d;if(!(D&&D[0]&&C&&C[0]))return new A(r.s&&i.s&&(D?!C||D[0]!=C[0]:C)?D&&0==D[0]||!C?0*O:O/0:NaN);for(l?(h=1,c=r.e-i.e):(l=X,h=7,c=W(r.e/h)-W(i.e/h)),x=C.length,k=D.length,g=(b=new A(O)).d=[],u=0;C[u]==(D[u]||0);u++);if(C[u]>(D[u]||0)&&c--,null==a?(S=a=A.precision,s=A.rounding):S=o?a+(r.e-i.e)+1:a,S<0)g.push(1),y=!0;else{if(S=S/h+2|0,u=0,1==x){for(p=0,C=C[0],S++;(u<k||p)&&S--;u++)I=p*l+(D[u]||0),g[u]=I/C|0,p=I%C|0;y=p||u<k}else{for((p=l/(C[0]+1)|0)>1&&(C=e(C,p,l),D=e(D,p,l),x=C.length,k=D.length),w=x,K=(v=D.slice(0,x)).length;K<x;)v[K++]=0;(T=C.slice()).unshift(0),j=C[0],C[1]>=l/2&&++j;do{p=0,(d=t(C,v,x,K))<0?(E=v[0],x!=K&&(E=E*l+(v[1]||0)),(p=E/j|0)>1?(p>=l&&(p=l-1),1==(d=t(m=e(C,p,l),v,f=m.length,K=v.length))&&(p--,n(m,x<f?T:C,f,l))):(0==p&&(d=p=1),m=C.slice()),(f=m.length)<K&&m.unshift(0),n(v,m,K,l),-1==d&&((d=t(C,v,x,K=v.length))<1&&(p++,n(v,x<K?T:C,K,l))),K=v.length):0===d&&(p++,v=[0]),g[u++]=p,d&&v[0]?v[K++]=D[w]||0:(v=[D[w]],K=1)}while((w++<k||void 0!==v[0])&&S--);y=void 0!==v[0]}g[0]||g.shift()}if(1==h)b.e=c,R=y;else{for(u=1,p=g[0];p>=10;p/=10)u++;b.e=u+c*h-1,le(b,o?a+b.e+1:a,s,y)}return b}}();function le(e,t,n,r){var i,a,s,o,l,d,c,u,p,h=e.constructor;e:if(null!=t){if(!(u=e.d))return e;for(i=1,o=u[0];o>=10;o/=10)i++;if((a=t-i)<0)a+=7,s=t,l=(c=u[p=0])/z(10,i-s-1)%10|0;else if((p=Math.ceil((a+1)/7))>=(o=u.length)){if(!r)break e;for(;o++<=p;)u.push(0);c=l=0,i=1,s=(a%=7)-7+1}else{for(c=o=u[p],i=1;o>=10;o/=10)i++;l=(s=(a%=7)-7+i)<0?0:c/z(10,i-s-1)%10|0}if(r=r||t<0||void 0!==u[p+1]||(s<0?c:c%z(10,i-s-1)),d=n<4?(l||r)&&(0==n||n==(e.s<0?3:2)):l>5||5==l&&(4==n||r||6==n&&(a>0?s>0?c/z(10,i-s):0:u[p-1])%10&1||n==(e.s<0?8:7)),t<1||!u[0])return u.length=0,d?(t-=e.e+1,u[0]=z(10,(7-t%7)%7),e.e=-t||0):u[0]=e.e=0,e;if(0==a?(u.length=p,o=1,p--):(u.length=p+1,o=z(10,7-a),u[p]=s>0?(c/z(10,i-s)%z(10,s)|0)*o:0),d)for(;;){if(0==p){for(a=1,s=u[0];s>=10;s/=10)a++;for(s=u[0]+=o,o=1;s>=10;s/=10)o++;a!=o&&(e.e++,u[0]==X&&(u[0]=1));break}if(u[p]+=o,u[p]!=X)break;u[p--]=0,o=1}for(a=u.length;0===u[--a];)u.pop()}return V&&(e.e>h.maxE?(e.d=null,e.e=NaN):e.e<h.minE&&(e.e=0,e.d=[0])),e}function de(e,t,n){if(!e.isFinite())return Ke(e);var r,i=e.e,a=re(e.d),s=a.length;return t?(n&&(r=n-s)>0?a=a.charAt(0)+"."+a.slice(1)+ye(r):s>1&&(a=a.charAt(0)+"."+a.slice(1)),a=a+(e.e<0?"e":"e+")+e.e):i<0?(a="0."+ye(-i-1)+a,n&&(r=n-s)>0&&(a+=ye(r))):i>=s?(a+=ye(i+1-s),n&&(r=n-i-1)>0&&(a=a+"."+ye(r))):((r=i+1)<s&&(a=a.slice(0,r)+"."+a.slice(r)),n&&(r=n-s)>0&&(i+1===s&&(a+="."),a+=ye(r))),a}function ce(e,t){var n=e[0];for(t*=7;n>=10;n/=10)t++;return t}function ue(e,t,n){if(t>ee)throw V=!0,n&&(e.precision=n),Error(Y);return le(new e(J),t,1,!0)}function pe(e,t,n){if(t>te)throw Error(Y);return le(new e(_),t,n,!0)}function he(e){var t=e.length-1,n=7*t+1;if(t=e[t]){for(;t%10==0;t/=10)n--;for(t=e[0];t>=10;t/=10)n++}return n}function ye(e){for(var t="";e--;)t+="0";return t}function me(e,t,n,r){var i,a=new e(1),s=Math.ceil(r/7+4);for(V=!1;;){if(n%2&&(je((a=a.times(t)).d,s)&&(i=!0)),0===(n=W(n/2))){n=a.d.length-1,i&&0===a.d[n]&&++a.d[n];break}je((t=t.times(t)).d,s)}return V=!0,a}function fe(e){return 1&e.d[e.d.length-1]}function be(e,t,n){for(var r,i,a=new e(t[0]),s=0;++s<t.length;){if(!(i=new e(t[s])).s){a=i;break}((r=a.cmp(i))===n||0===r&&a.s===n)&&(a=i)}return a}function ge(e,t){var n,r,i,a,s,o,l,d=0,c=0,u=0,p=e.constructor,h=p.rounding,y=p.precision;if(!e.d||!e.d[0]||e.e>17)return new p(e.d?e.d[0]?e.s<0?0:1/0:1:e.s?e.s<0?0:e:NaN);for(null==t?(V=!1,l=y):l=t,o=new p(.03125);e.e>-2;)e=e.times(o),u+=5;for(l+=r=Math.log(z(2,u))/Math.LN10*2+5|0,n=a=s=new p(1),p.precision=l;;){if(a=le(a.times(e),l,1),n=n.times(++c),re((o=s.plus(oe(a,n,l,1))).d).slice(0,l)===re(s.d).slice(0,l)){for(i=u;i--;)s=le(s.times(s),l,1);if(null!=t)return p.precision=y,s;if(!(d<3&&ae(s.d,l-r,h,d)))return le(s,p.precision=y,h,V=!0);p.precision=l+=10,n=a=o=new p(1),c=0,d++}s=o}}function ve(e,t){var n,r,i,a,s,o,l,d,c,u,p,h=1,y=e,m=y.d,f=y.constructor,b=f.rounding,g=f.precision;if(y.s<0||!m||!m[0]||!y.e&&1==m[0]&&1==m.length)return new f(m&&!m[0]?-1/0:1!=y.s?NaN:m?0:y);if(null==t?(V=!1,c=g):c=t,f.precision=c+=10,r=(n=re(m)).charAt(0),!(Math.abs(a=y.e)<15e14))return d=ue(f,c+2,g).times(a+""),y=ve(new f(r+"."+n.slice(1)),c-10).plus(d),f.precision=g,null==t?le(y,g,b,V=!0):y;for(;r<7&&1!=r||1==r&&n.charAt(1)>3;)r=(n=re((y=y.times(e)).d)).charAt(0),h++;for(a=y.e,r>1?(y=new f("0."+n),a++):y=new f(r+"."+n.slice(1)),u=y,l=s=y=oe(y.minus(1),y.plus(1),c,1),p=le(y.times(y),c,1),i=3;;){if(s=le(s.times(p),c,1),re((d=l.plus(oe(s,new f(i),c,1))).d).slice(0,c)===re(l.d).slice(0,c)){if(l=l.times(2),0!==a&&(l=l.plus(ue(f,c+2,g).times(a+""))),l=oe(l,new f(h),c,1),null!=t)return f.precision=g,l;if(!ae(l.d,c-10,b,o))return le(l,f.precision=g,b,V=!0);f.precision=c+=10,d=s=y=oe(u.minus(1),u.plus(1),c,1),p=le(y.times(y),c,1),i=o=1}l=d,i+=2}}function Ke(e){return String(e.s*e.s/0)}function Ee(e,t){var n,r,i;for((n=t.indexOf("."))>-1&&(t=t.replace(".","")),(r=t.search(/e/i))>0?(n<0&&(n=r),n+=+t.slice(r+1),t=t.substring(0,r)):n<0&&(n=t.length),r=0;48===t.charCodeAt(r);r++);for(i=t.length;48===t.charCodeAt(i-1);--i);if(t=t.slice(r,i)){if(i-=r,e.e=n=n-r-1,e.d=[],r=(n+1)%7,n<0&&(r+=7),r<i){for(r&&e.d.push(+t.slice(0,r)),i-=7;r<i;)e.d.push(+t.slice(r,r+=7));r=7-(t=t.slice(r)).length}else r-=i;for(;r--;)t+="0";e.d.push(+t),V&&(e.e>e.constructor.maxE?(e.d=null,e.e=NaN):e.e<e.constructor.minE&&(e.e=0,e.d=[0]))}else e.e=0,e.d=[0];return e}function Se(e,t,n,r,i){var a,s,o,l,d=e.precision,c=Math.ceil(d/7);for(V=!1,l=n.times(n),o=new e(r);;){if(s=oe(o.times(l),new e(t++*t++),d,1),o=i?r.plus(s):r.minus(s),r=oe(s.times(l),new e(t++*t++),d,1),void 0!==(s=o.plus(r)).d[c]){for(a=c;s.d[a]===o.d[a]&&a--;);if(-1==a)break}a=o,o=r,r=s,s=a}return V=!0,s.d.length=c+1,s}function Ie(e,t){for(var n=e;--t;)n*=e;return n}function we(e,t){var n,r=t.s<0,i=pe(e,e.precision,1),a=i.times(.5);if((t=t.abs()).lte(a))return P=r?4:1,t;if((n=t.divToInt(i)).isZero())P=r?3:2;else{if((t=t.minus(n.times(i))).lte(a))return P=fe(n)?r?2:3:r?4:1,t;P=fe(n)?r?1:4:r?3:2}return t.minus(i).abs()}function ke(e,t,n,r){var i,a,s,o,l,d,c,u,p,h=e.constructor,y=void 0!==n;if(y?(ie(n,1,N),void 0===r?r=h.rounding:ie(r,0,8)):(n=h.precision,r=h.rounding),e.isFinite()){for(y?(i=2,16==t?n=4*n-3:8==t&&(n=3*n-2)):i=t,(s=(c=de(e)).indexOf("."))>=0&&(c=c.replace(".",""),(p=new h(1)).e=c.length-s,p.d=se(de(p),10,i),p.e=p.d.length),a=l=(u=se(c,10,i)).length;0==u[--l];)u.pop();if(u[0]){if(s<0?a--:((e=new h(e)).d=u,e.e=a,u=(e=oe(e,p,n,r,0,i)).d,a=e.e,d=R),s=u[n],o=i/2,d=d||void 0!==u[n+1],d=r<4?(void 0!==s||d)&&(0===r||r===(e.s<0?3:2)):s>o||s===o&&(4===r||d||6===r&&1&u[n-1]||r===(e.s<0?8:7)),u.length=n,d)for(;++u[--n]>i-1;)u[n]=0,n||(++a,u.unshift(1));for(l=u.length;!u[l-1];--l);for(s=0,c="";s<l;s++)c+=L.charAt(u[s]);if(y){if(l>1)if(16==t||8==t){for(s=16==t?4:3,--l;l%s;l++)c+="0";for(l=(u=se(c,i,t)).length;!u[l-1];--l);for(s=1,c="1.";s<l;s++)c+=L.charAt(u[s])}else c=c.charAt(0)+"."+c.slice(1);c=c+(a<0?"p":"p+")+a}else if(a<0){for(;++a;)c="0"+c;c="0."+c}else if(++a>l)for(a-=l;a--;)c+="0";else a<l&&(c=c.slice(0,a)+"."+c.slice(a))}else c=y?"0p+0":"0";c=(16==t?"0x":2==t?"0b":8==t?"0o":"")+c}else c=Ke(e);return e.s<0?"-"+c:c}function je(e,t){if(e.length>t)return e.length=t,!0}function xe(e){return new this(e).abs()}function Te(e){return new this(e).acos()}function Ae(e){return new this(e).acosh()}function Oe(e,t){return new this(e).plus(t)}function De(e){return new this(e).asin()}function Ce(e){return new this(e).asinh()}function Re(e){return new this(e).atan()}function Pe(e){return new this(e).atanh()}function Me(e,t){e=new this(e),t=new this(t);var n,r=this.precision,i=this.rounding,a=r+4;return e.s&&t.s?e.d||t.d?!t.d||e.isZero()?(n=t.s<0?pe(this,r,i):new this(0)).s=e.s:!e.d||t.isZero()?(n=pe(this,a,1).times(.5)).s=e.s:t.s<0?(this.precision=a,this.rounding=1,n=this.atan(oe(e,t,a,1)),t=pe(this,a,1),this.precision=r,this.rounding=i,n=e.s<0?n.minus(t):n.plus(t)):n=this.atan(oe(e,t,a,1)):(n=pe(this,a,1).times(t.s>0?.25:.75)).s=e.s:n=new this(NaN),n}function Ne(e){return new this(e).cbrt()}function Le(e){return le(e=new this(e),e.e+1,2)}function Je(e,t,n){return new this(e).clamp(t,n)}function _e(e){if(!e||"object"!=typeof e)throw Error(G+"Object expected");var t,n,r,i=!0===e.defaults,a=["precision",1,N,"rounding",0,8,"toExpNeg",-M,0,"toExpPos",0,M,"maxE",0,M,"minE",-M,0,"modulo",0,9];for(t=0;t<a.length;t+=3)if(n=a[t],i&&(this[n]=F[n]),void 0!==(r=e[n])){if(!(W(r)===r&&r>=a[t+1]&&r<=a[t+2]))throw Error(q+n+": "+r);this[n]=r}if(n="crypto",i&&(this[n]=F[n]),void 0!==(r=e[n])){if(!0!==r&&!1!==r&&0!==r&&1!==r)throw Error(q+n+": "+r);if(r){if(!(typeof crypto<"u"&&crypto&&(crypto.getRandomValues||crypto.randomBytes)))throw Error(U);this[n]=!0}else this[n]=!1}return this}function Fe(e){return new this(e).cos()}function Ve(e){return new this(e).cosh()}function Ge(e,t){return new this(e).div(t)}function qe(e){return new this(e).exp()}function Ye(e){return le(e=new this(e),e.e+1,3)}function Ue(){var e,t,n=new this(0);for(V=!1,e=0;e<arguments.length;)if((t=new this(arguments[e++])).d)n.d&&(n=n.plus(t.times(t)));else{if(t.s)return V=!0,new this(1/0);n=t}return V=!0,n.sqrt()}function Be(e){return e instanceof ht||e&&e.toStringTag===B||!1}function We(e){return new this(e).ln()}function ze(e,t){return new this(e).log(t)}function Qe(e){return new this(e).log(2)}function $e(e){return new this(e).log(10)}function Ze(){return be(this,arguments,-1)}function He(){return be(this,arguments,1)}function Xe(e,t){return new this(e).mod(t)}function et(e,t){return new this(e).mul(t)}function tt(e,t){return new this(e).pow(t)}function nt(e){var t,n,r,i,a=0,s=new this(1),o=[];if(void 0===e?e=this.precision:ie(e,1,N),r=Math.ceil(e/7),this.crypto)if(crypto.getRandomValues)for(t=crypto.getRandomValues(new Uint32Array(r));a<r;)(i=t[a])>=429e7?t[a]=crypto.getRandomValues(new Uint32Array(1))[0]:o[a++]=i%1e7;else{if(!crypto.randomBytes)throw Error(U);for(t=crypto.randomBytes(r*=4);a<r;)(i=t[a]+(t[a+1]<<8)+(t[a+2]<<16)+((127&t[a+3])<<24))>=214e7?crypto.randomBytes(4).copy(t,a):(o.push(i%1e7),a+=4);a=r/4}else for(;a<r;)o[a++]=1e7*Math.random()|0;for(e%=7,(r=o[--a])&&e&&(i=z(10,7-e),o[a]=(r/i|0)*i);0===o[a];a--)o.pop();if(a<0)n=0,o=[0];else{for(n=-1;0===o[0];n-=7)o.shift();for(r=1,i=o[0];i>=10;i/=10)r++;r<7&&(n-=7-r)}return s.e=n,s.d=o,s}function rt(e){return le(e=new this(e),e.e+1,this.rounding)}function it(e){return(e=new this(e)).d?e.d[0]?e.s:0*e.s:e.s||NaN}function at(e){return new this(e).sin()}function st(e){return new this(e).sinh()}function ot(e){return new this(e).sqrt()}function lt(e,t){return new this(e).sub(t)}function dt(){var e=0,t=arguments,n=new this(t[e]);for(V=!1;n.s&&++e<t.length;)n=n.plus(t[e]);return V=!0,le(n,this.precision,this.rounding)}function ct(e){return new this(e).tan()}function ut(e){return new this(e).tanh()}function pt(e){return le(e=new this(e),e.e+1,1)}ne[Symbol.for("nodejs.util.inspect.custom")]=ne.toString,ne[Symbol.toStringTag]="Decimal";var ht=ne.constructor=function e(t){var n,r,i;function a(e){var t,n,r,i=this;if(!(i instanceof a))return new a(e);if(i.constructor=a,Be(e))return i.s=e.s,void(V?!e.d||e.e>a.maxE?(i.e=NaN,i.d=null):e.e<a.minE?(i.e=0,i.d=[0]):(i.e=e.e,i.d=e.d.slice()):(i.e=e.e,i.d=e.d?e.d.slice():e.d));if("number"===(r=typeof e)){if(0===e)return i.s=1/e<0?-1:1,i.e=0,void(i.d=[0]);if(e<0?(e=-e,i.s=-1):i.s=1,e===~~e&&e<1e7){for(t=0,n=e;n>=10;n/=10)t++;return void(V?t>a.maxE?(i.e=NaN,i.d=null):t<a.minE?(i.e=0,i.d=[0]):(i.e=t,i.d=[e]):(i.e=t,i.d=[e]))}return 0*e!=0?(e||(i.s=NaN),i.e=NaN,void(i.d=null)):Ee(i,e.toString())}if("string"===r)return 45===(n=e.charCodeAt(0))?(e=e.slice(1),i.s=-1):(43===n&&(e=e.slice(1)),i.s=1),H.test(e)?Ee(i,e):function(e,t){var n,r,i,a,s,o,l,d,c;if(t.indexOf("_")>-1){if(t=t.replace(/(\d)_(?=\d)/g,"$1"),H.test(t))return Ee(e,t)}else if("Infinity"===t||"NaN"===t)return+t||(e.s=NaN),e.e=NaN,e.d=null,e;if($.test(t))n=16,t=t.toLowerCase();else if(Q.test(t))n=2;else{if(!Z.test(t))throw Error(q+t);n=8}for((a=t.search(/p/i))>0?(l=+t.slice(a+1),t=t.substring(2,a)):t=t.slice(2),s=(a=t.indexOf("."))>=0,r=e.constructor,s&&(a=(o=(t=t.replace(".","")).length)-a,i=me(r,new r(n),a,2*a)),a=c=(d=se(t,n,X)).length-1;0===d[a];--a)d.pop();return a<0?new r(0*e.s):(e.e=ce(d,c),e.d=d,V=!1,s&&(e=oe(e,i,4*o)),l&&(e=e.times(Math.abs(l)<54?z(2,l):ht.pow(2,l))),V=!0,e)}(i,e);if("bigint"===r)return e<0?(e=-e,i.s=-1):i.s=1,Ee(i,e.toString());throw Error(q+e)}if(a.prototype=ne,a.ROUND_UP=0,a.ROUND_DOWN=1,a.ROUND_CEIL=2,a.ROUND_FLOOR=3,a.ROUND_HALF_UP=4,a.ROUND_HALF_DOWN=5,a.ROUND_HALF_EVEN=6,a.ROUND_HALF_CEIL=7,a.ROUND_HALF_FLOOR=8,a.EUCLID=9,a.config=a.set=_e,a.clone=e,a.isDecimal=Be,a.abs=xe,a.acos=Te,a.acosh=Ae,a.add=Oe,a.asin=De,a.asinh=Ce,a.atan=Re,a.atanh=Pe,a.atan2=Me,a.cbrt=Ne,a.ceil=Le,a.clamp=Je,a.cos=Fe,a.cosh=Ve,a.div=Ge,a.exp=qe,a.floor=Ye,a.hypot=Ue,a.ln=We,a.log=ze,a.log10=$e,a.log2=Qe,a.max=Ze,a.min=He,a.mod=Xe,a.mul=et,a.pow=tt,a.random=nt,a.round=rt,a.sign=it,a.sin=at,a.sinh=st,a.sqrt=ot,a.sub=lt,a.sum=dt,a.tan=ct,a.tanh=ut,a.trunc=pt,void 0===t&&(t={}),t&&!0!==t.defaults)for(i=["precision","rounding","toExpNeg","toExpPos","maxE","minE","modulo","crypto"],n=0;n<i.length;)t.hasOwnProperty(r=i[n++])||(t[r]=this[r]);return a.config(t),a}(F);J=new ht(J),_=new ht(_);var yt=ht},(e,t,n)=>{"use strict";n.r(t),n.d(t,{agentRegistry:()=>r});const r={echo:()=>n.e(1).then(n.bind(n,274))}}],t={};function n(r){var i=t[r];if(void 0!==i)return i.exports;var a=t[r]={id:r,loaded:!1,exports:{}};return e[r].call(a.exports,a,a.exports,n),a.loaded=!0,a.exports}n.m=e,n.n=e=>{var t=e&&e.__esModule?()=>e.default:()=>e;return n.d(t,{a:t}),t},n.d=(e,t)=>{for(var r in t)n.o(t,r)&&!n.o(e,r)&&Object.defineProperty(e,r,{enumerable:!0,get:t[r]})},n.f={},n.e=e=>Promise.all(Object.keys(n.f).reduce((t,r)=>(n.f[r](e,t),t),[])),n.u=e=>e+".worker-1VsTvM69je7rIagmlxVoo.js",n.g=function(){if("object"==typeof globalThis)return globalThis;try{return this||new Function("return this")()}catch(e){if("object"==typeof window)return window}}(),n.hmd=e=>((e=Object.create(e)).children||(e.children=[]),Object.defineProperty(e,"exports",{enumerable:!0,set:()=>{throw new Error("ES Modules may not assign module.exports or exports.*, Use ESM export syntax, instead: "+e.id)}}),e),n.o=(e,t)=>Object.prototype.hasOwnProperty.call(e,t),n.r=e=>{"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})},(()=>{var e;n.g.importScripts&&(e=n.g.location+"");var t=n.g.document;if(!e&&t&&(t.currentScript&&(e=t.currentScript.src),!e)){var r=t.getElementsByTagName("script");if(r.length)for(var i=r.length-1;i>-1&&!e;)e=r[i--].src}if(!e)throw new Error("Automatic publicPath is not supported in this browser");e=e.replace(/#.*$/,"").replace(/\?.*$/,"").replace(/\/[^\/]+$/,"/"),n.p=e})(),(()=>{var e={0:1};n.f.i=(t,r)=>{e[t]||importScripts(n.p+n.u(t))};var t=self.webpackChunkeverhood_platform=self.webpackChunkeverhood_platform||[],r=t.push.bind(t);t.push=t=>{var[i,a,s]=t;for(var o in a)n.o(a,o)&&(n.m[o]=a[o]);for(s&&s(n);i.length;)e[i.pop()]=1;r(t)}})(),(()=>{const{Worker:e}=n(1),t=n(19),{PrismaClient:r}=n(269),{agentRegistry:i}=n(273),a=new r,s=new e("agent-jobs",async e=>{const{agentInstanceId:t,input:n,mode:r,userId:s}=e.data;try{const e=await a.agentInstance.findUnique({where:{id:t,userId:s},include:{agent:!0}});if(!e)throw new Error(`Agent instance not found: ${t}`);const o=i[e.agent.type];if(!o)throw new Error(`Agent not found in registry: ${e.agent.type}`);const l=await o(),d=await l.run(n,r,s);await a.user.update({where:{id:s},data:{currentMonthExecutionCount:{increment:1}}});const c=await a.user.findUnique({where:{id:s}});if(c.stripeSubscriptionId){const e=(await stripe.subscriptions.retrieve(c.stripeSubscriptionId)).items.data[0];e&&await stripe.subscriptionItems.createUsageRecord(e.id,{quantity:1,action:"increment"})}await a.log.create({data:{agentInstanceId:t,userId:s,input:n,output:d,status:"completed"}}),console.log("Agent job completed:",d)}catch(e){throw console.error("Error processing agent job:",e),await a.log.create({data:{agentInstanceId:t,userId:s,input:n,output:{error:e.message},status:"failed"}}),e}},{connection:new t(process.env.REDIS_URL||"redis://localhost:6379")});s.on("completed",e=>{console.log(`Job ${e.id} has completed!`)}),s.on("failed",(e,t)=>{console.error(`Job ${e.id} has failed with error:`,t)})})()})();